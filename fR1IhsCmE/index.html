<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[listen]的个人博客">
<meta name="author" content="kveln">
<title>10. C语言进阶--指针进阶 | listen</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="10. C语言进阶--指针进阶 | listen » Feed"
  href="https://listen2022.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://listen2022.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="10. C语言进阶--指针进阶" />
  <meta property="og:url" content="https://listen2022.github.io/fR1IhsCmE/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="listen" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://listen2022.github.io">listen</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://listen2022.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://support.qq.com/products/378935" target="_blank">反馈</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1643726337720"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://listen2022.github.io">listen</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://listen2022.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://support.qq.com/products/378935" target="_blank">反馈</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1643726337720"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://listen2022.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
              </span>
              <h1>10. C语言进阶--指针进阶</h1>
              <span class="meta">
                Posted on
                2022-02-01，44 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <h1 id="2-指针进阶">2. 指针进阶</h1>
<h2 id="21-字符指针">2.1 字符指针</h2>
<h4 id="211-介绍">2.1.1 介绍</h4>
<pre><code class="language-C">char c = 'h';
char* pc = &amp;c;
// 访问权限为1bbyte
// ++/--为1byte
</code></pre>
<h4 id="212-例">2.1.2 例</h4>
<pre><code class="language-C">int main()
{
  char str1[] = &quot;Hello World!&quot;;
  char str2[] = &quot;Hello World!&quot;;
  char* str3 = &quot;Hello World!&quot;;
  char* str4 = &quot;Hello World!&quot;;
  // 将常量字符串的首字母H存放到指针变量str中
  // 常量是不可修改的
  // 在内存中只需要存在一份
  // 所以str3和str4指向的是同一块内存区域
  // 则str3和str4的指针值相等
  if (str1 == str2)
  {
    printf(&quot;same\n&quot;);
  }else {
    printf(&quot;not same\n&quot;);
  }

  if (str3== str4)
  {
    printf(&quot;same\n&quot;);
  }
  else {
    printf(&quot;not same\n&quot;);
  }
  return 0;
}
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image.png)<br>
<img src="https://listen2022.github.io/post-images/1643676779010.png" alt="" loading="lazy"></p>
<h2 id="22-数组指针">2.2 数组指针</h2>
<blockquote>
<p>指向数组的指针。</p>
</blockquote>
<h4 id="221-格式">2.2.1 格式</h4>
<pre><code class="language-C">int arr[10] = { 0 };
int (*p)[10] = &amp;arr;
// p 变量名
// *表示p是一个指针
// [10]表示该指针指向一个数组
// int 表示该指针指向的数组每个元素的类型为int


 // 注意 int (*p)[10] 与 int *p[10] 区分
 // 如果没有小括号 p先于[]结合 成数组
 // 若有小括号p先于*结合 成指针
</code></pre>
<h4 id="222-数组名">2.2.2 数组名</h4>
<pre><code class="language-C">// 数组名是数组首元素的地址
// 但是有2个例外
// 1. sizeof(arr) 数组名表示整个数组，计算的是整个数组大小，单位是字节
// 2. &amp;arr 数组名表示整个数组，取出的是整个数组的地址
</code></pre>
<h4 id="223-arr和arr">2.2.3 arr和&amp;arr</h4>
<pre><code class="language-C">int main()
{
  int arr[10] = { 0 };
  printf(&quot;arr:   %p\n&quot;, arr);
  printf(&quot;arr+1: %p\n&quot;, arr + 1);
  printf(&quot;&amp;arr:  %p\n&quot;, &amp;arr);
  printf(&quot;&amp;arr+1:%p\n&quot;, &amp;arr + 1);
  return 0;
}

// arr是数组首元素的地址
// &amp;arr是数组指针
// 指针值相同，但含义完全不同
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_1.png)<br>
<img src="https://listen2022.github.io/post-images/1643676788094.png" alt="" loading="lazy"></p>
<h4 id="224-应用">2.2.4 应用</h4>
<pre><code class="language-C">// 数组指针一般用于二维数组中，在一维数组中体现不出优势

// 普通方法
void print1(int arr[3][4], int r, int c)
{
  int i = 0;
  int j = 0;
  for ( i = 0; i &lt; r; i++)
  {
    for (j = 0; j &lt; c; j++)
    {
      printf(&quot;%d &quot;, arr[i][j]);
    }
    printf(&quot;\n&quot;);
  }
}

// 数组指针
void print2(int(*p)[4], int r, int c)
{
  int i = 0;
  int j = 0;
  for (i = 0; i &lt; r; i++)
  {
    for (j = 0; j &lt; c; j++)
    {
      printf(&quot;%d &quot;, *(*(p+i) + j));
    }
    printf(&quot;\n&quot;);
  }
}

int main()
{
  int arr[3][4] = { 
    { 1, 2, 3, 4 }, 
    { 11, 22, 33, 44 },
    { 111, 222, 333, 444} 
  };
  print1(arr, 3, 4);
  print2(arr, 3, 4); 
  // arr数组名，传递的是数组首元素的地址
  // 对于二维数组，则首元素就是第一行的一维数组
  // 则arr为一维数组指针
  // print2函数的需要使用数组指针接收
  return 0;
}
</code></pre>
<h4 id="225-类型判断">2.2.5 类型判断</h4>
<pre><code class="language-C">int (*parr1)[10];
// parr1是数组指针变量
// 该指针指向元素个数为10、每个元素为int类型的数组

int (*parr2[10])[5];
// parr2先和[10]结合 所以parr2是一个数组
// 数组的类型为 int (*)[5]; 是数组指针
// 则parr2是一个存储10个数组指针的数组
// 且每个数组指针指向元素类型为int、元素个数为5的数组
</code></pre>
<h2 id="23-指针数组">2.3 指针数组</h2>
<h4 id="231-介绍">2.3.1 介绍</h4>
<pre><code class="language-C">int* arr1[10]; // 整形指针的数组
char *arr2[4]; // 一级字符指针的数组
char **arr3[5]; // 二级字符指针的数组
</code></pre>
<h4 id="232-例">2.3.2 例</h4>
<pre><code class="language-C">int main()
{
  int a[] = {1, 2, 3, 4, 5};
  int b[] = {11, 22 ,33, 44, 55};
  int c[] = {111, 222 ,333, 444, 555};
  int* arr[] = { a, b, c };
  for (int i = 0; i &lt; 3; i++)
  {
    for (int j = 0; j &lt; 5; j++) {
      printf(&quot;%d &quot;, arr[i][j]);
      printf(&quot;%d &quot;, *(arr[i] + j));
    }
    printf(&quot;\n&quot;);
  }
  return 0;
}
// 模拟二维指针
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_2.png)<br>
<img src="https://listen2022.github.io/post-images/1643676797057.png" alt="" loading="lazy"></p>
<h2 id="24-数组传参和指针传参">2.4 数组传参和指针传参</h2>
<h4 id="241-一维数组传参">2.4.1 一维数组传参</h4>
<pre><code class="language-C">void test1(int arr[]) {} // 数组(省略大小)
// √

void test1(int arr[10]) {} // 数组(未省略大小)
// √

void test1(int *arr) {} // int指针
// √

void test2(int *arr[]) {} // 指针数组(省略大小)
// √

void test2(int **arr) {} // 二级指针
// √

int main()
{
  int arr1[5] = { 0 }; // 一维整形数组
  int* arr2[35] = { 0 }; // 一维整形指针数组
  test1(arr1);
  test2(arr2);
}
</code></pre>
<h4 id="242-二维数组传参">2.4.2 二维数组传参</h4>
<pre><code class="language-C">void test(int arr[3][4]) {} // 二维数组（未省略）
// √

void test(int arr[][]) {} // 二维数组（行列都省略）
// ×

void test(int arr[][4]) {} // 二维数组（行省略）
// √
// 总结：二维数组传参，函数形参的设计只能省略第一个[]的数组
//      因为对一个二维数组，可以不知道有多少行，但必须一行有多少个元素
//      方便运算

void test(int *arr) {} // int指针（传递过来的是第一行数组的指针）
// ×

void test(int *arr[4]) {} // 指针数组
// ×

void test(int (*arr)[4]) {} // 数组指针
// √

void test(int **arr) {} // 二级指针
// ×

int main()
{
  int arr[3][4] = { 0 };
  test(arr);
  return 0;
}
</code></pre>
<h4 id="243-一级指针传参">2.4.3 一级指针传参</h4>
<pre><code class="language-C">// eg:
void print(int* ptr, int sz)
{
  int i = 0;
  for (i = 0; i &lt; sz; i++)
  {
    printf(&quot;%d &quot;, *(ptr + i));
  }
}

int main()
{
  int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
  int* p = arr;
  int sz = sizeof(arr) / sizeof(arr[0]);
  print(p, sz);
  return 0;
}

// 当函数的形参为指针时
// 实参可以是对应类型变量的地址 &amp;var
//    也可以是一级指针变量 ptr
</code></pre>
<h4 id="244-二级指针传参">2.4.4 二级指针传参</h4>
<pre><code class="language-C">void print(int** ptr)
{
  // ...
}

int main()
{
  // 指针数组首元素
  int* arr[10] = { 0 };
  int** p = arr;
  print(p);

  // 二级指针变量
  int a = 7;
  int* pa = &amp;a;
  int** ppa = &amp;pa;
  print(ppa);
  print(&amp;pa);
  return 0;
}

// 当函数的形参是二级指针时
// 实参可以是指针数组首元素
//    也可以是二级指针变量
</code></pre>
<h2 id="25-函数指针">2.5 函数指针</h2>
<h4 id="251-介绍">2.5.1 介绍</h4>
<blockquote>
<p>指向函数的指针。存放函数地址的指针。</p>
</blockquote>
<pre><code class="language-C">int Add(int x, int y)
{
  return x + y;
}

int main()
{
  printf(&quot;%p\n&quot;, &amp;Add);
  printf(&quot;%p\n&quot;, Add);
  // 两种打印方式打印结果相同
  // 都是函数的地址
  // Add和&amp;Add完全等价
  // 函数名本质上就是地址
  return 0;
}
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_3.png)<br>
<img src="https://listen2022.github.io/post-images/1643676808136.png" alt="" loading="lazy"></p>
<h4 id="252-格式">2.5.2 格式</h4>
<pre><code class="language-C">返回值类型 (*函数指针变量)(参数类型);

// eg:
int (*pf)(int, int) = &amp;Add;
int (*pf)(int, int) = Add;
// * 表示pf是一个指针变量
// () 表示该指针指向一个函数
// (int, int) 表示指针指向的函数的参数类型
// int (*pf) 前面的int表示指针指向的函数的返回值类型
</code></pre>
<h4 id="253-调用">2.5.3 调用</h4>
<pre><code class="language-C">int Add(int x, int y)
{
  return x + y;
}

int main()
{
  int (*pf)(int, int) = Add; // Add === pf
  int ret1 = (*pf)(1, 2); 
  // 其中pf前的*只是摆设 可以省略 也可以有多个
  int ret2 = pf(2, 3);
  int ret3 = Add(3, 4);
  return 0;
}
</code></pre>
<h4 id="254-应用">2.5.4 应用</h4>
<ul>
<li>
<p>代码一</p>
<pre><code class="language-C">(*(void (*)())0)();
// 调用0地址处的函数
// 该函数无参，返回值类型为void
// 1. void(*)() - 函数指针类型
// 2. (void(*)())0 - 将0强制类型转换为函数指针类型 即函数地址
// 3. *(void (*)())0 - 将该函数地址进行指针解引用
// 4. (*(void (*)())0)() - 调用0地址处的函数
</code></pre>
</li>
<li>
<p>代码二</p>
<pre><code class="language-C">void (* signal(int, void(*)(int)))(int);
// 1. signal和()先结合 说明signal是一个函数名
// 2. signal函数的参数是一个int和函数指针
//    该函数指针类型 void(*)(int) 指向参数为int 返回值类型为void的函数
// 3. signal函数的返回类型为函数指针
//    将void (* signal(int, void(*)(int)))(int); 中的 signal(int, void(*)(int)) 剔除
//    结果为void (*)(int) 即为函数的返回类型
//    该函数指针类型 void(*)(int) 指向参数为int 返回值类型为void的函数
// 总结：signal是一个 参数为int和函数指针 返回类型为函数指针 的函数声明

// 简化如下（含义相同 表达更清晰）
typedef void(*func_ptr)(int);
func_ptr signal(int, func_ptr);
</code></pre>
<p>![代码片段来源：C陷阱和缺陷（15页）](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_4.png)<br>
<img src="https://listen2022.github.io/post-images/1643676821857.png" alt="代码片段来源：C陷阱和缺陷（15页）" loading="lazy"></p>
</li>
</ul>
<h2 id="26-函数指针数组">2.6 函数指针数组</h2>
<h4 id="261-介绍">2.6.1 介绍</h4>
<blockquote>
<p>存放函数指针的数组。</p>
</blockquote>
<pre><code class="language-C">// 定义：
// 函数指针
int (*fp)(int, int);
// fp为指针变量，*表示该变量为指针，其余 int (int, int) 为函数指针指向的函数类型

// 函数指针数组
int (*arr[5])(int, int);
// arr3为数组名，其余 int (* [5])(int, int) 为数组类型，int (* )(int, int) 为数组元素类型
</code></pre>
<h4 id="262-应用">2.6.2 应用</h4>
<blockquote>
<p>计算器实现</p>
</blockquote>
<ul>
<li>
<p>基本实现</p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;

void menu()
{
  // 打印菜单
  printf(&quot;*************************\n&quot;);
  printf(&quot;**** 两位数加减乘除 *****\n&quot;);
  printf(&quot;*************************\n&quot;);
  printf(&quot;**** 1.add    2.sub *****\n&quot;);
  printf(&quot;**** 3.mul    4.div *****\n&quot;);
  printf(&quot;****     0.exit     *****\n&quot;);
  printf(&quot;*************************\n&quot;);
}

int Add(int x, int y)
{
  return x + y;
}

int Sub(int x, int y)
{
  return x - y;
}

int Mul(int x, int y)
{
  return x * y;
}

int Div(int x, int y)
{
  return x / y;
}

int main() 
{
  int input = 0;
  do
  {
    menu(); // 打印菜单
    printf(&quot;请输入:&gt; &quot;); // 提示
    scanf(&quot;%d&quot;, &amp;input); // 获取用户输入 
    int x = 0;
    int y = 0;
    int ret = 0;
    switch (input) // 确定计算规则
    {
    case 1:
      scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据
      ret = Add(x, y); // 相加
      printf(&quot;结果是：%d\n&quot;, ret);
      break;
    case 2:
      scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据
      ret = Sub(x, y); // 相减
      printf(&quot;结果是：%d\n&quot;, ret);
      break;
    case 3:
      scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据
      ret = Mul(x, y); // 相乘
      printf(&quot;结果是：%d\n&quot;, ret);
      break;
    case 4:
      scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据
      ret = Div(x, y); // 相除
      printf(&quot;结果是：%d\n&quot;, ret);
      break;
    case 0:
      break;
    default:
      printf(&quot;输入错误，请重新输入！\n&quot;);
      break;
    }

  } while (input);
}
</code></pre>
</li>
<li>
<p>函数指针数组实现</p>
<blockquote>
<p>在上面代码的switch语句中发现有大量的代码冗余，接下来通过函数指针数组对main函数进行重写。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int input = 0;
  do
  {
    menu(); // 打印菜单
    printf(&quot;请输入:&gt; &quot;); // 提示
    scanf(&quot;%d&quot;, &amp;input); // 获取用户输入 
    // 创建函数指针数组
    int (*pfarr[5])(int, int) = { NULL, Add, Sub, Mul, Div };
    // 数组首元素使用NULL补位，使得input值为数组下标 恰好对应相应的函数
    if (input == 1 || input == 2 || input == 3 || input == 4)
    {
      int x = 0;
      int y = 0;
      int ret = 0;
      scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
      ret = pfarr[input](x, y);
      printf(&quot;结果是：%d\n&quot;, ret);
    }
    else if (input == 0)
    {
      break;
    }
    else
    {
      printf(&quot;输入错误，重新输入！\n&quot;);
    }
  } while (input);
}
</code></pre>
</li>
</ul>
<p><strong>转移表 -</strong>- 函数指针数组。</p>
<h2 id="27-指向函数指针数组的指针了解">2.7 指向函数指针数组的指针(了解)</h2>
<blockquote>
<p>指向函数指针数组的指针 指针指向一个数组 数组的每个元素是函数指针</p>
</blockquote>
<h4 id="271-指向整形数组的指针">2.7.1 指向整形数组的指针</h4>
<pre><code class="language-C">// 1.整形数组
int arr1[5];
// arr1为数组名，其余 int [5] 为数组类型，int为数组元素类型

// 2.整形数组的指针
int(*parr1)[5] = &amp;arr1;
// parr1为指针变量，*表示该变量为指针，其余 int [5] 为指针指向的对象的类型
</code></pre>
<h4 id="272-指向整形指针数组的指针">2.7.2 指向整形指针数组的指针</h4>
<pre><code class="language-C">// 1.整形指针数组
int* arr2[5];
// arr2为数组名，其余int* [5] 为数组类型，int*为数组元素的类型

// 2.整形指针数组的指针
int* (*parr2)[5] = &amp;arr2;
// parr2为指针变量，*表示该变量为指针，其余 int* [5] 为指针指向的对象的类型
</code></pre>
<h4 id="273-指向函数指针数组的指针">2.7.3 指向函数指针数组的指针</h4>
<pre><code class="language-C">// 1.函数指针
int (*fp)(int, int);
// fp为指针变量，*表示该变量为指针，其余 int (int, int) 为函数指针指向的函数类型

// 2.函数指针数组
int (*arr3[5])(int, int);
// arr3为数组名，其余 int (* [5])(int, int) 为数组类型，int (* )(int, int) 为数组元素类型

// 3.函数指针数组的指针
int (*(*parr3)[5])(int, int) = &amp;arr3;
// parr3为指针变量，*表示该变量为指针，其余 int (* [5])(int, int) 为指针指向对象的类型
</code></pre>
<h2 id="28-回调函数">2.8 回调函数</h2>
<blockquote>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，这就是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
</blockquote>
<h4 id="281-再次重写计算器">2.8.1 再次重写计算器</h4>
<blockquote>
<p>根据回调函数再次重写计算器实例的main函数</p>
</blockquote>
<pre><code class="language-C">int Cal(int (*fp)(int, int)) // 形参为函数指针类型int (* )(int, int)
{
  int x = 0;
  int y = 0;
  scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
  return fp(x, y);
}

int main()
{
  int input = 0;
  do
  {
    menu(); // 打印菜单
    printf(&quot;请输入:&gt; &quot;); // 提示
    scanf(&quot;%d&quot;, &amp;input); // 获取用户输入 
    int (*pfarr[5])(int, int) = { NULL, Add, Sub, Mul, Div };  // 数组指针
    if (input == 1 || input == 2 || input == 3 || input == 4)
    {
      int ret = Cal(pfarr[input]); // 将函数指针作为参数进行传递
      printf(&quot;结果是：%d\n&quot;, ret);
    }
    else if (input == 0)
    {
      break;
    }
    else
    {
      printf(&quot;输入错误，重新输入！\n&quot;);
    }
  } while (input);
}
</code></pre>
<h4 id="282-模拟实现qsort库函数">2.8.2 模拟实现qsort库函数</h4>
<blockquote>
<p>qsort底层是快速排序。此处只需关注如何使用，即qsort函数的参数和返回值。所以使用冒泡排序实现相同使用方法的该函数。</p>
</blockquote>
<ul>
<li>
<p><strong>介绍</strong></p>
<ul>
<li>
<p>头文件&lt;stdlib.h&gt;</p>
</li>
<li>
<p>语法</p>
<pre><code class="language-C">void qsort(
   void *base,
   size_t number,
   size_t width,
   int (__cdecl *compare )(const void *, const void *)
);
</code></pre>
</li>
<li>
<p>参数</p>
<ul>
<li>base：数组的起始地址</li>
<li>number：数组中元素的个数</li>
<li>width：数组中元素的大小（单位：byte）</li>
<li>compare：一个指向用户提供的函数的指针，该函数比较数组两个元素并返回一个值，改值表示他们之间的关系</li>
</ul>
</li>
<li>
<p>compare</p>
<pre><code class="language-C">compare( (void *) &amp; elem1, (void *) &amp; elem2 );
</code></pre>
<table>
<thead>
<tr>
<th>比较返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;0</td>
<td>elem1&lt;elem2</td>
</tr>
<tr>
<td>=0</td>
<td>elem1=elem2</td>
</tr>
<tr>
<td>&gt;0</td>
<td>elem1&gt;elem2</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<pre><code>    &gt; 数组按递增排序，如果要对数组进行递减排序，反转 比较返回值 中的`&gt;`和`&lt;`
</code></pre>
<ul>
<li>
<p>使用实例</p>
<ul>
<li>
<p>比较整形</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int compare_int(const void* e1, const void* e2)
{
  return *(int*)e1 - *(int*)e2;
}

int main()
{
  int arr[] = {5,3,1,2,4,6};
  int num = 0;
  num = sizeof(arr) / sizeof(arr[0]);
  qsort(arr, num, 4, compare_int);
  for (int i = 0; i &lt; 6; i++)
  {
    printf(&quot;%d &quot;, arr[i]);
  }
  return 0;
}

// void*类型可以存放任意类型地址
// 但是不能解引用和计算（解引用时，并不清楚访问几个字节）
// 使用时需要强制类型转换为需求的类型指针
</code></pre>
</li>
<li>
<p>比较字符串</p>
<pre><code class="language-C">// 字符串比较大小时，按位比较字符的ASCII码
// 如果字符串长度不相等，如&quot;ab&quot;和&quot;abc&quot;比较
// 'a'和'a'比较 相等 右移
// 'b'和'b'比较 相等 右移
// '\0'和'c'比较 '\0'&lt;'c' &quot;ab&quot;&lt;&quot;abc&quot;
#define _CRT_NONSTDC_NO_DEPRECATE
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int compare_string(const void* e1, const void* e2)
{
  return stricmp(*(char**)e1, *(char**)e2);
}
int main()
{
  char* arr[] = { &quot;afd&quot;,&quot;fasf&quot;,&quot;fadew&quot;,&quot;fdfa&quot;,&quot;rqewr&quot;,&quot;fdasf&quot; };
  int num = 0;
  num = sizeof(arr) / sizeof(arr[0]);
  qsort(arr, num, 4, compare_string);
  for (int i = 0; i &lt; 6; i++)
  {
    printf(&quot;%s &quot;, arr[i]);
  }
  return 0;
}
</code></pre>
</li>
<li>
<p>比较结构体</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

struct Student {
  char name[20];
  int age;
};

int compare_by_name(const void* e1, const void* e2)
{
  return strcmp(((struct Student*)e1)-&gt;name, ((struct Student*)e2)-&gt;name);
}

int compare_by_age(const void* e1, const void* e2)
{
  return (*((struct Student*)e1)).age - (*((struct Student*)e2)).age;
}

print_struct_arr(struct Student arr[], int num)
{
  for (int i = 0; i &lt; 4; i++)
  {
    printf(&quot;name: %s, age: %d\n&quot;, (arr[i]).name, (arr[i]).age);
  }
}

int main()
{
  struct Student arr[4] = { {&quot;listen&quot;, 20},{&quot;turbo&quot;, 34},{&quot;dummy&quot;, 24},{&quot;free&quot;, 19}};
  int num = 0;
  num = sizeof(arr) / sizeof(arr[0]);
  qsort(arr, num, sizeof(arr[0]), compare_by_name);
  printf(&quot;按照姓名排序如下：\n&quot;);
  print_struct_arr(arr, num); // 打印结构体数组
  qsort(arr, num, sizeof(arr[0]), compare_by_age);
  printf(&quot;按照年龄排序如下：\n&quot;);
  print_struct_arr(arr, num); // 打印结构体数组
  return 0;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>冒泡排序实现</strong>（升序为例）</p>
<ul>
<li>
<p>原理图</p>
<blockquote>
<p>描述：当前元素和下一个元素进行比较。如果小于下一个元素，则保持不变；如果大于下一个元素，则交换位置。然后下标+1，再比较，再下标+1，直到比较完倒数第二个元素和最后一个元素，这个过程称为一趟。接着再从头开始进行比较，如下图所示：</p>
</blockquote>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_5.png)<br>
<img src="https://listen2022.github.io/post-images/1643676871102.png" alt="" loading="lazy"></p>
<blockquote>
<p>容易得出：5个数进行排序需要4趟。</p>
</blockquote>
</li>
<li>
<p>代码</p>
<pre><code class="language-C">void bubble_sort(int* p, int num)
{
  for (int i = 0; i &lt; num-1; i++)
  {
    for (int j = 0; j &lt; num-1; j++)
    {
      if (p[j] &gt; p[j+1])
      {
        int tmp = p[j];
        p[j] = p[j + 1];
        p[j + 1] = tmp;
      }
    }
  }
}

int main()
{
  int arr[] = {5,3,1,2,4,6};
  int num = sizeof(arr) / sizeof(arr[0]);
  bubble_sort(arr, num);
  for (int i = 0; i &lt; num; i++)
  {
    printf(&quot;%d &quot;, arr[i]);
  }
  return 0;
}
</code></pre>
</li>
<li>
<p>优化</p>
<blockquote>
<p>第二趟6和8比较 与 前面的6和8比较 重复</p>
</blockquote>
<pre><code>  第三趟4和6比较、6和8比较 与 前面的4和6比较、6和8比较 重复
  第四趟2和4比较、4和6比较、6和8比较 与 前面的2和4比较、4和6比较、6和8比较 重复
  所以：在第二趟中一次重复的比较；在第三趟中二次重复的比较；在第四趟中三次重复的比较。优化的原理就是让每两个数比较只出现一次。
  如图中，圈中的是重复进行比较的两元素。
  ![](image/image_6.png)
  ![](https://listen2022.github.io/post-images/1643676911293.png)
</code></pre>
<pre><code class="language-C">void bubble_sort(int* p, int num)
{
  for (int i = 0; i &lt; num-1; i++)
  {
    for (int j = 0; j &lt; num-i-1; j++)
    {
      if (p[j] &gt; p[j+1])
      {
        int tmp = p[j];
        p[j] = p[j + 1];
        p[j + 1] = tmp;
      }
    }
  }
}

int main()
{
  int arr[] = {5,3,1,2,4,6};
  int num = sizeof(arr) / sizeof(arr[0]);
  bubble_sort(arr, num);
  for (int i = 0; i &lt; num; i++)
  {
    printf(&quot;%d &quot;, arr[i]);
  }
  return 0;
}
</code></pre>
</li>
<li>
<p>增强</p>
<blockquote>
<p>前面的冒泡排序算法只能比较两个整形，现在将冒泡排序功能进行扩展，使其可以比较任何数据类型（参考sqort库函数）。</p>
</blockquote>
<pre><code class="language-C">void bubble_sort(void* p, int num, int width, int (*compare)(const void*, const void*))
{
  for (int i = 0; i &lt; num - 1; i++)
  {
    for (int j = 0; j &lt; num - i - 1; j++)
    {
      // 比较大小，前者&gt;后者返回整数
      if (compare((char*)p + j * width, (char*)p + (j+1) * width) &gt; 0)
      {
        // 交换值
        // 确定大小，但不知道类型 
        // 按字节交换 char类型刚好代表一个字节，总共交换width次
        for (int k = 0; k &lt; width; k++)
        {
          char tmp = *((char*)p + j * width + k);
          *((char*)p + j * width + k) = *((char*)p + (j + 1) * width + k);
          *((char*)p + (j + 1) * width + k) = tmp;
        }
      }
    }
  }
}
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-C">// bubble_sort测试
int compare_int(const void* e1, const void* e2)
{
  return *(int*)e1 - *(int*)e2;
}

int main()
{
  int arr[] = {5,3,1,2,4,6};
  int num = sizeof(arr) / sizeof(arr[0]);
   bubble_sort(arr, num, sizeof(arr[0]), compare_int);
  for (int i = 0; i &lt; num; i++)
  {
    printf(&quot;%d &quot;, arr[i]);
  }
  return 0;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="29-习题">2.9 习题</h2>
<h4 id="291-指针">2.9.1 指针</h4>
<ul>
<li>
<p>int a[] = { 1,2,3,4 };</p>
<pre><code class="language-C">int main()
{
  int a[] = { 1,2,3,4 };
  printf(&quot;%d\n&quot;, sizeof(a)); // 16  
  // 解释：a 单独放在 sizeof() 中时，a 表示整个数组，
  //      计算的是整个数组的大小，整个数组 4 个元素，且数组元素为 int 类型
  //      所以数组大小为 4 × 4 = 16byte

  printf(&quot;%d\n&quot;, sizeof(a + 0)); // 4/8 
  // 解释：a 表示数组首元素的地址，+0 之后依然是数组是首元素的地址，
  //      作为地址在32位计算机中为 4byte，64位系统中为 8byte

  printf(&quot;%d\n&quot;, sizeof(*a)); // 4
  // 解释：a 表示数组首元素的地址，*a 对 a 解引用，得到的是数组首元素 1，
  //      数组元素的类型为 int，所以 *a 的大小为 4byte

  printf(&quot;%d\n&quot;, sizeof(a+1)); // 4/8
  // 解释：a 表示数组首元素的地址，a+1 表示数组第二个元素的地址，
  //      作为地址，其大小为 4byte(32位系统) 或 8byte(64位系统)

  printf(&quot;%d\n&quot;, sizeof(a[1])); // 4
  // 解释：a[1] 表示数组首元素，数组元素的类型为 int，其大小为 4byte

  printf(&quot;%d\n&quot;, sizeof(&amp;a)); // 4/8
  // 解释：&amp;a 中 a 表示的是整个数组，获取的是整个数组的指针
  //     作为地址，其大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(*&amp;a)); // 16
  // 解释：&amp;a 获取的是整个数组的地址，再解引用得到的是整个数组
  //      整个数组的大小为 4 × 4 = 16byte

  printf(&quot;%d\n&quot;, sizeof(&amp;a + 1)); // 4/8
  // 解释：&amp;a 获取的是整个数组的指针，&amp;a+1 跳过一个 int [4] 类型的数组
  //      &amp;a+1 指向数组 arr 之后第一个位置的地址
  //      作为指针，其大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(&amp;a[0])); // 4/8
  // 解释：a[0] 获取数组首元素，&amp;a[0] 对数组首元素取地址，即数组首元素的地址
  //      作为指针，其大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(&amp;a[0] + 1)); // 4/8
  // 解释：易得 &amp;a[0] 为数组首元素的地址，&amp;a[0]+1 跳过一个元素，
  //      即数组第二个元素的地址，作为指针，其大小为 4/8byte
}
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_7.png)<br>
<img src="https://listen2022.github.io/post-images/1643676925910.png" alt="" loading="lazy"></p>
</li>
<li>
<p>char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };</p>
<pre><code class="language-C">#include &lt;string.h&gt;
int main()
{
  char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
  printf(&quot;%d\n&quot;, sizeof(arr)); // 6
  // 解释：arr 表示整个数组，数组共6个元素，且元素类型为 char
  //      所以，数组的大小为 6byte

  printf(&quot;%d\n&quot;, sizeof(arr + 0)); // 4/8
  // 解释：arr 表示数组首元素的地址，arr+0 表示跳过 0byte，
  //      同样是数组首元素的地址，作为指针，其大小为 4 / 8byte
</code></pre>
</li>
</ul>
<pre><code>  printf(&quot;%d\n&quot;, sizeof(*arr)); // 1
  // 解释：arr 表示数组首元素的地址，*arr 对数组首元素的地址解引用
  //      *arr 表示数组首元素，数组元素为char类型，则数组首元素的大小为 1byte

   printf(&quot;%d\n&quot;, sizeof(arr[1])); // 1
  // 解释：arr[1] 表示数组第二个元素，数组元素为char类型，
  //      则数组第二个元素的大小为 1byte

  printf(&quot;%d\n&quot;, sizeof(&amp;arr)); //  4/8
  // 解释：arr 表示整个数组，&amp;arr 对整个数组取地址，
  //      作为地址，其大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(&amp;arr + 1)); // 4/8
  // 解释：arr 表示真个数组，&amp;arr 对整个数组取地址，
  //      &amp;arr+1 表示跳过一个 char [6] 类型数组的大小，
  //      则指向数组后第一个位置的地址，
  //      作为地址，其大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(&amp;arr[0] + 1)); // 4/8
  // 解释：arr[0] 表示数组首元素，&amp;arr[0] 获取数组首元素的地址
  //      &amp;arr[0]+1 跳过一个char类型元素的大小，
  //      则表示数组第二元素的地址，作为地址，其大小为 4/8byte

  printf(&quot;%d\n&quot;, strlen(arr)); // 随机值
  // 解释：arr表示数组首元素的地址，从arr开始向后找 \0 ，
  //      所以，结果为随机值

  printf(&quot;%d\n&quot;, strlen(arr + 1)); // 随机值
  // 解释：arr表示数组首元素的地址，则 arr+1 表示数组第二个元素的地址
  //      从数组第二个元素开始向后查找 \0 ，所以结果为随机值
  //      但相对于上一个随机值，相差1

  //printf(&quot;%d\n&quot;, strlen(*arr)); // error
  //// 解释：arr表示数组首元素的地址，*arr 表示对首元素地址解引用，则得到首元素 'a'
  ////      而 strlen 函数的参数是指针类型，所以 error

  //printf(&quot;%d\n&quot;, strlen(arr[1])); // error
  //// 解释：arr[1] 表示数组第二个元素 'b' ，同样参数类型不否，error

  printf(&quot;%d\n&quot;, strlen(&amp;arr)); // 随机值
  // 解释：&amp;arr 取真个数组的地址，但是其值与数组首元素地址相等
  //      所以，从数组首元素开始向后找 '\0' ，结果为随机值

  printf(&quot;%d\n&quot;, strlen(&amp;arr + 1)); // 随机值
  // 解释：&amp;arr 取整个数组的地址，&amp;arr+1 指向数组后第一个位置的地址
  //     从该位置开始向后找 '\0' 结果为随机值
  //     但相对于上一个随机值，相差6

  printf(&quot;%d\n&quot;, strlen(&amp;arr[0] + 1)); // 随机值
  // 解释：arr[0] 表示数组第一个元素，&amp;arr[0] 对数组第一个元素取地址
  //      &amp;arr[0]+1 跳过一个元素的大小，指向数组第二个元素，
  //      从数组第二个元素开始向后查找 '\0'，结果为随机值

  return 0;
}
```
</code></pre>
<ul>
<li>
<p>char arr[] = &quot;abcdef&quot;;</p>
<pre><code class="language-C">#include &lt;string.h&gt;
int main()
{
  char arr[] = &quot;abcdef&quot;;
  // 等价于 
  //char arr[] = { 'a','b','c','d','e','f','\0' };
  printf(&quot;%d\n&quot;, sizeof(arr)); // 7
  // arr表示真个数组 数组大小为 6×1=7byte

  printf(&quot;%d\n&quot;, sizeof(arr + 0)); // 4/8
  // arr+0=arr 表示数组首元素地址
  // 作为地址 大小为 4/8 byte

  printf(&quot;%d\n&quot;, sizeof(*arr)); // 1
  // arr表示数组首元素地址
  // *arr 表示数组首元素'a' 大小为1byte
   printf(&quot;%d\n&quot;, sizeof(arr[1])); // 1
  // arr[1] 表示数组第二个元素'b' 大小为1byte

  printf(&quot;%d\n&quot;, sizeof(&amp;arr)); // 4/8
  // &amp;arr 获取真个数组arr的地址
  // 作为地址 大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(&amp;arr + 1)); // 4/8
  // &amp;arr 获取真个数组arr的地址
  // &amp;arr+1 跳过一个 char [7] 数组
  // 数组arr后面第一个位置的地址

  printf(&quot;%d\n&quot;, sizeof(&amp;arr[0] + 1)); // 4/8
  // arr[0] 数组首元素
  // &amp;arr[0] 数组首元素地址
  // &amp;arr[0]+1 数组第二个元素地址
  // 作为地址 大小为 4/8byte

  printf(&quot;%d\n&quot;, strlen(arr)); // 6
  // arr数组首元素'a'地址
  // 从该地址开始向后找'\0'
  // strlen 获取从'a'到'\0'的字符串长度6

  printf(&quot;%d\n&quot;, strlen(arr + 1)); // 5
  // arr数组首元素'a'地址
  // arr+1 数组第二个元素'b'地址
  // strlen 获取从'b'到'\0'的字符串长度5

  //printf(&quot;%d\n&quot;, strlen(*arr)); // error
  // arr 数组首元素地址
  // *arr 数组首元素
  // strlen 参数为地址

  //printf(&quot;%d\n&quot;, strlen(arr[1])); // error
  // arr[1] 数组第二个元素
  // strlen 参数为地址

  printf(&quot;%d\n&quot;, strlen(&amp;arr)); // 6
  // &amp;arr 获取整个数组地址 等于数组首元素'a'地址
  // 从该地址开始向后找'\0'
  // strlen函数 从'a'到'\0'的字符串长度6

  printf(&quot;%d\n&quot;, strlen(&amp;arr + 1)); // 随机值
  // &amp;arr 获取整个数组地址 类型为数组指针
  // &amp;arr+1 跳过一个 char [7] 数组 --&gt; 数组arr后第一个位置地址
  // strlen函数 从该位置开始向后找'\0' 而后面的区域未知
  // 所以结果为随机值

  printf(&quot;%d\n&quot;, strlen(&amp;arr[0] + 1)); // 5
  // &amp;arr[0] 等价于 &amp;*(arr+0) 等价于 arr
  // arr+1 表示数组第二个元素'b'地址
  // strlen 从'b'到'\0'的字符串长度5
  return 0;
}
</code></pre>
</li>
<li>
<p>char* p = &quot;abcdef&quot;;</p>
<pre><code class="language-C">#include &lt;string.h&gt;
int main()
{
  char* p = &quot;abcdef&quot;;
  printf(&quot;%d\n&quot;, sizeof(p)); // 4/8
  // p 字符指针 字符串首字符 'a' 的地址
  // 大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(p + 1)); // 4/8 
  // p 字符指针 字符串首字符 'a' 的地址
  // p+1 跳过一个字符 字符串第二个字符 'b' 的地址
  // 大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(*p)); // 1
  // p 字符指针 字符串首字符 'a' 的地址
  // 解引用得到字符'a' 大小为 1byte

  printf(&quot;%d\n&quot;, sizeof(p[0])); // 1 
  // p[0] 等价于 *(p+0)
  // p+0 字符串第1个字符'a'的地址
  // *(p+0) 字符串第1个字符'a' 大小为1byte

  printf(&quot;%d\n&quot;, sizeof(&amp;p)); //  4/8
  // p 字符指针 字符串首字符 'a' 的地址
  // &amp;p 获取字符指针的地址 二级指针
  // 大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(&amp;p + 1)); //  4/8
    // &amp;p 获取字符指针的地址 二级指针
  // &amp;p+1 作为指针 大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(&amp;p[0] + 1)); // 4/8
  // p[0] 字符串第1个字符'a'
  // &amp;p[0] 字符串第1个字符 'a' 的地址
  // &amp;p[0]+1 跳过1个字符 --&gt; 字符串第2个字符'b'地址

  printf(&quot;%d\n&quot;, strlen(p)); // 6
  // p 字符指针 字符串第1个字符'a'地址
  // strlen 获取从'a'到'\0'字符串长度

  printf(&quot;%d\n&quot;, strlen(p + 1)); // 5 
  // p+1 字符串第2个字符'b'地址
  // strlen 获取从'b'到'\0'字符串长度

  //printf(&quot;%d\n&quot;, strlen(*p)); // error
  // *p 字符'a' strlen函数的参数为指针

  //printf(&quot;%d\n&quot;, strlen(p[0])); // error
  // p[0] 字符'a' strlen函数的参数为指针

  printf(&quot;%d\n&quot;, strlen(&amp;p)); // 随机值
  // &amp;p 字符指针p的地址 从p的地址开始向后查找'\0'
  // '\0' 可能再字符指针p中，也可能在其后面
  // 所以 strlen(&amp;p) 为随机值

  printf(&quot;%d\n&quot;, strlen(&amp;p + 1)); // 随机值
  // &amp;p+1 字符指针p后面一个位置的地址
  // 从该位置向后查找 '\0' 后面的区域是未知的
  // 所以 strlen(&amp;p+1) 为随机值

  printf(&quot;%d\n&quot;, strlen(&amp;p[0] + 1)); // 5 
  // &amp;p[0] 相当于 &amp;*(p+0) = p
  // p+1 字符串第2个字符'b'地址
  // 从该地址向后找 '\0' 
  // strlen 获取从'b'到'\0'字符串长度

  return 0;
}
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_8.png)<br>
<img src="https://listen2022.github.io/post-images/1643676940341.png" alt="" loading="lazy"></p>
</li>
<li>
<p>int a[3][4] = { 0 };</p>
</li>
</ul>
<pre><code class="language-C"> #include &lt;stdio.h&gt;
 int main()
 {
  int a[3][4] = { 0 };
  printf(&quot;%d\n&quot;, sizeof(a)); // 48
  // a表示整个数组 大小为 3×4×4=48(byte)

  printf(&quot;%d\n&quot;, sizeof(a[0][0])); // 4
  // a[0][0] 表述数组第一行第一列的元素 int类型 大小为4byte

  printf(&quot;%d\n&quot;, sizeof(a[0])); // 16
  // a[0]表示二维数组a的第一行，大小为4×4=16(byte)

  printf(&quot;%d\n&quot;, sizeof(a[0] + 1)); // 4/8
  // a[0]表示二维数组a的第一行
  // a[0]+1 a[0]为二维数组第一行数组首元素地址
  // +1 跳过1字节 --&gt; 二维数组第一行数组第二个元素地址
  // 地址大小为 4/8byte

  printf(&quot;%d\n&quot;, sizeof(*(a[0] + 1))); // 4
  // *(a[0] + 1) 等价于a[0][1]
  // 表示为二维数组a第一行第二列的元素
  // int类型 大小为 4byte

  printf(&quot;%d\n&quot;, sizeof(a + 1)); // 4/8
  // a 表示数组首元素地址，二维数组的第一行数组的地址
  // a+1 跳过 1个int [4] 类型一维数组 --&gt; 二维数组的第二行地址 
  // 大小为 4/8(byte)

  printf(&quot;%d\n&quot;, sizeof(*(a + 1))); // 16
  // a 表示二维数组第一行地址
  // a+1 跳过 1个int [4] 类型一维数组 --&gt; 二维数组第二行地址
  // *(a+1) 解引用得到二维数组第二行
  // 大小为 4×4=16(byte)

  printf(&quot;%d\n&quot;, sizeof(&amp;a[0] + 1)); // 4/8
  // a[0] 二维数组第一行 
  // &amp;a[0] 二维数组第一行地址
  // &amp;a[0]+1 跳过一个 int [4] 类型一维数组 --&gt; 二维数组第二行地址
  // 大小为 4/8(byte)

  printf(&quot;%d\n&quot;, sizeof(*(&amp;a[0] + 1))); // 16
  // &amp;a[0]+1 二维数组第二行地址
  // *(&amp;a[0]+1) 解引用得到二维数组第二行
  // 大小为 4×4=16(byte)

  printf(&quot;%d\n&quot;, sizeof(*a)); // 16
  // a 二维数组第一行地址
  // *a 二维数组第一行
  // 大小为 4×4=16(byte)

  printf(&quot;%d\n&quot;, sizeof(a[3])); // 16
  // a[3] 类型为int [4]
  // 大小为 4×4=16(byte)
  // sizeof并不会计算括号内的表达式，而是通过类型来确定大小
  // 所以a[3]并不会越界访问

  return 0;
}
</code></pre>
<h4 id="292-练习1">2.9.2 练习1</h4>
<pre><code class="language-C">struct Test
{
  int Num;
  char* pcName;
  short sDate;
  char cha[2];
  short sBa[4];
}*p;

// 假设p的值位0x100000 
// 已知结构体Test的大小位20字节

int main()
{
  printf(&quot;%p\n&quot;, p + 0x1); // 0x100014 结构体指针+1
  printf(&quot;%p\n&quot;, (unsigned long)p + 0x1); // 0x100001 整形+1
  printf(&quot;%p\n&quot;, (unsigned int*)p + 0x1); // 0x100004 整形指针+1 
}
</code></pre>
<h4 id="293-练习2">2.9.3 练习2</h4>
<pre><code class="language-C">int main()
{
  int a[5] = { 1,2,3,4,5 };
  int* ptr = (int*)(&amp;a + 1);
  // &amp;a 获取真个数组的地址
  // &amp;a+1 跳过 int [5] 数组 --&gt; 数组后第一个位置的地址
  // (int*)(&amp;a + 1) 强制类型转换为整形指针 赋值给ptr
  printf(&quot;%d %d\n&quot;, *(a + 1), *(ptr - 1)); // 2 5
  // *(a+1) 等价于 a[1] 等于2
  // ptr-1 向前跳过 int 整形 --&gt; 数组a最后一个元素地址
  // *(ptr-1) 数组a最后一个元素
}
</code></pre>
<h4 id="294-练习3">2.9.4 练习3</h4>
<pre><code class="language-C">int main()
{
  int a[4] = { 1,2,3,4 };
  int* ptr1 = (int*)(&amp;a + 1);
  // ptr1 整形指针
  // 其中 a 表示整个数组，&amp;a 获取整个数组的地址
  // &amp;a+1 是数组a之后第一个位置的地址
  // (int*)(&amp;a+1) 将数组指针强制类型转换为整形指针，并赋值给ptr1
  // ptr1[-1] 等价于 *(ptr1-1)，
  // ptr1-1 将指针向前移动一个int类型的大小(4byte)
  // 即，*(ptr-1) 的值为a[3] = 4;

  int* ptr2 = (int*)((int)a + 1);
  // ptr2 整形指针
  // 其中 a 表示数组首元素的地址，(int)a 将地址强制类型转换为int
  // (int)a+1 则地址数值加1，而内存中每个地址代表1byte
  // 比如：地址是0xFF9A8C11 地址数值 +1 后变为 0xFF9A8C12
  // 即，指向原来指向的地址的后一个字节的地址
  // 所以 (int)a+1 指向如图所示的位置
  // (int*)((int)a+1) 将int型数值强制类型转换为整形指针，并赋值给ptr2
  // 所以 对ptr2解引用 *ptr2 值为 (int*)((int)a+1) 开始向后四个字节的内容

  printf(&quot;%x, %x\n&quot;, ptr1[-1], *ptr2);
  // 输出结果(输出时将数字前无用的零去除)：4，2000000
  return 0;
}
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_9.png)<br>
<img src="https://listen2022.github.io/post-images/1643676955658.png" alt="" loading="lazy"></p>
<h4 id="295-练习4">2.9.5 练习4</h4>
<pre><code class="language-C">int main()
{
  int a[3][2] = { (0,1), (2,3),(4,5) };
  // 注意：{}中是()，所以是逗号表达式
  // 赋值语句相当于 int a[3][2]={ 1,3,5 };

  int* p; 
  // 声明整形指针

  p = a[0]; 
  // 将数组a首元素赋值给p
  // 数组a为二维数组，其首元素为第一行的数组
  // 并赋值给整形指针p，则p的值为第一行数组的首元素的地址

  printf(&quot;%d\n&quot;, p[0]); // 1
  // p[0] 等价于 *(p+0) 对第一行数组首元素地址解引用
  // 值为第一行数组的首元素

  return 0;
}
</code></pre>
<h4 id="296-练习5">2.9.6 练习5</h4>
<pre><code class="language-C">int main()
{
  int a[5][5];
  int(*p)[4];
  // 定义数组指针 指向对象类型为 int [4]
  p = a;
  // 将数组 a 首元素地址赋值给 p
  printf(&quot;%p, %d\n&quot;, &amp;p[4][2] - &amp;a[4][2], &amp;p[4][2] - &amp;a[4][2]);
  // &amp;p[4][2] 等价于 *(p+4)+2
  // p+4 跳过 4×4=16 个元素
  // *(p+4) 对数组指针解引用得到一维数组 p[4]
  // *(p+4)+2 跳过2个整形型元素，即第18个元素的地址
  // 
  // &amp;a[4][2] 等价于 *(a+4)+2
  // a+4 跳过 4×5=20 个元素
  // *(a+4) 解引用得到一维数组 a[4]
  // *(a+4)+2 跳过2个整形元素，即第22个元素的地址
  // 
  // &amp;p[4][2] - &amp;a[4][2] 地址相减是两个地址间元素的个数
  // &amp;p[4][2] 第18个元素的地址
  // &amp;a[4][2] 第22个元素的地址
  // 相减结果为 -4 
  // 在内存中十六进制表示为 FFFFFFFC
  // %p 指针形式打印为 FFFFFFFC 
  // %d 将内存中二进制再转换为整形 打印为 -4
  // FFFFFFFC, -4
  return 0;
}


// 另外：运行时警告 “int (*)[4]”和“int (*)[5]”数组的下标不同
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_10.png)<br>
<img src="https://listen2022.github.io/post-images/1643676976452.png" alt="" loading="lazy"></p>
<h4 id="297-练习6">2.9.7 练习6</h4>
<pre><code class="language-C">int main()
{
  int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
  int* ptr1 = (int*)(&amp;aa + 1);
  // &amp;aa 其中 aa 表示二维数组 获取二维数组的地址
  // &amp;aa+1 跳过整个二维数组 指向二维数组之后第一个位置
  // (int*)(&amp;aa+1)强制类型转换为整形指针 并赋值给 ptr1

  int* ptr2 = (int*)(*(aa + 1));
  // aa 表示二维数组首元素地址--第一行地址
  // aa+1 跳过 int [5] 大小，--第二行地址 
  // *(aa+1) 得到第二行数组--第二行数组首元素地址
  // (int*)(*(aa+1)) 强制类型转换为整形指针 并赋值给 ptr2
  // (不过，本来已经是整形指针，此转换没有必要)

  printf(&quot;%d, %d\n&quot;, *(ptr1 - 1), *(ptr2 - 1));
  // *(ptr1-1) 向前跳 一个整形大小 并解引用 得到二维数组的最后一个元素
  // *(ptr2-1) 向前跳 一个整形大小 并解引用 得到二维数组第一行最后一个元素

  // 输出结果为：10, 5
  return 0;
}
</code></pre>
<h4 id="298-练习7">2.9.8 练习7</h4>
<pre><code class="language-C">int main()
{
  char* a[] = { &quot;work&quot;, &quot;at&quot;, &quot;home&quot; };
  char** pa = a;
  // 数组 a 中元素的类型时 char*
  // a 表示数组首元素的地址 所以a是二级指针 并赋值给pa

  pa++;
  // pa指向的类型为 char* 自增之后 跳过 1个地址的大小
  // 指向数组a第二个元素的地址

  printf(&quot;%s\n&quot;, *pa);
  // 对 pa 解引用，得到数组 a 第二个元素(是一个地址)
  // %s 打印 从该地址*pa开始向后查找'/0' 并打印字符串

  // 输出结果为 &quot;at&quot;
  return 0;
}


// 初始化数组a和二级指针pa之后的内存如下：
</code></pre>
<p>![](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_11.png)<br>
<img src="https://listen2022.github.io/post-images/1643676989289.png" alt="" loading="lazy"></p>
<h4 id="299-练习8">2.9.9 练习8</h4>
<pre><code class="language-C">int main()
{
  char* c[] = { &quot;ENTER&quot;, &quot;NEW&quot;, &quot;POINT&quot;, &quot;FIRST&quot; };
  char** cp[] = { c + 3, c + 2, c + 1, c };
  char*** cpp = cp;
  // 初始化之后的内存情况如果0所示
  printf(&quot;%s\n&quot;, **++cpp); // POINT
  printf(&quot;%s\n&quot;, *-- * ++cpp + 3); // ER
  printf(&quot;%s\n&quot;, *cpp[-2] + 3); // ST
  printf(&quot;%s\n&quot;, cpp[-1][-1] + 1); // EW
  return 0;
}
</code></pre>
<p>![图0](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_12.png)<br>
<img src="https://listen2022.github.io/post-images/1643676999726.png" alt="图0" loading="lazy"></p>
<ul>
<li>
<p>第一个printf</p>
<pre><code class="language-C">  printf(&quot;%s\n&quot;, **++cpp); // POINT
  // ++cpp cpp下移动如图1所示
  // 第一次解引用 得到c+2
  // 第二次解引用得到指向字符串&quot;POINT&quot;的字符指针
  // 则打印字符串 &quot;POINT&quot;
</code></pre>
<p>![图1](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_13.png)<br>
<img src="https://listen2022.github.io/post-images/1643677012066.png" alt="图1" loading="lazy"></p>
</li>
<li>
<p>第二个printf</p>
<pre><code class="language-C">  printf(&quot;%s\n&quot;, *-- * ++cpp + 3); // ER
  // ++cpp cpp下移如图2所示
  // 第一次解引用得到 c+1
  // *-- 得到指向&quot;ENTER&quot;的字符指针
  // +3 跳过3个字符，--&gt; 字符'E'的地址
  // 则打印字符串&quot;ER&quot;
</code></pre>
<p>![图2](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_14.png)<br>
<img src="https://listen2022.github.io/post-images/1643677023451.png" alt="图2" loading="lazy"></p>
</li>
<li>
<p>第三个printf</p>
<pre><code class="language-C">  printf(&quot;%s\n&quot;, *cpp[-2] + 3); // ST
  // *cpp[-2] 相当于 **(cpp-2)，cpp-2 指向如图3所示
  // *(cpp-2) 得到 c+3 
  // **(cpp-2) 得到 指向&quot;FIRST&quot;的字符指针
  // *cpp[-2] + 3 跳过3个字符，--&gt; 字符'S'的地址
</code></pre>
<p>![图3](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_15.png)<br>
<img src="https://listen2022.github.io/post-images/1643677248972.png" alt="图3" loading="lazy"></p>
</li>
<li>
<p>第四个printf</p>
<pre><code class="language-C">  printf(&quot;%s\n&quot;, cpp[-1][-1] + 1); // EW
  // cpp[-1][-1] 相当于 *(*(cpp-1)-1)
  // cpp-1 指向如图4所示 *(cpp-1) 得到c+2
  // *(*(cpp-1)-1) 向后跳一个指针大小 得到指向&quot;NEW&quot;的字符指针
  // cpp[-1][-1] + 1 向后跳过1个字符，--&gt; 字符'E'的地址
  // 则打印字符串 &quot;EW&quot;
</code></pre>
<p>![图4](file://C:\Users\Turbo\Desktop\2. 指针进阶\image\image_16.png)<br>
<img src="https://listen2022.github.io/post-images/1643677151822.png" alt="图4" loading="lazy"></p>
</li>
</ul>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li><a href="#2-%E6%8C%87%E9%92%88%E8%BF%9B%E9%98%B6">2. 指针进阶</a>
<ul>
<li><a href="#21-%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88">2.1 字符指针</a><br>
*
<ul>
<li><a href="#211-%E4%BB%8B%E7%BB%8D">2.1.1 介绍</a></li>
<li><a href="#212-%E4%BE%8B">2.1.2 例</a></li>
</ul>
</li>
<li><a href="#22-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">2.2 数组指针</a><br>
*
<ul>
<li><a href="#221-%E6%A0%BC%E5%BC%8F">2.2.1 格式</a></li>
<li><a href="#222-%E6%95%B0%E7%BB%84%E5%90%8D">2.2.2 数组名</a></li>
<li><a href="#223-arr%E5%92%8Carr">2.2.3 arr和&amp;arr</a></li>
<li><a href="#224-%E5%BA%94%E7%94%A8">2.2.4 应用</a></li>
<li><a href="#225-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">2.2.5 类型判断</a></li>
</ul>
</li>
<li><a href="#23-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">2.3 指针数组</a><br>
*
<ul>
<li><a href="#231-%E4%BB%8B%E7%BB%8D">2.3.1 介绍</a></li>
<li><a href="#232-%E4%BE%8B">2.3.2 例</a></li>
</ul>
</li>
<li><a href="#24-%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82%E5%92%8C%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82">2.4 数组传参和指针传参</a><br>
*
<ul>
<li><a href="#241-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82">2.4.1 一维数组传参</a></li>
<li><a href="#242-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82">2.4.2 二维数组传参</a></li>
<li><a href="#243-%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82">2.4.3 一级指针传参</a></li>
<li><a href="#244-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E5%8F%82">2.4.4 二级指针传参</a></li>
</ul>
</li>
<li><a href="#25-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">2.5 函数指针</a><br>
*
<ul>
<li><a href="#251-%E4%BB%8B%E7%BB%8D">2.5.1 介绍</a></li>
<li><a href="#252-%E6%A0%BC%E5%BC%8F">2.5.2 格式</a></li>
<li><a href="#253-%E8%B0%83%E7%94%A8">2.5.3 调用</a></li>
<li><a href="#254-%E5%BA%94%E7%94%A8">2.5.4 应用</a></li>
</ul>
</li>
<li><a href="#26-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">2.6 函数指针数组</a><br>
*
<ul>
<li><a href="#261-%E4%BB%8B%E7%BB%8D">2.6.1 介绍</a></li>
<li><a href="#262-%E5%BA%94%E7%94%A8">2.6.2 应用</a></li>
</ul>
</li>
<li><a href="#27-%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E4%BA%86%E8%A7%A3">2.7 指向函数指针数组的指针(了解)</a><br>
*
<ul>
<li><a href="#271-%E6%8C%87%E5%90%91%E6%95%B4%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88">2.7.1 指向整形数组的指针</a></li>
<li><a href="#272-%E6%8C%87%E5%90%91%E6%95%B4%E5%BD%A2%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88">2.7.2 指向整形指针数组的指针</a></li>
<li><a href="#273-%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88">2.7.3 指向函数指针数组的指针</a></li>
</ul>
</li>
<li><a href="#28-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">2.8 回调函数</a><br>
*
<ul>
<li><a href="#281-%E5%86%8D%E6%AC%A1%E9%87%8D%E5%86%99%E8%AE%A1%E7%AE%97%E5%99%A8">2.8.1 再次重写计算器</a></li>
<li><a href="#282-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0qsort%E5%BA%93%E5%87%BD%E6%95%B0">2.8.2 模拟实现qsort库函数</a></li>
</ul>
</li>
<li><a href="#29-%E4%B9%A0%E9%A2%98">2.9 习题</a><br>
*
<ul>
<li><a href="#291-%E6%8C%87%E9%92%88">2.9.1 指针</a></li>
<li><a href="#292-%E7%BB%83%E4%B9%A01">2.9.2 练习1</a></li>
<li><a href="#293-%E7%BB%83%E4%B9%A02">2.9.3 练习2</a></li>
<li><a href="#294-%E7%BB%83%E4%B9%A03">2.9.4 练习3</a></li>
<li><a href="#295-%E7%BB%83%E4%B9%A04">2.9.5 练习4</a></li>
<li><a href="#296-%E7%BB%83%E4%B9%A05">2.9.6 练习5</a></li>
<li><a href="#297-%E7%BB%83%E4%B9%A06">2.9.7 练习6</a></li>
<li><a href="#298-%E7%BB%83%E4%B9%A07">2.9.8 练习7</a></li>
<li><a href="#299-%E7%BB%83%E4%B9%A08">2.9.9 练习8</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          
          <hr />
          <p class="next-post">下一篇：
            <a href="https://listen2022.github.io/KqgOIuMEN/">
              <span class="post-title">
                9. C语言进阶--数据存储&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script>
  var gitalk = new Gitalk({
    clientID: '3f95c9079ef35c0e7742',
    clientSecret: '43f525cf5aa44ca3dd1cb661a5406e508d2cb58c',
    repo: 'listen2022.github.io',
    owner: 'listen2022',
    admin: ['listen2022'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>

            
            
            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/listen2022" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
            <li class="list-inline-item">
              <a href="https://www.zhihu.com/people/turbo-studio" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-zhihu fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://listen2022.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>listen</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://listen2022.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://listen2022.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://listen2022.github.io/media/scripts/tocScript.js"></script>
</body>

</html>