<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[listen]的个人博客">
<meta name="author" content="kveln">
<title>12. C语言进阶--自定义类型 | listen</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="12. C语言进阶--自定义类型 | listen » Feed"
  href="https://listen2022.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://listen2022.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="12. C语言进阶--自定义类型" />
  <meta property="og:url" content="https://listen2022.github.io/ptlOCjxZ8/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="listen" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://listen2022.github.io">listen</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://listen2022.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://support.qq.com/products/378935" target="_blank">反馈</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1644633409599"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://listen2022.github.io">listen</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://listen2022.github.io">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="https://support.qq.com/products/378935" target="_blank">反馈</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1644633409599"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://listen2022.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://listen2022.github.io/KBJdndKld/" class="tag">C语言</a>
                
              </span>
              <h1>12. C语言进阶--自定义类型</h1>
              <span class="meta">
                Posted on
                2022-02-11，15 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <h1 id="4-自定义类型">4. 自定义类型</h1>
<h2 id="41-结构体">4.1 结构体</h2>
<blockquote>
<p>定义：一些值得集合，这些值称为成员变量。结构体每个成员可以是不同类型的变量。</p>
</blockquote>
<h4 id="411-结构体类型声明">4.1.1 结构体类型声明</h4>
<ul>
<li>
<p>普通声明</p>
<pre><code class="language-C">struct Person
{
  char name[10];
  int age;
  float height;
};

struct Person
{
  char name[10];
  int age;
  float height;
}p1, p2; // 声明结构体类型并声明结构体变量p1、p2

</code></pre>
</li>
<li>
<p>特殊声明（匿名结构体）</p>
<blockquote>
<p>省略标签，不完全声明结构体类型。只能声明一次变量。</p>
</blockquote>
<pre><code class="language-C">struct
{
  char name[10];
  int age;
  float height;
}p; // 声明匿名结构体类型 并声明结构体变量

struct
{
  char name[10];
  int age;
  float height;
}*p; // 声明匿名结构体类型 并声明结构体指针变量

</code></pre>
<blockquote>
<p>那么上面的两个结构体变量能否写成如下形式？</p>
</blockquote>
<pre><code class="language-C">ps = &amp;s;
</code></pre>
<blockquote>
<p>警告：编译器将两种声明当成完全不同的两个类型</p>
</blockquote>
</li>
</ul>
<h4 id="412-结构体的自引用">4.1.2 结构体的自引用</h4>
<blockquote>
<p>一个结构体中可以包含另一个另一个结构体类型。那结构体中能否包含本身结构体类型？</p>
</blockquote>
<pre><code class="language-C">// 答案：不能
// 原因：形成递归 内存大小无法确定
</code></pre>
<p><strong>自引用</strong></p>
<blockquote>
<p>该结构体变量能找到同类型的另一个结构体变量，声明中包含同类型结构体的指针，而不是同类型结构体的变量。</p>
</blockquote>
<pre><code class="language-C">// 正确自引用
struct Node
{
  int data;
  struct Node* next;
}

// 错误自引用
typedef struct
{
  int data;
  Node* next;
}Node;
// 通过类型重命名得到的Node 不能再结构体声明中直接使用
</code></pre>
<h4 id="413-结构体变量的定义和初始化">4.1.3 结构体变量的定义和初始化</h4>
<ul>
<li>
<p>定义</p>
<pre><code class="language-C">struct Person
{
  char name[10];
  int age;
  float height;
}p1; // 方式一

int main()
{
  struct Person p2; // 方式二
  return 0;
}

</code></pre>
</li>
<li>
<p>初始化</p>
<pre><code class="language-C">struct Person
{
  char name[10];
  int age;
  float height;
}p1 = {&quot;listen&quot;, 20, 185.0}; // 方式一

int main()
{
  struct Person p2 = { &quot;turbo&quot;, 25, 178.5 }; // 方式二
  return 0;
}
</code></pre>
</li>
<li>
<p>结构体嵌套初始化</p>
<pre><code class="language-C">struct Person
{
  char name[10];
  int age;
  float height;
}

struct Student
{
  char id[20];
  float score;
  struct Person p;
}s1 = { &quot;1914121006&quot;, 63.95, {&quot;listen&quot;, 20, 185.0} }; // 方式一


int main()
{
  struct Student s2 = { &quot;2114134566&quot;, 78.50, {&quot;turbo&quot;, 19, 178.5} }; // 方式二
  return 0;
}
</code></pre>
</li>
</ul>
<h4 id="414-结构体内存对齐">4.1.4 结构体内存对齐</h4>
<ul>
<li>
<p><strong>内存对齐规则</strong></p>
<ol>
<li>第一个成员在与结构体变量偏移量为0的地址处</li>
<li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处<br>
<strong>对齐数</strong>=编辑器默认的一个对齐数与该成员大小的较小值（VS中默认的值为8，linux系统中没有默认对齐数）</li>
<li>结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍</li>
<li>嵌套结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有对齐数（含嵌套结构体的对齐数）中的最大值的整数倍</li>
</ol>
<ul>
<li>
<p>实例1</p>
<pre><code class="language-C">struct S1
{
  char c1;
  int i;
  char c2;
};

struct S2
{
  char c1;
  char c2;
  int i;
};

int main()
{
  printf(&quot;%d\n&quot;, sizeof(struct S1)); // 12
  printf(&quot;%d\n&quot;, sizeof(struct S2)); // 8
}

// 输出结果：
// 12
// 8
</code></pre>
<p><img src="image/image.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538031328.png" alt="" loading="lazy"></p>
</li>
<li>
<p>实例2</p>
<pre><code class="language-C">struct S1
{
  char c1;
  int i;
  char c2;
};

struct S2
{  
  int i;
  char c;
  struct S1 s;
};

int main()
{
  printf(&quot;%d\n&quot;, sizeof(struct S2)); // 20
}

// 输出结果：
// 20
</code></pre>
<p><img src="image/image_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538038969.png" alt="" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<p><a href="https://www.pengrl.com/p/20020/"><strong>为什么存在内存对齐</strong></a> — 空间换时间</p>
<ol>
<li><strong>平台原因（移植原因）</strong>：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li><strong>硬件原因</strong>：经过内存对齐之后，可以减少CPU访问内存的次数和运算，提高效率。</li>
</ol>
</li>
<li>
<p><strong>修改默认对齐数</strong></p>
<pre><code class="language-C">#pragma pack(8) // 设置默认对齐数为8
#pragma pack() // 取消设置的默认对齐数 还原为默认值

// 一般设置的默认对齐数为2的倍数
</code></pre>
</li>
<li>
<p><strong>补充</strong></p>
<blockquote>
<p>通过实例1可得，调整结构体成员顺序，将较小的成员放在一块，可以在一定程度上减小结构体的大小。</p>
</blockquote>
</li>
</ul>
<h4 id="415-结构体传参">4.1.5 结构体传参</h4>
<pre><code class="language-C">struct Data
{
  int id;
  char data[1000];
};

void print1(struct Data d)
{
  printf(&quot;%d --&gt; %s\n&quot;, d.id, d.data);
}

void print1(struct Data *d)
{
  printf(&quot;%d --&gt; %s\n&quot;, d-&gt;id, d-&gt;data);
}

int main()
{
  struct Data d = { 0 };
  print1(d);
  print2(&amp;d);
  return 0;
}

</code></pre>
<ul>
<li><code>print1</code>和<code>print2</code>哪个函数更好？<br>
答案：<code>print2</code><br>
原因：如果传递的是结构体变量，函数传参时，将拷贝结构体，将造成一定程度空间上和时间上的系统开销；而传递的是结构体指针，指针变量也就4或8字节，并不会造成过大的系统开销。此外，传递结构体指针，还能在函数体内修改结构体变量的成员值；如果不想修改，只需在函数形参前加上<code>const</code></li>
</ul>
<h4 id="416-百度笔试题">4.1.6 百度笔试题</h4>
<ul>
<li><strong>要求</strong>：写一个宏，计算结构体中某变量相对于首地址的偏移量，并给出说明</li>
<li><strong>考察</strong>：<code>offsetof</code>宏的实现</li>
</ul>
<h2 id="42-位段或位域">4.2 位段(或位域)</h2>
<h4 id="421-什么是位段">4.2.1 什么是位段</h4>
<blockquote>
<p>定义结构体时，指定成员变量所占用的二进制位。数据存储时，并不需要一个完整的字节，只需要占用一个或几个字节即可，因此来节省空间。</p>
</blockquote>
<ul>
<li>位段的成员必须是int、unsigned int 或 signed int</li>
<li>位段的成员名后边有一个冒号和一个数字</li>
<li>位域在本质上就是一种结构类型，不过其成员是按二进位分配的</li>
</ul>
<p><strong>例如</strong></p>
<pre><code class="language-C">struct bs{
    int a:8;
    int b:2;
    int c:1;
};
// a占8位 b站2位 c站1位
</code></pre>
<h4 id="422-位域定义">4.2.2 位域定义</h4>
<pre><code class="language-C">struct 位域结构名 
{
  type [member_name] : width ;
  type [member_name] : width ;
  type [member_name] : width ;
  ...
};
// type: 只能为 int、unsigned int、signed int 决定如何解释位域的值
// member_name：位域名称
// width：位域中位的数量 宽度必须小于或等于指定类型的位宽度
</code></pre>
<h4 id="423-位域的使用">4.2.3 位域的使用</h4>
<blockquote>
<p>位段的使用和结构体变量相同。</p>
</blockquote>
<pre><code class="language-C">位域变量名.位域名
位域指针变量名-&gt;位域名

</code></pre>
<ul>
<li>
<p>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</p>
<pre><code class="language-C">struct bs{
    int a:4;
    int  :4;    /* 空域 */
    int b:4;    /* 从下一单元开始存放 */
    int c:4;
}

// a 占第一字节的 4 位，后 4 位填 0 表示不使用
// b 从第二字节开始，占用 4 位，c 占用 4 位
</code></pre>
</li>
<li>
<p>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，: 后面的数字不能超过这个长度。</p>
</li>
<li>
<p>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。</p>
<pre><code class="language-C">struct bs{
    int a:4;
    int  :3;    /* 空域 3不能使用 */
    int b:2;
    int c:1;
}
</code></pre>
</li>
<li>
<p>位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用<code>&amp;</code>获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。</p>
</li>
</ul>
<h4 id="422-位段的内存分配">4.2.2 位段的内存分配</h4>
<ul>
<li>
<p><strong>几点说明</strong>：</p>
<ol>
<li>位段的成员可以是int、 unsigned int、 signed int、char、signed char、unsigned char (整形家族) 类型（其中char、signed char、unsigned char 类型C标准中并没有规定，仅仅是VS编译器对其进行了扩充）</li>
<li>位段的空间上是按照需要以4byte（int）或者1byte（char）的方式开辟</li>
<li>位段涉及很多不确定因素，位段是不跨平台的，注意可移植程序应避免使用位段</li>
<li>C语言标准并没有规定位域的具体存储方式，不同的编译器有不同的实现，但它们都尽量压缩存储空间</li>
</ol>
</li>
<li>
<p><strong>位段的大小是多少呢？</strong></p>
<pre><code class="language-C">struct bs {
    int a : 4;
    int : 3;
    int b : 2;
    int c : 1;
};

int main()
{
    printf(&quot;%d\n&quot;, sizeof(struct bs)); // 4
    return 0;
} 
// 输出结果：
// 4
</code></pre>
</li>
<li>
<p><strong>基本存储规则</strong></p>
</li>
</ul>
<ol>
<li>当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。</li>
<li>当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC会压缩存储，而 VC/VS 不会（与不指定位宽时的存储方式相同）。</li>
<li>如果成员之间穿插着非位域成员，那么不会进行压缩。</li>
</ol>
<ul>
<li>VS中，内存分配如图所示
<blockquote>
<p>实例：位段S的内存分配。</p>
</blockquote>
</li>
</ul>
<p><img src="image/image_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538063551.png" alt="" loading="lazy"></p>
<h4 id="423-位段的跨平台问题">4.2.3 位段的跨平台问题</h4>
<ol>
<li>int位段被当成有符号数还是无符号数是不确定的</li>
<li>位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，如果在16位机器中写成大于16的数则会出现问题）</li>
<li>位段中成员在内存中从左向右分配，还是从右向左分配标准尚未定义</li>
<li>当一个结构体包含两个位段，第二个位段成员较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的</li>
</ol>
<h4 id="424-位段的应用">4.2.4 位段的应用</h4>
<p><strong>TCP头部报文</strong></p>
<p><img src="image/image_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538069270.png" alt="" loading="lazy"></p>
<h4 id="425-习题">4.2.5 习题</h4>
<blockquote>
<p>代码输出结果</p>
</blockquote>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  unsigned char puc[4];
  struct tagPIM
  {
    unsigned char ucPim1;
    unsigned char ucData0 : 1;
    unsigned char ucData1 : 2;
    unsigned char ucData2 : 3;
  } *pstPimData;
  pstPimData = (struct tagPIM*)puc;
  memset(puc, 0, 4);
  pstPimData-&gt;ucPim1 = 2;
  pstPimData-&gt;ucData0 = 3;
  pstPimData-&gt;ucData1 = 4;
  pstPimData-&gt;ucData2 = 5;
  printf(&quot;%02x %02x %02x %02x\n&quot;, puc[0], puc[1], puc[2], puc[3]); // 02 29 00 00 
  return 0;
}

</code></pre>
<p><img src="image/image_4.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538078233.png" alt="" loading="lazy"></p>
<h2 id="42-枚举">4.2 枚举</h2>
<blockquote>
<p>C 语言中的一种基本数据类型。将可能的值一一列举。</p>
</blockquote>
<pre><code class="language-C">// 比如：星期 1~7
//      性别 男 女 其他
//      月份 1~12
</code></pre>
<h4 id="421-枚举类型的定义">4.2.1 枚举类型的定义</h4>
<pre><code class="language-C">enum Day // 星期
{
  Mon,
  Tues,
  Wed,
  Thur,
  Fri,
  Sat,
  Sun
};
enum Sex // 性别
{
  Male,
  Female,
  Other
};

// 第一个枚举成员的默认值为整型的 0
// 后续枚举成员的值在前一个成员上加 1
// 如果将第一个枚举的成员变量定义为1
// 那么第二个就为2 一次类推 自增1
// 没有指定枚举元素的值 默认为前一个元素+1
// C语言中 枚举类型是被当做 int 或者 unsigned int 类型来处理
</code></pre>
<h4 id="422-枚举变量的定义">4.2.2 枚举变量的定义</h4>
<ul>
<li>
<p>先定义类型，后定义枚举变量</p>
<pre><code class="language-C">enum Sex // 性别
{
  Male,
  Female,
  Other
};

enum Sex s;
</code></pre>
</li>
<li>
<p>定义类型的同时定义枚举变量</p>
<pre><code class="language-C">enum Sex // 性别
{
  Male,
  Female,
  Other
} s;
</code></pre>
</li>
<li>
<p>省略枚举名称，直接定义枚举变量</p>
<pre><code class="language-C">enum // 性别
{
  Male,
  Female,
  Other
} s;
</code></pre>
</li>
</ul>
<h4 id="422-枚举的优点">4.2.2 枚举的优点</h4>
<ul>
<li>增加代码的可读性和可维护性</li>
<li>和#define定义的标识符比较枚举有类型检查，更加严谨 枚举是一种类型</li>
<li>防止命名污染（封装）</li>
<li>便于调试。#define在预编译时替换，在调试时只有被替换值</li>
<li>使用方便，一次定义多个常量（相比于#define）</li>
</ul>
<h4 id="423-枚举的使用">4.2.3 枚举的使用</h4>
<pre><code class="language-C">enum Sex// 性别
{
  Male,
  Female,
  Other
}s;

int main()
{
  enum Sex s = Female;
  printf(&quot;%d\n&quot;, s); // 1
  printf(&quot;%d\n&quot;, sizeof(s)); // 4
  return 0;
}
</code></pre>
<h4 id="424-枚举遍历">4.2.4 枚举遍历</h4>
<pre><code class="language-C">enum Day // 星期
{
  Mon,
  Tues,
  Wed,
  Thur,
  Fri,
  Sat,
  Sun
};

int main()
{
  enum Day day;
  for (day = Mon;  day &lt;= Sun; day++)
  {
    printf(&quot;%d\n&quot;, day);
  }
  return 0;
}

// 输出结果：
// 0
// 1
// 2
// 3
// 4
// 5
// 6
</code></pre>
<h2 id="43-联合体或共用体">4.3 联合体（或共用体）</h2>
<h4 id="431-联合类型的定义">4.3.1 联合类型的定义</h4>
<blockquote>
<p>是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
</blockquote>
<ul>
<li>
<p>格式</p>
<pre><code class="language-C">union [union tag]
{
  member definition;
  member definition;
  member definition;
   ...
} [union variables];
// [] 内的值是可选的
// union定义与结构体定义相似
</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">union Data
{
  char c;
  int i;
} d;
</code></pre>
<p><img src="image/image_5.png" alt="共用体变量d的内存占用情况" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538115449.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="433-共用体使用">4.3.3 共用体使用</h4>
<blockquote>
<p>共用体成员的访问，使用成员访问操作符<code>.</code></p>
</blockquote>
<pre><code class="language-C">// 实例

union Data
{
  char c;
  int i;
} d;

int main()
{
  d.i = 10000000;
  printf(&quot;%d\n&quot;, d.i); // 10000000
  printf(&quot;%d\n&quot;, d.c); // -128

  d.c = 'a';
  printf(&quot;%d\n&quot;, d.i); // 9999969
  printf(&quot;%d\n&quot;, d.c); // 97
  return 0;
}
</code></pre>
<ul>
<li>应用—判断机器大小端字节序<br>
<img src="image/image_6.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538123092.png" alt="" loading="lazy">
<ul>
<li>
<p>字符指针</p>
<pre><code class="language-C">int sysinfo()
{
  // 返回值 0 -- 大端存储
  // 返回值 1 -- 小端存储
  int a = 1;
  return *(char*)(&amp;a);
}

int main()
{
  printf(&quot;%d\n&quot;, sysinfo()); // 1
  return 0;
}
</code></pre>
</li>
<li>
<p>共用体</p>
<pre><code class="language-C">int sysinfo()
{
  // 返回值 0 -- 大端存储
  // 返回值 1 -- 小端存储
  union Data
  {
    char c;
    int i;
  } d;
  d.i = 1;
  return d.c;
}

int main()
{
  printf(&quot;%d\n&quot;, sysinfo()); // 1
  return 0;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="433-联合的特点">4.3.3 联合的特点</h4>
<blockquote>
<p>联合体成员是共用一块内存空间，一个联合变量的大小，至少是最大成员的大小。</p>
</blockquote>
<pre><code class="language-C">union Data
{
  char c;
  int i;
} d;

int main()
{
  printf(&quot;%p\n&quot;, &amp;d);
  printf(&quot;%p\n&quot;, &amp;d.c);
  printf(&quot;%p\n&quot;, &amp;d.i);
  return 0;
}

</code></pre>
<p><img src="image/image_7.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538129774.png" alt="" loading="lazy"></p>
<h4 id="434-联合大小的计算">4.3.4 联合大小的计算</h4>
<ul>
<li>联合的大小至少是最大成员的大小</li>
<li>当最大成员大小不是最大对齐数的正数倍时，对齐到最大对齐数的整数倍</li>
</ul>
<pre><code class="language-C">union U1
{
  char c[5]; // 对齐数 1  占用 5byte
  int i;     // 对齐数 4  占用 4byte
};
// 最大共用体成员占用内存5byte 最大对齐数4 所以共用体总占用内存 8byte (4byte × 2 &gt; 5byte) 

union U2
{
  short c[7]; // 对齐数 2 占用 14byte
  int i;      // 对齐数 4 占用 4byte
};
// 最大共用体成员占用内存14byte 最大对齐数4 所以共用体总占用内存 16byte (4byte × 4 &gt; 14byte)

int main()
{
  printf(&quot;%d\n&quot;, sizeof(union U1)); // 8
  printf(&quot;%d\n&quot;, sizeof(union U2)); // 16
}
</code></pre>
<h4 id="435-练习">4.3.5 练习</h4>
<blockquote>
<p>代码输出结果。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  union
  {
    short k;
    char i[2];
  }*s, a;
  s = &amp;a;
  s-&gt;i[0] = 0x39;
  s-&gt;i[1] = 0x38;
  printf(&quot;%x\n&quot;, a.k);
  return 0;
}
</code></pre>
<p><img src="image/image_8.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1644538137720.png" alt="" loading="lazy"></p>
<blockquote>
<p>对于a.k，short类型，在vs中<strong>小端存储</strong>，数值低位存储在低地址内存中，数值高位存储在高地址中。所以s.k=0x3839</p>
</blockquote>
<h2 id="44-实战-通讯录">4.4 实战-通讯录</h2>
<ul>
<li><strong>要求</strong>
<ul>
<li>通讯录中能够存放1000个人的信息
<ul>
<li>信息：名字、年龄、性别、电话、地址</li>
</ul>
</li>
<li>增加人的信息</li>
<li>删除指定人名的信息</li>
<li>修改指定人名的所有信息</li>
<li>查找指定人名的信息</li>
<li>排序通讯录的信息</li>
</ul>
</li>
</ul>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li><a href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">4. 自定义类型</a>
<ul>
<li><a href="#41-%E7%BB%93%E6%9E%84%E4%BD%93">4.1 结构体</a><br>
*
<ul>
<li><a href="#411-%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">4.1.1 结构体类型声明</a></li>
<li><a href="#412-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8">4.1.2 结构体的自引用</a></li>
<li><a href="#413-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96">4.1.3 结构体变量的定义和初始化</a></li>
<li><a href="#414-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">4.1.4 结构体内存对齐</a></li>
<li><a href="#415-%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82">4.1.5 结构体传参</a></li>
<li><a href="#416-%E7%99%BE%E5%BA%A6%E7%AC%94%E8%AF%95%E9%A2%98">4.1.6 百度笔试题</a></li>
</ul>
</li>
<li><a href="#42-%E4%BD%8D%E6%AE%B5%E6%88%96%E4%BD%8D%E5%9F%9F">4.2 位段(或位域)</a><br>
*
<ul>
<li><a href="#421-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E6%AE%B5">4.2.1 什么是位段</a></li>
<li><a href="#422-%E4%BD%8D%E5%9F%9F%E5%AE%9A%E4%B9%89">4.2.2 位域定义</a></li>
<li><a href="#423-%E4%BD%8D%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8">4.2.3 位域的使用</a></li>
<li><a href="#422-%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">4.2.2 位段的内存分配</a></li>
<li><a href="#423-%E4%BD%8D%E6%AE%B5%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%97%AE%E9%A2%98">4.2.3 位段的跨平台问题</a></li>
<li><a href="#424-%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%BA%94%E7%94%A8">4.2.4 位段的应用</a></li>
<li><a href="#425-%E4%B9%A0%E9%A2%98">4.2.5 习题</a></li>
</ul>
</li>
<li><a href="#42-%E6%9E%9A%E4%B8%BE">4.2 枚举</a><br>
*
<ul>
<li><a href="#421-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89">4.2.1 枚举类型的定义</a></li>
<li><a href="#422-%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">4.2.2 枚举变量的定义</a></li>
<li><a href="#422-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BC%98%E7%82%B9">4.2.2 枚举的优点</a></li>
<li><a href="#423-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8">4.2.3 枚举的使用</a></li>
<li><a href="#424-%E6%9E%9A%E4%B8%BE%E9%81%8D%E5%8E%86">4.2.4 枚举遍历</a></li>
</ul>
</li>
<li><a href="#43-%E8%81%94%E5%90%88%E4%BD%93%E6%88%96%E5%85%B1%E7%94%A8%E4%BD%93">4.3 联合体（或共用体）</a><br>
*
<ul>
<li><a href="#431-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89">4.3.1 联合类型的定义</a></li>
<li><a href="#433-%E5%85%B1%E7%94%A8%E4%BD%93%E4%BD%BF%E7%94%A8">4.3.3 共用体使用</a></li>
<li><a href="#433-%E8%81%94%E5%90%88%E7%9A%84%E7%89%B9%E7%82%B9">4.3.3 联合的特点</a></li>
<li><a href="#434-%E8%81%94%E5%90%88%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97">4.3.4 联合大小的计算</a></li>
<li><a href="#435-%E7%BB%83%E4%B9%A0">4.3.5 练习</a></li>
</ul>
</li>
<li><a href="#44-%E5%AE%9E%E6%88%98-%E9%80%9A%E8%AE%AF%E5%BD%95">4.4 实战-通讯录</a></li>
</ul>
</li>
</ul>
</div>
          
          <hr />
          <p class="next-post">下一篇：
            <a href="https://listen2022.github.io/ffelNQomt/">
              <span class="post-title">
                11. C语言进阶--字符串+内存函数&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script>
  var gitalk = new Gitalk({
    clientID: '3f95c9079ef35c0e7742',
    clientSecret: '43f525cf5aa44ca3dd1cb661a5406e508d2cb58c',
    repo: 'listen2022.github.io',
    owner: 'listen2022',
    admin: ['listen2022'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>

            
            
            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/listen2022" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
            <li class="list-inline-item">
              <a href="https://www.zhihu.com/people/turbo-studio" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-zhihu fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://listen2022.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>listen</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://listen2022.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://listen2022.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <script src="https://listen2022.github.io/media/scripts/tocScript.js"></script>
</body>

</html>