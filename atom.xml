<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://listen2022.github.io</id>
    <title>listen</title>
    <updated>2022-02-11T00:01:04.483Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://listen2022.github.io"/>
    <link rel="self" href="https://listen2022.github.io/atom.xml"/>
    <subtitle>不积跬步，无以至千里！</subtitle>
    <logo>https://listen2022.github.io/images/avatar.png</logo>
    <icon>https://listen2022.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, listen</rights>
    <entry>
        <title type="html"><![CDATA[11. C语言进阶--字符串+内存函数]]></title>
        <id>https://listen2022.github.io/ffelNQomt/</id>
        <link href="https://listen2022.github.io/ffelNQomt/">
        </link>
        <updated>2022-02-10T23:59:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="3-字符串内存函数">3. 字符串+内存函数</h1>
<h2 id="31-字符串函数">3.1 字符串函数</h2>
<blockquote>
<p>头文件：string.h</p>
</blockquote>
<h4 id="311-strlen">3.1.1 strlen</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：返回字符串的长度
size_t strlen ( const char * str );
// 形参：字符指针
// 返回值：C字符串的长度

</code></pre>
</li>
<li>
<p>原理</p>
<pre><code class="language-C">size_t strlen (
        const char * str
        )
{
        const char *eos = str;

        while( *eos++ ) ;

        return( eos - str - 1 );
}

</code></pre>
</li>
<li>
<p>说明</p>
<ul>
<li>
<p>字符串以 '\0' 作为结束标志，strlen函数返回的是在字符串中 '\0' 前面出现的字符个数（不包含 '\0' ）</p>
</li>
<li>
<p>参数指向的字符串必须要以 '\0' 结束</p>
</li>
<li>
<p>函数的返回值为size_t，无符号整形</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  if (strlen(&quot;abc&quot;) - strlen(&quot;abcdef&quot;) &gt; 0)
  {
    printf(&quot;&gt;\n&quot;);
  }
  else
  {
    printf(&quot;&lt;=\n&quot;);
  }
}
// 输出结果： &lt;=
// &quot;abc&quot;的长度为3; &quot;abcdef&quot;的长度为6
// 而输出结果表示&quot;abc&quot;的长度 小于 &quot;abcdef&quot;的长度
// 原因：strlen(&quot;abc&quot;) - strlen(&quot;abcdef&quot;)
//      (无符号整形)3 - (无符号整形)6 = (无符号整形)-3
//      -3为 unsigned int 应表示为 一个正数 (FFFFFFFF-3)(十六进制)

</code></pre>
<figure data-type="image" tabindex="1"><img src="image/image.png" alt="" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char* s = &quot;hello world!&quot;;
  printf(&quot;%u\n&quot;, strlen(s)); // 12
  return 0;
}
// 输出结果：12
</code></pre>
<figure data-type="image" tabindex="2"><img src="image/image_1.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h4 id="312-strcpy">3.1.2 strcpy</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：拷贝字符串
char * strcpy ( char * destination, const char * source );
// 形参：destination 将要拷贝到的地址空间的指针
//      source 被拷贝的字符串
// 返回值：目标空间地址destination 
</code></pre>
</li>
<li>
<p>原理</p>
<pre><code class="language-C">char * strcpy(char * dst, const char * src)
{
        char * cp = dst;

        while((*cp++ = *src++) != '\0')
                ;               /* Copy src over dst */

        return( dst );
}


</code></pre>
</li>
<li>
<p>说明</p>
<ul>
<li>
<p>源字符串必须以 '\0' 结束</p>
</li>
<li>
<p>会将源字符串中的 '\0' 拷贝到目标空间</p>
</li>
<li>
<p>目标空间必须足够大，以确保能存放源字符串</p>
<pre><code class="language-C">// strcpy并不会检查目标空间是否大于要拷贝的字符串
// 而是直接强行拷贝 所以strcpy不安全
// 源文件最前面加上一行代码 #define _CRT_SECURE_NO_WARNINGS

</code></pre>
</li>
<li>
<p>目标空间必须可变</p>
<pre><code class="language-C">// C语言中数组是可变的
char arr[20] = { 0 };

// 字符串是常量，不可变的
char* s = &quot;     &quot;;

// 所以目标空间可以是arr，而不能是s
// C语言中，字符串的底层就是字符串首字符地址
</code></pre>
</li>
</ul>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char arr[20] = { 0 };
  // arr = &quot;hello&quot;;
  // arr表示的是数组首元素的地址，是数组的标识
  // 而字符串 &quot;hello&quot; 应放到arr所指的空间中
  // 所以需要使用库函数strcpy将字符串拷贝放到arr中
  // 而不能直接赋值 arr = &quot;hello&quot;;
  strcpy(arr, &quot;hello&quot;);
  // 字符串使用本质上是字符串首字符的地址
  printf(&quot;%s\n&quot;, arr); // hello
}
</code></pre>
</li>
</ul>
<h4 id="313-strcat">3.1.3 strcat</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：字符串追加
char * strcat ( char * destination, const char * source );
// 形参：source 被追加的字符串
//      destination 目标字符串
// 返回值：目标字符串 destination 地址
</code></pre>
</li>
<li>
<p>原理</p>
<pre><code class="language-C">char * strcat (
        char * dst,
        const char * src
        )
{
        char * cp = dst;

        while( *cp )
                cp++;                   /* find end of dst */

        while((*cp++ = *src++) != '\0') ;       /* Copy src to end of dst */

        return( dst );                  /* return dst */

}
</code></pre>
</li>
<li>
<p>说明</p>
<ul>
<li>源字符串必须以 '\0' 结束</li>
<li>目标空间必须有足够的大，能容纳下源字符串的内容</li>
<li>目标空间必须可修改</li>
</ul>
</li>
<li>
<p>模拟实现</p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

char* my_strcat(char* dst, const char* src)
{
  assert(dst &amp;&amp; src);
  char* cp = dst;
  while (*cp)
  {
    cp++;
  } // 找到dst中的'\0'
  //while (*cp++);  问题：为什么上一条while循环不能简写成这样
  while (*cp++ = *src++); // 将src复制到dst末尾
  return dst;
}
</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char arr1[20] = &quot;Hello \0#########&quot;;
  char arr2[] = &quot;world&quot;;
  strcat(arr1, arr2);
  printf(&quot;%s\n&quot;, arr1); // Hello world
  return 0;
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="image/image_2.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>追加字符串自己</p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char arr[20] = &quot;abcd&quot;;
  strcat(arr, arr);
  printf(&quot;%s\n&quot;, arr); // abcdabcd
  return 0;
}

// 输出结果：abcdabcd

// 而自己实现的strcat函数会出现死循环
// dst和src指向同一块区域 追加时 '\0' 被覆盖
</code></pre>
</li>
</ul>
<h4 id="314-strcmp">3.1.4 strcmp</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 比较字符串1和字符串2
int strcmp ( const char * str1, const char * str2 );
// 形参：str1 str2 分别是要比较的两个字符串
// 返回值：整形  标准规定：
//        &lt;0 str1&lt;str2
//        &gt;0 str1&gt;str2
//        =0 str1=str2
//        VS中返回值为-1 0 1
// C语言中不能直接使用使用关系运算符确定两个字符串的大小
// 字符串比较，实际上是比较字符的ASCII码
</code></pre>
</li>
<li>
<p>原理</p>
<pre><code class="language-C">int strcmp (
        const char * src,
        const char * dst
        )
{
        int ret = 0 ;

        while((ret = *(unsigned char *)src - *(unsigned char *)dst) == 0 &amp;&amp; *dst)
                {
                ++src, ++dst;
                }

        return ((-ret) &lt; 0) - (ret &lt; 0); // (if positive) - (if negative) generates branchless code
}
</code></pre>
</li>
<li>
<p>模拟实现</p>
<pre><code class="language-C">#include &lt;assert.h&gt;

int my_strcmp(const char* s1, const char* s2)
{
  assert(s1 &amp;&amp; s2);
  while (*s1 == *s2)
  {
    if (*s1 == '\0')
    {
      return 0;
    }
    s1++;
    s2++;
  }
  return *s1 - *s2;
}

</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  printf(&quot;%d\n&quot;, strcmp(&quot;abc&quot;, &quot;abcd&quot;)); // -1
  return 0;
}

// 输出结果：-1
// 'a' 比较 'a' 结果 =
// 'b' 比较 'b' 结果 =
// 'c' 比较 'c' 结果 =
// '\0' 比较 'd' 结果 &lt;
// 返回 -1
</code></pre>
</li>
</ul>
<h4 id="315-strncpy">3.1.5 strncpy</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 将n个字符拷贝到另一个字符串中
char * strncpy ( char * destination, const char * source, size_t num );
// 形参： destination 目标字符串
//       source 被拷贝字符串
//       num 拷贝字符个数
// 返回值：destination
</code></pre>
</li>
<li>
<p>原理</p>
<pre><code class="language-C">char * strncpy (
        char * dest,
        const char * source,
        size_t count
        )
{
        char *start = dest;

        while (count &amp;&amp; (*dest++ = *source++) != '\0')    /* copy string */
                count--;

        if (count)                              /* pad out with zeroes */
                while (--count)
                        *dest++ = '\0';

        return(start);
}

</code></pre>
</li>
<li>
<p>模拟实现</p>
<pre><code class="language-C">#include &lt;assert.h&gt;

char* my_strncpy(char* destination, const char* source, size_t num) 
{
  // 当 num 大于 source 长度时 
  // 当 num 大于 destination 长度时  
  // 当 num 等于 0
  assert(destination &amp;&amp; source);
  char* ret = destination;
  char* src = source;
  while (num &amp;&amp; (*destination++ = *source++))
  {
    num--;
  }
  if (num)
  {
    return ret;
  }
  while (num--)
  {
    *destination++ = '\0';
  }
  return ret;
}
</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char dest[20] = { 0 };
  char src[] = &quot;i like c.&quot;;
  strncpy(dest, src, 6);
  printf(&quot;%s\n&quot;, dest); // i like
  return 0;
}

// 输出结果：
// i like

</code></pre>
</li>
</ul>
<h4 id="316-strncat">3.1.6 strncat</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：将n个字符追加到另一个字符串后
char * strncat ( char * destination, const char * source, size_t num );
// 形参： destination 目标字符串
//       source 被追加字符串
//       num 追加字符个数
// 返回值：destination

</code></pre>
</li>
<li>
<p>原理</p>
<pre><code class="language-C">char * strncat (
        char * front,
        const char * back,
        size_t count
        )
{
        char *start = front;

        while (*front++)
                ;
        front--;

        while (count--)
                if ((*front++ = *back++) == 0)
                        return(start);

        *front = '\0';
        return(start);
}

</code></pre>
</li>
<li>
<p>模拟实现</p>
<pre><code class="language-C">#include &lt;assert.h&gt;

char* my_strncat( char* front, const char* back, size_t count )
{
    // count 大于 back 的字符数(包括'\0'在内)
    // count 等于 0 
    assert(front &amp;&amp; back); // 断言 空指针
    char* ret = front;
    while (*front++); // 找到被追加字符串的结束位置 '\0'
    front--; // 回退到 '\0' 位置
    while (count--) // 循环 count 次
        if (!(*front++ = *back++)) // 将 back 复制到 被追加字符串末尾 
            return ret; // 遇到 '\0' 返回 ret (表示 已经将back的所有字符追加到front后面)
    *front = '\0'; // 字符串末尾补 '\0'
    return ret;
}
</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char dest[20] = &quot;I like &quot;;
  char src[] = &quot;clang and golang&quot;;
  char* ret = strncat(dest, src, 5);
  printf(&quot;%s\n&quot;, ret); // I like clang
  return 0;
}

// 输出结果：
// I like clang
</code></pre>
</li>
</ul>
<h4 id="317-strncmp">3.1.7 strncmp</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：比较两字符串前n个字符
int strncmp ( const char * str1, const char * str2, size_t num );
// 形参：str1 str2 分别是要比较的两个字符串
//      num 比较的字符个数
// 返回值：整形（规定与strcmp相同）

// 相对于 strcmp函数 更安全

</code></pre>
</li>
<li>
<p>原理</p>
<pre><code class="language-C">int strncmp
(
    const char *first,
    const char *last,
    size_t      count
)
{
    size_t x = 0;

    if (!count)
    {
        return 0;
    }

    /*
     * This explicit guard needed to deal correctly with boundary
     * cases: strings shorter than 4 bytes and strings longer than
     * UINT_MAX-4 bytes .
     */
    if( count &gt;= 4 )
    {
        /* unroll by four */
        for (; x &lt; count-4; x+=4)
        {
            first+=4;
            last +=4;

            if (*(first-4) == 0 || *(first-4) != *(last-4))
            {
                return(*(unsigned char *)(first-4) - *(unsigned char *)(last-4));
            }

            if (*(first-3) == 0 || *(first-3) != *(last-3))
            {
                return(*(unsigned char *)(first-3) - *(unsigned char *)(last-3));
            }

            if (*(first-2) == 0 || *(first-2) != *(last-2))
            {
                return(*(unsigned char *)(first-2) - *(unsigned char *)(last-2));
            }

            if (*(first-1) == 0 || *(first-1) != *(last-1))
            {
                return(*(unsigned char *)(first-1) - *(unsigned char *)(last-1));
            }
        }
    }

    /* residual loop */
    for (; x &lt; count; x++)
    {
        if (*first == 0 || *first != *last)
        {
            return(*(unsigned char *)first - *(unsigned char *)last);
        }
        first+=1;
        last+=1;
    }

    return 0;
}

</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">
int main()
{
  char str1[] = &quot;I like&quot;;
  char str2[] = &quot;I like c&quot;;
  int ret = 0;
  ret = strncmp(str1, str2, 5);
  printf(&quot;%d\n&quot;, ret); // 0
  ret = strncmp(str1, str2, 7);
  printf(&quot;%d\n&quot;, ret); // -1
  return 0;
}

// 输出结果：
// 0
// -1
</code></pre>
</li>
</ul>
<h4 id="318-strstr">3.1.8 strstr</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：在字符串 str1 中查找第一次出现字符串 str2 的位置 不包含终止符 '\0'。
const char * strstr ( const char * str1, const char * str2 );
      char * strstr (       char * str1, const char * str2 );
// 参数：str1 str2 字符串
// 返回值：str2 在 str1 中第一次出现的位置--指针
</code></pre>
</li>
<li>
<p>模拟实现</p>
<ul>
<li>
<p>查找原理</p>
<blockquote>
<p>假设在字符串 &quot;acdeef&quot; 中查找 &quot;ef&quot; 查找步骤如下图：</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="image/image_3.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>代码</p>
<pre><code class="language-C">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

char* my_strstr(const char* str1, const char* str2)
{
  assert(str1 &amp;&amp; str2);
  const char* s = str1;
  const char* s1 = NULL;
  const char* s2 = NULL;
  // C语言规定 如果str2为空字符串，返回str1
  if (*str2 == '\0')
  {
    return (char*)str1;
  }

  while (*s)
  {
    s1 = s;
    s2 = str2;
    while (*s1 &amp;&amp; *s2 &amp;&amp; (*s1 == *s2))
    // 或者 while ((*s2 != '\0') &amp;&amp; (*s1 == *s2))
    // *s2 != '\0' 主要是防止越界访问
    {
      s1++;
      s2++;
    }
    if (*s2 == '\0')
    {
      return (char*)s;
    }
    s++;
  }
  return NULL;
}

// 测试函数
void test()
{
  char str1[] = &quot;acdeef&quot;;
  char str2[] = &quot;ef&quot;;
  char* ret;
  ret = my_strstr(str1, str2);
  printf(&quot;%s\n&quot;, ret); // ef
}

// main主函数
int main()
{
  test();
  return 0;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char str1[] = &quot;i like c&quot;;
  char str2[] = &quot;like&quot;;
  char* ret = strstr(str1, str2);
  printf(&quot;%s\n&quot;, ret);
  return 0;
}
// 输出结果：like c
</code></pre>
</li>
</ul>
<h4 id="319-strtok">3.1.9 strtok</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：分割字符串
char * strtok ( char * str, const char * delimiters );
// 参数：
//     str2 字符串 定义了用作分隔符的字符集合
//     str1 字符串 包含0个或多个由str2中一个或多个字符分割的标记

</code></pre>
</li>
<li>
<p>说明</p>
<ul>
<li>strtok函数找到str中的下一个标记，并将其用 '\0' 结尾，返回一个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改）</li>
<li>strtok函数第一个参数不为NULL时，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置（基于static）</li>
<li>strtok函数第一个参数为NULL时，函数将在同一个字符串中保存的位置开始，查找下一个标记</li>
<li>如果字符串中不存在更多的标记，则返回NULL指针</li>
</ul>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char str[] = &quot;he#ll*o wo#rl*d&quot;;
  char delimiters[] = &quot;*#&quot;;
  // strtok会修改被分割字符串，所以创建临时变量
  char tmp[20] = { 0 };
  strcpy(tmp, str);
  for (
    char* s = strtok(tmp, delimiters); // 找到str中第一个标记 strtok函数将保存它在字符串中的位置
    s != NULL;  // 当s=NULL时剩余的字符串中没有更多的标记
    s = strtok(NULL, delimiters) // strtok 函数将在同一个字符串中保存的位置开始 查找下一个标记
    )
  {
    printf(&quot;%s\n&quot;, s);
  }
  return 0;
}
// 输出结果：
// he
// ll
// o wo
// rl
// d

</code></pre>
</li>
</ul>
<h4 id="3110-strerror">3.1.10 strerror</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：将错误码转换为错误信息
char * strerror ( int errnum );
// 参数：errnum 整形 由C语言提供的全部变量 存在于头文件 &lt;errno.h&gt; 中 调用库函数失败时 都会设置全局错误码
// 返回值：转换的错误信息字符串第一个字符地址
</code></pre>
</li>
<li>
<p>实例1</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char* str0 = strerror(0);
  printf(&quot;%s\n&quot;, str0);
  char* str1 = strerror(1);
  printf(&quot;%s\n&quot;, str1);
  char* str2 = strerror(2);
  printf(&quot;%s\n&quot;, str2);
  char* str3 = strerror(3);
  printf(&quot;%s\n&quot;, str3);
  char* str4 = strerror(4);
  printf(&quot;%s\n&quot;, str4);
  return 0;
}


// 输出结果：
// No error
// Operation not permitted
// No such file or directory
// No such process
// Interrupted function call

</code></pre>
</li>
<li>
<p>实例2</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main()
{
    FILE* pFile;
    pFile = fopen(&quot;unexist.ent&quot;, &quot;r&quot;);
    if (pFile == NULL)
        printf(&quot;Error: %s\n&quot;, strerror(errno));
    //... 文件处理
    fclose(pf);
    pf = NULL;
    return 0;
}

// 输出结果：
// Error: No such file or directory
</code></pre>
</li>
</ul>
<h4 id="3111-perror">3.1.11 perror</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：
//    1. 将错误码转换为错误信息 strerror
//    2. 将错误信息打印 printf

void perror ( const char * str );
// 参数：提示信息 会自动与错误信息拼接打印

// 头文件 stdio.h 中
</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int main()
{
    FILE* pFile;
    pFile = fopen(&quot;unexist.ent&quot;, &quot;r&quot;);
    if (pFile == NULL)
        perror(&quot;Error&quot;);
    //... 文件处理
    fclose(pf);
    pf = NULL;
    return 0;
}

// 输出结果：
// Error: No such file or directory

</code></pre>
</li>
</ul>
<h2 id="32-字符函数">3.2 字符函数</h2>
<blockquote>
<p>头文件：ctype.h</p>
</blockquote>
<h4 id="321-字符分类">3.2.1 字符分类</h4>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>如果他的参数符合下列要求 则返回真</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>iscntrl</td>
<td>任何控制字符</td>
</tr>
<tr>
<td>isspace</td>
<td>空白字符：空格' '，换页 '\f'，换行 '\n'，回车 '\r'，制表符 '\t'，垂直制表符 '\v'</td>
</tr>
<tr>
<td>isxdigit</td>
<td>十进制数字0~9</td>
</tr>
<tr>
<td>islower</td>
<td>十六进制数字，包括所有十进制数字，小写字母a<sub>f，大写字母A</sub>F</td>
</tr>
<tr>
<td>islower</td>
<td>小写字母a~z</td>
</tr>
<tr>
<td>isupper</td>
<td>大写字母A~Z</td>
</tr>
<tr>
<td>isalpha</td>
<td>字母a<sub>z或A</sub>Z</td>
</tr>
<tr>
<td>isalnum</td>
<td>字母或者数字，a~z, A~Z, 0~9</td>
</tr>
<tr>
<td>ispunct</td>
<td>标点符号，任何不属于数组或者字母的图形字符（可打印）</td>
</tr>
<tr>
<td>isgraph</td>
<td>任何图形字符</td>
</tr>
<tr>
<td>isprint</td>
<td>任何可打印字符，包括图形字符和空白字符</td>
</tr>
</tbody>
</table>
<h4 id="322-字符转换">3.2.2 字符转换</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// tolower：将大写字符转换为小写字符
int tolower ( int c );


// toupper：将小写字符转换为大写字符
int toupper ( int c );

</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

int main()
{
  char str[] = &quot;hello&quot;;
  int size = sizeof(str) / sizeof(str[0]);

  for (int i = 0; i &lt; size; i++)
  {
    str[i] = toupper(str[i]);
  }
  printf(&quot;%s\n&quot;, str); // HELLO
}

// 输出结果：
// HELLO
</code></pre>
</li>
</ul>
<h2 id="33-内存函数">3.3 内存函数</h2>
<blockquote>
<p>头文件：string.h</p>
</blockquote>
<h4 id="331-memcpy">3.3.1 memcpy</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能拷贝不重叠内存（C语言规定实现拷贝不重叠内存即可，但是VS编译器中该函数也实现了拷贝重叠内存功能）
void * memcpy ( void * destination, const void * source, size_t num );
// 参数：destination 拷贝目标地址
//      source 被拷贝数据地址
//      num 拷贝的大小 单位：字节
// 返回值：destination
</code></pre>
</li>
<li>
<p>模拟实现</p>
<pre><code class="language-C">#include &lt;assert.h&gt;

void* my_memcpy(void* dest, const void* src, size_t num)
{
  assert(dest &amp;&amp; src);
  void* ret = dest;
  while (num--)
  {
    *(char*)dest = *(char*)src;
    dest = (char*)dest + 1;
    src = (char*)src + 1;
    // 不能 (char*)src++ 因为(type)类型转换优先级高于后置自增++操作符
    // 或者说 单目运算符 从右向左 先自增再类型转换 而类型转换前 src时无类型指针 不能自增
    // 可以这样改写 ((char*)src)++
  }
  return ret;
}

</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char arr[] = &quot;abcdefg&quot;;
  memcpy(arr + 4, arr, 2);
  printf(&quot;%s\n&quot;, arr); // abcdabg
  return 0;
}

// 输出结果：
// abcdabg
</code></pre>
</li>
</ul>
<h4 id="332-memmove">3.3.2 memmove</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：可拷贝重叠内存
void * memmove ( void * destination, const void * source, size_t num );
// 参数：destination 拷贝目标地址
//      source 被拷贝数据地址
//      num 拷贝的大小 单位：字节
// 返回值：destination

</code></pre>
</li>
<li>
<p>模拟实现</p>
<ul>
<li>
<p>分析</p>
<pre><code class="language-C">// 对于一个数组：
int arr[] = { 1,2,3,4,5,6,7 }; 
// 想要将数组索引为1~4的数据复制到索引为3~6的位置
// 使用memcpy函数(C标准规定)得到的结果是 { 1,2,3,2,3,2,3 }
// 而预期结果是{  1,2,3,2,3,4,5 } 显然结果不同
// 原因是 memcpy在拷贝时 如果拷贝内容重叠 会发生覆盖
</code></pre>
<blockquote>
<p>拷贝有两种情况，分别为从前向后和从后向前</p>
</blockquote>
<ul>
<li>
<p>情况一<br>
<img src="image/image_4.png" alt="" loading="lazy"></p>
<blockquote>
<p>如图，将红框中内容拷贝到篮框中，如果从前往后拷贝则不会发生覆盖，是预期结果；而从后往前拷贝则会发生覆盖，非预期结果。</p>
</blockquote>
</li>
<li>
<p>情况二<br>
<img src="image/image_5.png" alt="" loading="lazy"></p>
<blockquote>
<p>如图，将红框中内容拷贝到篮框中，如果从前往后拷贝则会发生覆盖，非预期结果；而从后往前拷贝则不会发生覆盖，达到预期结果。</p>
</blockquote>
</li>
<li>
<p>情况三<br>
<img src="image/image_6.png" alt="" loading="lazy"></p>
<blockquote>
<p>如图，将红框中内容拷贝到篮框中，无论是从前向后拷贝还是从后向前拷贝，并不会发生覆盖，都是预期结果。</p>
</blockquote>
</li>
<li>
<p>总结</p>
<blockquote>
<p>当目标地址和被拷贝地址重合时，如果目标地址在被拷贝地址之前，则从前向后拷贝；如果目标地址在被拷贝地址之后，则从后向前拷贝。</p>
</blockquote>
<pre><code>  当目标地址和被拷贝地址不重合时，拷贝顺序并不影响结果。
  显然：选择适当的拷贝顺序，就可以避免发生覆盖。
  方便起见，和重合统一划分为，如果目标地址在被拷贝地址之前，则从前向后拷贝；如果目标地址在被拷贝地址之后，则从后向前拷贝。
</code></pre>
<ul>
<li>代码<pre><code class="language-C">#include &lt;assert.h&gt;

void* my_memmove(void* dest, const void* src, size_t num)
{
  assert(dest &amp;&amp; src);
  void* ret = dest;
  if (dest&gt;src)
  { // 从前向后拷贝
    while (num--)
    {
      *(char*)dest = *(char*)src;
      dest = (char*)dest + 1;
      src = (char*)src + 1;
    }
  }
  else
  { // 从后向前拷贝
    while (num--)
    {
      *((char*)dest + num) = *((char*)src + num);
    }
  }
  return ret;
}

// 测试函数
void test()
{
  char arr[] = &quot;abcdefg&quot;;
  my_memmove(arr + 2, arr, 4);
  printf(&quot;%s\n&quot;, arr); // ababcdg
}

// main主函数
int main()
{
  test();
  return 0;
}

// 输出结果：
// ababcdg

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char arr[] = &quot;abcdefg&quot;;
  memmove(arr + 2, arr, 4);
  printf(&quot;%s\n&quot;, arr); // ababcdg
  return 0;
}
// 输出结果：
// ababcdg
</code></pre>
</li>
</ul>
<h4 id="333-memcmp">3.3.3 memcmp</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：内存比较
int memcmp ( const void * ptr1, const void * ptr2, size_t num );
// 参数：ptr1 ptr2 地址
//      num 比较小大 单位：字节
// 返回值：整形  标准规定：
//        &lt;0 str1&lt;str2
//        &gt;0 str1&gt;str2
//        =0 str1=str2
//        VS中返回值为-1 0 1

</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  int arr1[] = { 1,2,3 };
  int arr2[] = { 1,3,5 };
  int ret = 0;
  
  // 比较arr1和arr2内存空间中的前4字节
  ret = memcmp(arr1, arr2, 4);
  printf(&quot;%d\n&quot;, ret); // 0
  
  // 比较arr1和arr2内存空间中的前8字节
  ret = memcmp(arr1, arr2, 8);
  printf(&quot;%d\n&quot;, ret); // -1
  return 0;
}

// 输出结果：
// 0
// -1
</code></pre>
</li>
</ul>
<h4 id="334-memset">3.3.4 memset</h4>
<ul>
<li>
<p>原型</p>
<pre><code class="language-C">// 功能：内存设置
void * memset ( void * ptr, int value, size_t num );
// 参数：ptr 地址
//      value 值
//      num 大小 单位：字节
// 返回值：ptr
</code></pre>
</li>
<li>
<p>实例</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char s[10] = { 0 };
  memset(s, 'a', 10);
  for (int i = 0; i &lt; 10; i++)
  {
    printf(&quot;%c &quot;, s[i]); // a a a a a a a a a a
  }
  return 0;
}

// 输出结果：
// a a a a a a a a a a
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2022]]></title>
        <id>https://listen2022.github.io/6Tad6moOG/</id>
        <link href="https://listen2022.github.io/6Tad6moOG/">
        </link>
        <updated>2022-02-01T14:32:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="2022年度规划">2022年度规划</h1>
<h2 id="22年目标">22年目标</h2>
<ul>
<li><strong>考研成功</strong></li>
<li><strong>学会自律</strong></li>
<li><strong>感情顺利</strong></li>
<li><strong>坚持运动</strong></li>
</ul>
<h2 id="考研目标深圳大学">考研目标：深圳大学</h2>
<h2 id="自律-自律-自律"><strong>自律 自律 自律</strong></h2>
<h2 id="做自己"><strong>做自己</strong></h2>
<ul>
<li>
<p><strong>日安排</strong><br>
<img src="https://listen2022.github.io/post-images/1643726211640.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>周安排</strong><br>
<img src="https://listen2022.github.io/post-images/1643726216769.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>月安排</strong><br>
<img src="https://listen2022.github.io/post-images/1643726221179.png" alt="" loading="lazy"></p>
</li>
<li>
<p>寒假（2月1号周二—2月17号周四 共16天）</p>
<ul>
<li>
<p>安排<br>
| <strong>日期</strong> | <strong>安排</strong> |<br>
| ------ | ------ |<br>
| 1-2号   | 心态调整   |<br>
| 3-10号  |        |<br>
| 10-17号 |        |<br>
| 17-20号 | 开学准备   |</p>
</li>
<li>
<p>目标：</p>
<ul>
<li>结束C语言、操作系统、计算机组成原理</li>
<li>每天25min跑步（天晴）</li>
<li>gitee上每天一个绿点</li>
<li>牛客网C语言：5道选择和1道编程题</li>
<li>戒掉B站，微信</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. C语言--调试]]></title>
        <id>https://listen2022.github.io/ZD0FIx_5C/</id>
        <link href="https://listen2022.github.io/ZD0FIx_5C/">
        </link>
        <updated>2022-01-30T15:11:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="8调试">8.调试</h1>
<h2 id="81-什么是bug">8.1 什么是bug？</h2>
<blockquote>
<p>程序错误，即英文的Bug，也称为缺陷、臭虫，是指在软件运行中因为程序本身有错误而造成的功能不正常、死机、数据丢失、非正常中断等现象。</p>
</blockquote>
<p>史上的第一只 &quot;Bug&quot; ，真的是因为一只飞蛾意外走入一电脑而引致<a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C/9850042">故障</a>，因此Bug从原意为臭虫引申为程序错误。</p>
<p><a href="https://baike.baidu.com/reference/4605473/629ckzKerK1hLa0XtYeZ_G8ZHjG_qumr4xw80FO6tKqUlkxWv7i0Q2ei8S5R8Es3vCM3kcH0F3HS4w">程序错误参考资料 (baidu.com)</a></p>
<h2 id="82-调试是什么有多重要">8.2 调试是什么？有多重要？</h2>
<h4 id="821-调试概念">8.2.1 调试概念</h4>
<blockquote>
<p>调试（英语：Debugging/Debug）：又称排错，将编制的程序投入实际运行前，用手工或编译程序等方法进行测试，修正语法错误和逻辑错误的过程。是发现和减少计算机程序或电子仪器设备中程序错误的一个过程。</p>
</blockquote>
<h4 id="822-基本步骤">8.2.2 基本步骤</h4>
<ul>
<li>发现错误程序的存在</li>
<li>以隔离、消除等方式对错误进行定位</li>
<li>确定错误产生的原因</li>
<li>提出纠正错误的解决办法</li>
<li>对程序错误予以改正，重新测试</li>
</ul>
<h2 id="83-debug和release的介绍">8.3 debug和release的介绍</h2>
<h4 id="831-debug">8.3.1 Debug</h4>
<blockquote>
<p>调试版本，它包含调试信息，并且不做任何优化，便于程序员调试程序。并且程序中只有包含了额外的辅助信息才可以进行调试。</p>
</blockquote>
<h4 id="832-release">8.3.2 Release</h4>
<blockquote>
<p>发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好的使用。</p>
</blockquote>
<h4 id="833-总结">8.3.3 总结</h4>
<blockquote>
<p>Release版本相较于Debug版本的可执行文件，空间更小，运行更快。</p>
</blockquote>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555598626.png" alt="" loading="lazy"></p>
<h2 id="84-windows环境调试介绍">8.4 windows环境调试介绍</h2>
<blockquote>
<p>Linux系统中使用gdb(GNU symbolic debugger)</p>
</blockquote>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555606773.png" alt="" loading="lazy"></p>
<h4 id="841-快捷键">8.4.1 快捷键</h4>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + Alt + P</td>
<td>附加到进程</td>
</tr>
<tr>
<td>F10</td>
<td>调试单步执行</td>
</tr>
<tr>
<td>F5</td>
<td>开始调试</td>
</tr>
<tr>
<td>Shift + F5</td>
<td>停止调试</td>
</tr>
<tr>
<td>Ctrl + Alt + Q</td>
<td>添加快捷匹配</td>
</tr>
<tr>
<td>F9</td>
<td>设置或删除断点</td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/DahlinSky/article/details/109287866">VisualStudio2019快捷键汇总_Dahlin哥's 博客-CSDN博客_vs快捷键</a></p>
<h4 id="842-窗口">8.4.2 窗口</h4>
<p>重点：某些窗口只有当调试起来（快捷键 <code>F10</code>和 <code>F11</code>）之后才会显示。</p>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555614314.png" alt="" loading="lazy"></p>
<h4 id="843-断点">8.4.3 断点</h4>
<blockquote>
<p>设置断点，如果开始执行（不调试），程序直接执行结束，并不会在断点处暂停。所以使用断点必须调试执行才能生效。断点之前的程序正常执行，到断点处暂停。使用断点窗口，可以方便的查看多个源文件中的断点位置。</p>
</blockquote>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555620289.png" alt="" loading="lazy"></p>
<p><strong>添加条件</strong></p>
<ul>
<li>在循环中设置断点的条件，可以循环到一定的次数之后进行暂停。</li>
</ul>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5C1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555627090.png" alt="" loading="lazy"></p>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5C2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555633166.png" alt="" loading="lazy"></p>
<p><strong>其他</strong></p>
<ul>
<li>使用<code>F5</code>移动到下一个断点。</li>
</ul>
<h4 id="844-监视">8.4.4 监视</h4>
<blockquote>
<p>监视各个变量值的变化。可以自己添加需要监视的标识符和不需要监视的标识符。</p>
</blockquote>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_4.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555641701.png" alt="" loading="lazy"></p>
<blockquote>
<p>此外还有自动监视和局部变量窗口。自动监视窗口可以自动检测需要监视的变量。局部变量窗口显示局部变量的变化。</p>
</blockquote>
<h4 id="845-调用堆栈">8.4.5 调用堆栈</h4>
<blockquote>
<p>函数的调用逻辑。</p>
</blockquote>
<h4 id="846-其他">8.4.6 其他</h4>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_5.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555648495.png" alt="" loading="lazy"></p>
<blockquote>
<p>内存窗口，可以设置每行显示的列数。</p>
</blockquote>
<h2 id="85-调试实例">8.5 调试实例</h2>
<h4 id="851-阶乘之和">8.5.1 阶乘之和</h4>
<blockquote>
<p>找出代码中的bug</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int n = 3;
  int sum = 0;
  int mul = 1;
  for (int i = 1; i &lt;= n; i++)
  {
    for (int j = 1; j &lt;= i; j++)
    {
      mul *= j;
    }
    sum += mul;
  }
  printf(&quot;%d\n&quot;, sum);
  return 0;
}
</code></pre>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_6.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555656194.png" alt="" loading="lazy"></p>
<pre><code class="language-C">// bug原因，mul变量在每次循环之后并没有重置为1
</code></pre>
<h4 id="852-数组越界死循环">8.5.2 数组越界死循环</h4>
<blockquote>
<p>寻找原因</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int i = 0;
  int arr[10] = { 0 };
  for ( i = 0; i &lt;= 12; i++)
  {
    arr[i] = 0;
    printf(&quot;Hello\n&quot;);
  }
  return 0;
}
// vs2013~2019出现死循环
// vs2022中正常循环12次，并没有出现数组访问越界错误
// 下图为vs2022运行结果图
</code></pre>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_7.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555664507.png" alt="" loading="lazy"></p>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_8.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555671357.png" alt="" loading="lazy"></p>
<h2 id="86-如何写出好易于调试的代码">8.6 如何写出好（易于调试）的代码</h2>
<h4 id="861-优秀的代码">8.6.1 优秀的代码</h4>
<ul>
<li>代码正常运行</li>
<li>bug很少</li>
<li>效率高</li>
<li>可读性高</li>
<li>可维护性高</li>
<li>注释清晰</li>
<li>文档齐全</li>
</ul>
<h4 id="862-常见的coding技巧">8.6.2 常见的coding技巧</h4>
<ul>
<li>使用assert</li>
<li>尽量使用const</li>
<li>养成良好的编码风格</li>
<li>添加必要的注释</li>
<li>避免编码的陷阱</li>
</ul>
<h4 id="863-实例">8.6.3 实例</h4>
<blockquote>
<p>模拟实现库函数strcpy</p>
</blockquote>
<p><strong>介绍</strong></p>
<ul>
<li>声明</li>
</ul>
<pre><code class="language-C">char *strcpy(char *dest, const char *src)
</code></pre>
<ul>
<li>
<p>参数</p>
<ul>
<li>dest: 用于存储复制内容的目标数组</li>
<li>src: 要复制的字符串</li>
</ul>
</li>
<li>
<p>返回值：返回指向目标字符串的指针<br>
<strong>代码</strong></p>
</li>
<li>
<p>库函数</p>
<pre><code class="language-C">#include &lt;string.h&gt;
int main() {
  char arr1[20] = { 0 };
  char arr2[] = &quot;Hello World!&quot;;
  strcpy(arr1, arr2);
  printf(arr1);
  return 0;
}
// 需要在源文件最开始加入#define _CRT_SECURE_NO_WARNINGS
</code></pre>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C8.%E8%B0%83%E8%AF%95%5Cimage%5Cimage_9.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555679715.png" alt="" loading="lazy"></p>
</li>
<li>
<p>自实现</p>
<pre><code class="language-C">void my_strcpy(char* dest, char* sour)
{
  while (*sour != '\0')
  {
    *dest = *sour;
    dest++;
    sour++;
  }
  *dest = *sour;
}

int main() {
  char arr1[20] = { '\0'};
  char arr2[] = &quot;Hello&quot;;
  my_strcpy(arr1, arr2);
  printf(arr1);
  return 0;
}
</code></pre>
</li>
<li>
<p>优化1</p>
<pre><code class="language-C">void my_strcpy(char* dest, char* sour)
{
  while (*sour != '\0')
  {
    *dest++ = *sour++;
  }
  *dest = *sour;
}
</code></pre>
</li>
<li>
<p>优化2</p>
<pre><code class="language-C">void my_strcpy(char* dest, char* sour)
{
  while (*sour)
  {
    *dest++ = *sour++;
  }
  *dest = *sour;
}
</code></pre>
</li>
<li>
<p>优化3</p>
<pre><code class="language-C">void my_strcpy(char* dest, char* sour)
{
  while (*dest++ = *sour++); 
  // 先将*sour赋值给*dest
  // 获得整个表达式的结果
  // 并判断整个表达式的结果是否为假
  // 如果为真 再对dest和sour进行自增
}
</code></pre>
</li>
<li>
<p>优化4</p>
<pre><code class="language-C">void my_strcpy(char* dest, char* sour)
{
  assert(src != NULL); // 断言
  assert(dest != NULL); // 断言
  while (*dest++ = *sour++); 
}
// assert的使用需要引用头文件&lt;assert.h&gt;
// assert中的表达式类似于if中的表达式
</code></pre>
</li>
<li>
<p>优化5</p>
<pre><code class="language-C">void my_strcpy(char* dest, const char* sour)
{
  assert(src != NULL);
  assert(dest != NULL);
  while (*dest++ = *sour++); 
}
// const char* sour
// sour指向的对象的内容不能被修改
// 防止将dest中的内容复制到sour中
// 即使发生了问题，发生的也只是语法错误，也容易找出并解决问题
// 另外const char* sour中的const只需要在*前面，并不一定要在char前面
// 即：char const * sour 但一般char*是一种类型，不拆开
</code></pre>
<ul>
<li>
<p>常量指针和指针常量</p>
<pre><code class="language-C">int main()
{
  int m = 100;
  int n = 10;

  //const int* p = &amp;n; // 指针变量指向的对象不能改变
  //*p = 100; // ×
  //p = &amp;m; // √

  //int* const p = &amp;n; // 指针变量的值不能改变
  //p = &amp;m; // ×
  //*p = m; // √

  //const int* const p = &amp;n; // 指针变量和指针变量的值都不能改变
  //p = &amp;m; // ×
  //*p = m; // ×

  //const int* p; // 称为常量指针
  //int* const p; // 称为指针常量
  return 0;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>优化6</p>
<pre><code class="language-C">char* my_strcpy(char* dest, const char* sour)
{
  assert(src != NULL);
  assert(dest != NULL);
  char* ret = dest;
  while (*dest++ = *sour++);
  return ret; // 返回目标空间的其实地址（为了更好的看到目标地址发生的变化）
}
// 链式访问功能
</code></pre>
</li>
</ul>
<blockquote>
<p>模拟实现库函数strlen</p>
</blockquote>
<ul>
<li>
<p>自实现</p>
<pre><code class="language-C">size_t my_strlen(const char *s)
{
  assert(s);
  size_t len = 0;
  while (*s++)len++;
  return len;
}
// size_t 相当于 unsigned int

int main()
{
  char s[] = &quot;hello&quot;;
  int len = my_strlen(s);
  printf(&quot;%d\n&quot;, len);
  return 0;
}
</code></pre>
</li>
<li>
<p>参考代码</p>
<pre><code class="language-C">size_t __cdecl strlen (
        const char * str
        )
{
        const char *eos = str;

        while( *eos++ ) ;

        return( eos - str - 1 );
}

// 参考代码并不代表真实实现
// __cdecl表示函数调用约定，不影响函数使用
</code></pre>
</li>
</ul>
<h2 id="87-编程常见的错误">8.7 编程常见的错误</h2>
<h4 id="错误类型">错误类型</h4>
<ul>
<li>
<p>编译型错误</p>
<blockquote>
<p>直接看错误提示信息（双击定位出错位置），解决问题。或者凭借经验就可以搞定。相对来说简单。</p>
</blockquote>
</li>
<li>
<p>链接型错误</p>
<blockquote>
<p>看错误提示信息，主要在代码中找到错误信息的标识符，然后定位问题所在。一般是标识符名不存在或者拼写错误。</p>
</blockquote>
</li>
<li>
<p>运行时错误</p>
<blockquote>
<p>借助调试信息，逐步定位问题。难度最大。</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. C语言--结构体]]></title>
        <id>https://listen2022.github.io/bDOIBKF8Z/</id>
        <link href="https://listen2022.github.io/bDOIBKF8Z/">
        </link>
        <updated>2022-01-30T15:09:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="7结构体">7.结构体</h1>
<h2 id="71-结构体">7.1 结构体</h2>
<p>类型的声明</p>
<h4 id="711-介绍">7.1.1 介绍</h4>
<blockquote>
<p>结构体是由一批数据组合而成的结构型数据。组成结构型数据的每个数据称为结构型数据的“成员”，其描述了一块内存区间的大小及解释意义。</p>
</blockquote>
<ul>
<li>结构体是一种数据类型，地位同等于int、float等</li>
<li>结构体类型不是系统定义好的，由程序员自己定义</li>
<li>使用struct关键字来标识定义的结构体类型</li>
<li>结构体通常用来表示类型不同但又相关的若干数据</li>
<li>关键字struct和结构体名组成类型标识符</li>
<li>成员又称为成员变量，是结构体所包含的若干个基本的结构类型</li>
<li>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针</li>
</ul>
<h4 id="712-声明">7.1.2 声明</h4>
<pre><code class="language-C">// 格式：
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list;

// tag: 结构体标签
// member-list: 变量定义
// variable-list: 结构体变量
// 一般情况下：tag、member-list、variable-list 3部分至少出现两个

// 使用typedef创建新类型
typedef struct
{
    int a;
    char b;
    double c; 
} Simple;
// 可以用Simple作为类型声明新的结构体变量
// eg:
Simple s;
</code></pre>
<h4 id="713-例">7.1.3 例</h4>
<pre><code class="language-C">int main()
{
  struct Person
  {
    char name[10];
    short age;
  };

  struct Student
  {
    char id[20];
    struct Person p;
  };
  return 0;
}
</code></pre>
<h2 id="72-结构体初始化">7.2 结构体初始化</h2>
<h4 id="721-定义时初始化">7.2.1 定义时初始化</h4>
<pre><code class="language-C">int main()
{
  struct Person
  {
    char name[10];
    short age;
  };

  struct Student
  {
    char id[20];
    struct Person p;
  } s = {&quot;1914121006&quot;, {&quot;listen&quot;, 25}};
  return 0;
}
</code></pre>
<h4 id="722-定义后初始化">7.2.2 定义后初始化</h4>
<pre><code class="language-C">struct Person
{
  char name[10];
  short age;
};

struct Student
{
  char id[20];
  struct Person p;
};

int main()
{
  struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} };
  return 0;
}
</code></pre>
<h2 id="73-结构体成员访问">7.3 结构体成员访问</h2>
<h4 id="731">7.3.1 <code>.</code></h4>
<pre><code class="language-C">struct Person
{
  char name[10];
  short age;
};

struct Student
{
  char id[20];
  struct Person p;
};

int main()
{
  struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} };
  printf(&quot;id: %s\nname: %s\nage: %d\n&quot;, s.id, s.p.name, s.p.age);
  return 0;
}
</code></pre>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C7.%E7%BB%93%E6%9E%84%E4%BD%93%5Cimage%5Cimage.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555465680.png" alt="" loading="lazy"></p>
<h4 id="732">7.3.2 <code>→</code></h4>
<pre><code class="language-C">struct Person
{
  char name[10];
  short age;
};

struct Student
{
  char id[20];
  struct Person p;
};

int main()
{
  struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} };
  struct Student* ps = &amp;s;
  printf(&quot;id: %s\nname: %s\nage: %d\n&quot;, (*ps).id, (*ps).p.name, (*ps).p.age);
  printf(&quot;id: %s\nname: %s\nage: %d\n&quot;, ps-&gt;id, ps-&gt;p.name, ps-&gt;p.age);
  return 0;
}
</code></pre>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C7.%E7%BB%93%E6%9E%84%E4%BD%93%5Cimage%5Cimage_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555475043.png" alt="" loading="lazy"></p>
<h2 id="74-结构体传参">7.4 结构体传参</h2>
<pre><code class="language-C">struct Person
{
  char name[10];
  short age;
};

struct Student
{
  char id[20];
  struct Person p;
};

void print1(struct Student s)
{
  printf(&quot;id: %s\nname: %s\nage: %d\n&quot;, s.id, s.p.name, s.p.age);
}

void print2(struct Student* ps)
{
  printf(&quot;id: %s\nname: %s\nage: %d\n&quot;, ps-&gt;id, ps-&gt;p.name, ps-&gt;p.age);
}

int main()
{
  struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} };
  print1(s); // 值传递
  print2(&amp;s); // 址传递
  return 0;
}
</code></pre>
<p><img src="file://C:%5CUsers%5CTurbo%5CDesktop%5C7.%E7%BB%93%E6%9E%84%E4%BD%93%5Cimage%5Cimage_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643555480966.png" alt="" loading="lazy"></p>
<ul>
<li>print1和pirnt2对比：
<ul>
<li>print1: 值传递，更安全。传参时，需要开辟一块与结构体变量s同等大小的区域用于将s复制一份到print1函数中，相比于print2消耗更多的内存资源。此外，print1函数中不可以修改结构体变量s中的值。</li>
<li>print2: 址传递。传参时，在32位平台使用4字节内存资源，在64位平台使用8字节。相比于print1，消耗更少的内存资源。此外，print2可以修改结构体变量s中成员变量的值。但print2相对于print1不安全。</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数传参的时候，参数是需要压栈的，并且按照参数列表的顺序，从右向左压栈。如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降。</p>
</blockquote>
<p><strong>结论</strong>：结构体传参时，要传结构体的指针。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[6. C语言--指针]]></title>
        <id>https://listen2022.github.io/6-c-yu-yan-zhi-zhen/</id>
        <link href="https://listen2022.github.io/6-c-yu-yan-zhi-zhen/">
        </link>
        <updated>2022-01-30T09:32:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="6指针">6.指针</h1>
<h2 id="61-指针是什么">6.1 指针是什么？</h2>
<blockquote>
<p>在计算机中，所有的数据都是存放在存储器中的，不同的数据类型占有的内存空间的大小各不相同。内存是以字节为单位的连续编址空间，每一个字节单元对应着一个独一的编号，这个编号被称为内存单元的地址。比如：int 类型占 4 个字节，char 类型占 1 个字节等。系统在内存中，为变量分配存储空间的首个字节单元的地址，称之为该变量的地址。地址用来标识每一个存储单元，方便用户对存储单元中的数据进行正确的访问。在高级语言中地址形象地称为指针。</p>
</blockquote>
<h4 id="611-内存与地址">6.1.1 内存与地址</h4>
<blockquote>
<p>指针相对于一个内存单元来说，指的是单元的地址，该单元的内容里面存放的是数据。在 C 语言中，允许用指针变量来存放指针，因此，一个指针变量的值就是某个内存单元的地址或称为某内存单元的指针。</p>
</blockquote>
<h4 id="612-内存空间的访问">6.1.2 内存空间的访问</h4>
<ul>
<li>直接访问：变量代表有名字的内存单元，通过变量名直接访问内存空间。</li>
<li>间接访问：指针是内存空间的地址，通过指针解引用间接访问内存空间。</li>
</ul>
<h4 id="613-指针声明">6.1.3 指针声明</h4>
<pre><code class="language-C">type* pointer_name;
// type指明该指针变量的类型
// *说明该变量是一个指针变量
</code></pre>
<h4 id="614-指针大小">6.1.4 指针大小</h4>
<pre><code class="language-C">int main()
{
  printf(&quot;%u\n&quot;, sizeof(int*));
  printf(&quot;%u\n&quot;, sizeof(char*));
  printf(&quot;%u\n&quot;, sizeof(float*));
  return 0;
}
</code></pre>
<ul>
<li>32位平台，占据4byte<br>
<img src="image/image.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535227637.png" alt="" loading="lazy"></li>
<li>64位平台，占据8byte<br>
<img src="image/image_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535232095.png" alt="" loading="lazy"></li>
</ul>
<h2 id="62-指针和指针类型">6.2 指针和指针类型</h2>
<h4 id="621-指针的类型">6.2.1 指针的类型</h4>
<blockquote>
<p>指针的类型和指针所指向的对象的类型是两个不同的概。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int a = 100;
  int* pa = &amp;a; // 其中`*`表示pa是一个指针变量，`int`表示pa是一个int类型指针
  return 0;
}
</code></pre>
<ul>
<li>指针的大小都是一样的，为什么不创建一个通用类型指针？</li>
</ul>
<h4 id="622-指针类型的意义">6.2.2 指针类型的意义</h4>
<ul>
<li>
<p>指针类型决定了指针解引用的权限（能访问字节的数目）</p>
<pre><code class="language-C">int main()
{
  int a = 0xffffffff;
  int* pi = &amp;a; // int类型指针
  *pi = 1; // 解引用操作四个字节
  printf(&quot;%x\n&quot;, a);
  // char* pc = &amp;a;
  // *pc = 1;
  // printf(&quot;%x\n&quot;, a);
  return 0;
}
</code></pre>
<p><img src="image/image_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535240789.png" alt="" loading="lazy"></p>
<pre><code class="language-C">int main()
{
  int a = 0xffffffff;
  // int* pi = &amp;a; 
  // *pi = 1;
  // printf(&quot;%x\n&quot;, a);
  char* pc = &amp;a; // char类型指针
  *pc = 1; // 解引用只操作一个字节
  printf(&quot;%x\n&quot;, a);
  return 0;
}
</code></pre>
<p><img src="image/image_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535245866.png" alt="" loading="lazy"></p>
</li>
<li>
<p>指针类型决定了指针的步长</p>
<pre><code class="language-C">int main()
{
  int arr[10] = { 0 };
  int* pi = arr;
  char* pc = arr;
  printf(&quot;%x&quot;, pi);
  printf(&quot;%x&quot;, pi+1); // int类型指针+1，改变4个字节，步长为4byte
  printf(&quot;%x&quot;, pc);
  printf(&quot;%x&quot;, pc+1); // char类型指针+1，改变1个字节，步长为1byte
  return 0;
}
</code></pre>
<p><img src="image/image_4.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535251528.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="623-使用">6.2.3 使用</h4>
<pre><code class="language-C">int main()
{
  int arr[10] = { 0 };
  int* pa = arr; // 数组名是数组第一个元素的指针
  for (int i = 0; i &lt; 10; i++)
  {
    *pa = 100;
    pa++;
  }
  for (int i = 0; i &lt; 10; i++)
  {
    printf(&quot;%d\n&quot;, arr[i]);
  }
  return 0;
}

</code></pre>
<p><img src="image/image_5.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535258095.png" alt="" loading="lazy"></p>
<ul>
<li>如果将int类型指针换为char类型指针，如下<br>
<img src="image/image_6.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535262971.png" alt="" loading="lazy"></li>
</ul>
<h2 id="63-野指针">6.3 野指针</h2>
<blockquote>
<p>定义：指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）。</p>
</blockquote>
<h4 id="631-野指针的成因">6.3.1 野指针的成因</h4>
<ul>
<li>
<p>指针变量未初始化</p>
<blockquote>
<p>类似于：去酒店，没有办理入住手续，直接随便找个房间就住。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int* p; // 局部变量指针未初始化，默认为随机值
  *p = 100;
  return 0;
}
</code></pre>
<p><img src="image/image_7.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535270543.png" alt="" loading="lazy"></p>
</li>
<li>
<p>指针越界访问</p>
<blockquote>
<p>类似于：酒店房间号只有000~100，而你非要去找房间号为111的房间。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int arr[10] = { 0 };
  int* p = arr;
  for (int i = 0; i &lt;= 10; i++)
  {
    *p = i;
    p++;
  }
}
</code></pre>
<p><img src="image/image_8.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535277850.png" alt="" loading="lazy"></p>
</li>
<li>
<p>指针指向的空间释放</p>
<blockquote>
<p>类似于：都已经办理退房手续，你仍然要在房间里住。</p>
</blockquote>
<pre><code class="language-C">// 非法访问内存，指针指向的空间不属于该程序
int* func() 
{
  int a = 10;
  return &amp;a; // 函数返回之后，将a的内存空间释放，还给操作系统
}

int main()
{
  int* p = func();
  *p = 20;
  return 0;
}

</code></pre>
<p><img src="image/image_9.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535360868.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="632-如何避免野指针">6.3.2 如何避免野指针</h4>
<ul>
<li>
<p>指针初始化</p>
<pre><code class="language-C">// 方式一
int* p = NULL // NULL在stdio.h头文件中

// 方式二
int a = 100;
int* p = &amp;a;
</code></pre>
</li>
<li>
<p>小心指针越界</p>
<pre><code class="language-C">// 数组越界
// C语言本身是不会检查数组是否越界
</code></pre>
</li>
<li>
<p>指针指向空间及时置NULL</p>
<pre><code class="language-C">*p = NULL;
// 此时p依然不能使用

// 例如：
int main()
{
  int* p = NULL;
  *p = 100; // NULL属于操作系统，空间地址并没有分配给用户，所以用户不能访问
  return 0;
}

</code></pre>
<p><img src="image/image_10.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535351635.png" alt="" loading="lazy"></p>
</li>
<li>
<p>指针使用前检查有效性</p>
<pre><code class="language-C">int *p = NULL;
if(p != NULL){
  code...
}
</code></pre>
</li>
</ul>
<h4 id="633-实例">6.3.3 实例</h4>
<pre><code class="language-C">#include &lt;stdio.h&gt;
main() {
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p = a + 5, *q = NULL;
    *q = *(p+5);
    printf(&quot;%d %d\n&quot;, *p, *q);
}
// 结果：运行后报错
</code></pre>
<h2 id="64-指针运算">6.4 指针运算</h2>
<h4 id="641-">6.4.1 <code>+</code> <code>-</code></h4>
<pre><code class="language-C">int main()
{
  int arr[5];
  int* p;
  for (p = &amp;arr[0]; p &lt; &amp;arr[5]; )
  {
    *p++ = 0;
    // 相当于：
    // *p = 0;
    // p++;
  }
  return 0;
}
// 随着数组索引增大，地址由低到高变化
</code></pre>
<p><img src="image/image_11.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535384377.png" alt="" loading="lazy"></p>
<h4 id="642">6.4.2 <code>&gt;</code> <code>≥</code> <code>&lt;</code> <code>≤</code> <code>==</code></h4>
<blockquote>
<p>指针的关系运算。</p>
</blockquote>
<pre><code class="language-C">// 打印数组中的元素
int main()
{
  int arr[5] = { 1, 2, 3, 4, 5 };
  int* p = arr; // arr第一个元素的地址
  int* pend = p + 4; // arr最后一个元素的地址
  while (p&lt;=pend)
  {
    printf(&quot;%d\n&quot;, *p);
    p++;
  }

  return 0;
}

</code></pre>
<p><img src="image/image_12.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535391334.png" alt="" loading="lazy"></p>
<h4 id="643-指针-指针">6.4.3 指针<code>-</code>指针</h4>
<blockquote>
<p>两个指针相减的结果是数组中两个元素之间的个数。指针相加是没有意义的（类似日期与日期相加）。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int arr[10] = { 0 };
  printf(&quot;%d\n&quot;, &amp;arr[9]-&amp;arr[0]);
  return 0;
}
</code></pre>
<p><img src="image/image_13.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535399263.png" alt="" loading="lazy"></p>
<blockquote>
<p>指针相减的前提：两个指针指向同一块区域。</p>
</blockquote>
<h4 id="644-应用求字符串长度len">6.4.4 应用（求字符串长度len）</h4>
<ul>
<li>
<p>方法一：库函数</p>
<pre><code class="language-C">#include &lt;string.h&gt;
int main()
{
  char s[] = &quot;Hello&quot;;
  int len = strlen(s);
  printf(&quot;%d\n&quot;, len);
}
</code></pre>
<p><img src="image/image_14.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535406854.png" alt="" loading="lazy"></p>
</li>
<li>
<p>方法二：计数器</p>
<pre><code class="language-C">int my_strlen(char* p)
{
  int count = 0;
  while (*p != '\0')
  {
    count++;
    p++;
  }
  return count;
}

int main()
{
  char s[] = &quot;Hello&quot;;
  int len = my_strlen(s); // 传参时，传递的是字符串的第一个字符的地址
  printf(&quot;%d\n&quot;, len);
}
</code></pre>
<p><img src="image/image_15.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535413972.png" alt="" loading="lazy"></p>
</li>
<li>
<p>方法三：指针相减</p>
<pre><code class="language-C">int my_strlen(char* p)
{
  char* p0 = p;
  while (*p != '\0')
  {
    p++;
  }
  return p - p0;
}

int main()
{
  char s[] = &quot;Hello&quot;;
  int len = my_strlen(s); // 传参时，传递的是字符串的第一个字符的地址
  printf(&quot;%d\n&quot;, len);
}
</code></pre>
<p><img src="image/image_16.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535420927.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="644-其他">6.4.4 其他</h4>
<pre><code class="language-C">for(vp = &amp;values[N_VALUES-1]; vp &gt;= &amp;values[0]; vp--)
{
  *vp = 0;
}

// 在大部分的编译器上可以正常运行，然而应避免这样编码，因为标准并不保证它可行。
</code></pre>
<p><strong>标准规定</strong></p>
<blockquote>
<p>允许指向数组元素的指针与指向数组最后一个元素后面的哪个内存位置的指针比较，但不允许与指向第一个元素之前的那个内存位置的指针进行比较。</p>
</blockquote>
<h2 id="65-指针和数组">6.5 指针和数组</h2>
<h4 id="651-数组名是数组首元素的地址">6.5.1 数组名是数组首元素的地址</h4>
<pre><code class="language-C">int main()
{
  int arr[5] = { 0 };
  printf(&quot;%p\n&quot;, arr);
  printf(&quot;%p\n&quot;, &amp;arr[0]);
  return 0;
}
</code></pre>
<p><img src="image/image_17.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535432338.png" alt="" loading="lazy"></p>
<h4 id="652-通过指针操作数组元素">6.5.2 通过指针操作数组元素</h4>
<pre><code class="language-C">int main()
{
  int arr[5] = { 0 };
  int* p = arr;
  for (int i = 0; i &lt; 5; i++)
  {
    *(p + i) = i;
  }
  for (int i = 0; i &lt; 5; i++)
  {
    printf(&quot;%d\n&quot;, *(p+i));
  }
}

</code></pre>
<p><img src="image/image_18.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535444343.png" alt="" loading="lazy"></p>
<h4 id="653-下标引用操作符的交换律">6.5.3 下标引用操作符的交换律</h4>
<pre><code class="language-C">int main()
{
    int arr[5] = { 1, 2, 3, 4, 5 };
    int* p = arr;
    // 访问下标为3的元素的底层原理：
    // arr[3] =&gt; *(p+3)
    // 根据加法的交换律，可得
    // *(p+3) = *(3+p)
    // 则
    // arr[3] = 3[arr];
    // []下标引用操作符也具有交换律
    printf(&quot;%d\n&quot;, arr[3]);
    printf(&quot;%d\n&quot;, 3[arr]);
    printf(&quot;%d\n&quot;, p[3]);
    printf(&quot;%d\n&quot;, 3[p]);
}
</code></pre>
<p><img src="image/image_19.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535450885.png" alt="" loading="lazy"></p>
<h2 id="66-二级指针">6.6 二级指针</h2>
<h4 id="661-创建">6.6.1 创建</h4>
<pre><code class="language-C">int main()
{
  int n = 100;
  int* pn = &amp;n; // 一级指针
  int** ppn = &amp;pn; // 二级指针
}
// 依次类推，还有三级、四级...
</code></pre>
<p><img src="image/image_20.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535458277.png" alt="" loading="lazy"></p>
<pre><code class="language-C">// 指针变量中存储了地址，跟普通变量一样，需要开辟一块内存空间用来存放数据
// 而指针变量所在的地址，用二级指针来表示
// pnn中存放的是pn的地址
// pn中存放的是n的地址
// n中存放的是数据
</code></pre>
<h4 id="662-访问">6.6.2 访问</h4>
<pre><code class="language-C">int main()
{
  int n = 100;
  int* pn = &amp;n; // 一级指针
  int** ppn = &amp;pn; // 二级指针
  // *pnn = pn;
  // *pn = n;
  // 所以：**pnn = n; 即通过**pnn即可访问变量n
}
</code></pre>
<h2 id="67-指针数组">6.7 指针数组</h2>
<pre><code class="language-C">int arr1[10]; // 整形数组
float arr2[10]; // 浮点型数组
char arr3[10]; // 字符型数组

int* parr1[10]; // 整形指针数组
float* parr2[10]; // 浮点型指针数组
char* parr3[10]; // 字符型指针数组

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5. C语言--操作符]]></title>
        <id>https://listen2022.github.io/5-c-yu-yan-cao-zuo-fu/</id>
        <link href="https://listen2022.github.io/5-c-yu-yan-cao-zuo-fu/">
        </link>
        <updated>2022-01-30T09:25:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="5操作符">5.操作符</h1>
<h2 id="51-算术操作符">5.1 算术操作符</h2>
<pre><code class="language-C">+ - * / %
</code></pre>
<ul>
<li>
<p>除%操作符之外，其他几个操作符可以作用于整数和浮点数。</p>
</li>
<li>
<p>对于/操作符如果两个操作符都为整数，执行整数除法。只要有一个浮点数，则执行浮点数除法。</p>
<pre><code class="language-C">float num = 1 / 2; // num=0.000000; 

float num = 1 / 2.0; // num=0.500000;
// 这里的2.0 是double类型 而num为float类型
// 可以做如下调整

float num = 1f / 2.0f;
double num = 1 / 2.0;

</code></pre>
</li>
<li>
<p>%操作符两端必须都是整数，可以是负数，但不能为0。</p>
</li>
</ul>
<h2 id="52-移位操作符">5.2 移位操作符</h2>
<pre><code class="language-C">&gt;&gt; &lt;&lt;
</code></pre>
<h4 id="521-非负整数的二进制表示形式">5.2.1 非负整数的二进制表示形式</h4>
<ul>
<li>原码：直接根据数值写出二进制</li>
<li>反码：原码符号位不变，其他位按位取反</li>
<li>补码：反码加1</li>
</ul>
<pre><code class="language-C">// 非负整数在内存中存放的是原码（非负整数的原码、反码、补码相同）
// 负整数在内存中存放的是补码
</code></pre>
<h4 id="522-左移">5.2.2 左移</h4>
<blockquote>
<p>算数左移和逻辑左移相同，都是左边抛弃，右边补0。</p>
</blockquote>
<h4 id="523-右移">5.2.3 右移</h4>
<ul>
<li>
<p>算术右移（通常采用）</p>
<blockquote>
<p>向右移动，首位补原二进制位的第一位</p>
</blockquote>
</li>
<li>
<p>逻辑右移</p>
<blockquote>
<p>向右移动，首位补0</p>
</blockquote>
</li>
</ul>
<pre><code class="language-C">// 只能移动非负整数位

int main()
{
  int ret = -1 &gt;&gt; 1;
  printf(&quot;%d\n&quot;, ret);
  return 0;
}

</code></pre>
<p><img src="image/image.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534828469.png" alt="" loading="lazy"></p>
<h2 id="53-位操作符">5.3 位操作符</h2>
<pre><code class="language-C">&amp; | ^ // 操作数必须为整数
</code></pre>
<h4 id="531-按位与">5.3.1 按位与</h4>
<pre><code class="language-C">int main()
{
  int ret = 3 &amp; 4; 
  // 00000000000000000000000000000011 
  //                                &amp; 
  // 00000000000000000000000000000100
  printf(&quot;%d\n&quot;, ret);
  return 0;
}
</code></pre>
<p><img src="image/image_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534835273.png" alt="" loading="lazy"></p>
<h4 id="532-按位或">5.3.2 按位或</h4>
<pre><code class="language-C">// 按位或
int main()
{
  int ret = 3 | 4; 
  // 00000000000000000000000000000011 
  //                                |
  // 00000000000000000000000000000100
  printf(&quot;%d\n&quot;, ret);
  return 0;
}

</code></pre>
<p><img src="image/image_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534840541.png" alt="" loading="lazy"></p>
<h4 id="533-按位异或">5.3.3 按位异或</h4>
<blockquote>
<p>相同为0，相异为1</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int ret = 3 ^ 4; 
  // 00000000000000000000000000000011 
  //                                ^
  // 00000000000000000000000000000100
  printf(&quot;%d\n&quot;, ret);
  return 0;
}
// 奇数^奇数=偶数
// 奇数^偶数=奇数
// 偶数^偶数=偶数

</code></pre>
<p><img src="image/image_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534846119.png" alt="" loading="lazy"></p>
<h4 id="534-题目">5.3.4 题目</h4>
<blockquote>
<p>交换两个int变量的值，不使用第三个变量</p>
</blockquote>
<ul>
<li>
<p>方法一</p>
<pre><code class="language-C">int main()
{
  int a = 3;
  int b = 4;
  a = a + b;
  b = a - b;
  a = a - b;
  printf(&quot;a=%d, b=%d\n&quot;, a, b);
  return 0;
}
// 问题：数字过大，内存溢出
</code></pre>
<p><img src="image/image_4.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534870079.png" alt="" loading="lazy"></p>
</li>
<li>
<p>方法二</p>
<pre><code class="language-C">int main()
{
  int a = 3;
  int b = 4;
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;
  printf(&quot;a=%d, b=%d\n&quot;, a, b);
  return 0;
}
// 没有进位，不可能发生溢出
// 异或特点：
//      1.任何数和他本身异或，结果为0
//      2.任何数和0异或，结果为他本身
//  底层逻辑：
//      b = a ^ b ^ b = a (前两行代码)
//      a = a ^ b ^ b ^ a ^ b = b (第三行代码)
</code></pre>
<p><img src="image/image_5.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534876725.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="535-练习">5.3.5 练习</h4>
<blockquote>
<p>编写代码实现：求一个整数存储在内存中的二进制中1的个数</p>
</blockquote>
<ul>
<li>
<p>方法一</p>
<pre><code class="language-C">int main()
{
  int num = 5;
  int count = 0;
  for (int i = 0; i &lt; 32; i++)
  {
    if (num % 2 == 1)
    {
      count++;
    }
    num = num &gt;&gt; 1;
  }
  printf(&quot;count=%d\n&quot;, count);
  return 0;
}

</code></pre>
<p><img src="image/image_6.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534883107.png" alt="" loading="lazy"></p>
<blockquote>
<p><strong>缺点：不能统计负数的二进制中1的个数。</strong></p>
</blockquote>
</li>
<li>
<p>方法二</p>
<pre><code class="language-C">int main()
{
    int num = -5;
    int count = 0;
    for (int i = 0; i &lt; 32; i++)
    {
        if ((num &gt;&gt; i) &amp; 1)
        {
            count++;
        }
    }
    printf(&quot;count=%d\n&quot;, count);
    return 0;
}
// -5 
// 原码 10000000000000000000000000000101
// 补码 11111111111111111111111111111011
// 右移0位
// 11111111111111111111111111111011 &amp; 00000000000000000000000000000001
// 00000000000000000000000000000001 -&gt; 1
// 右移一位
// 01111111111111111111111111111101 &amp; 00000000000000000000000000000001
// 00000000000000000000000000000001 -&gt; 1
// 右移二位
// 00111111111111111111111111111110 &amp; 00000000000000000000000000000001
// 00000000000000000000000000000000 -&gt; 0
// ...
// 右移31位
// 00000000000000000000000000000001 &amp; 00000000000000000000000000000001
// 00000000000000000000000000000001 -&gt; 1

</code></pre>
</li>
<li>
<p>方法三</p>
<pre><code class="language-C">int main()
{
    int num = -5;
    int count = 0;
    while (num)
    {
        num = num &amp; (num - 1);
        count++;
    }
    printf(&quot;count=%d\n&quot;, count);
    return 0;
}
// num &amp; (num - 1)
// 11111111111111111111111111111011 =&gt; num
// 11111111111111111111111111111011 &amp; (11111111111111111111111111111011 - 1)
// 11111111111111111111111111111011 &amp; 11111111111111111111111111111010
// 11111111111111111111111111111010 =&gt; num
// 11111111111111111111111111111010 &amp; (11111111111111111111111111111010 - 1)
// 11111111111111111111111111111010 &amp; 11111111111111111111111111111001
// 11111111111111111111111111111000 =&gt; num
// ...
// 每次把num&amp;(num-1)的结果再赋值给num
// 每num&amp;(num-1)运算一次，就会将num中的1变成0
// 通过n次num&amp;(num-1)运算使得num=0
// 此时n为num的二进制中1的个数
</code></pre>
<p><img src="image/image_7.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534891048.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="54-赋值操作符">5.4 赋值操作符</h2>
<pre><code class="language-C">= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= |= ^=

// 连续赋值：
int a = 0;
int b = 0;
int c = 1;
a = b = c + 1; // 从由向左赋值（不推荐）
</code></pre>
<h2 id="55-单目操作符">5.5 单目操作符</h2>
<blockquote>
<p>只有一个操作数</p>
</blockquote>
<pre><code class="language-C">!      // 逻辑反操作
-      // 负
+      // 正
sizeof // 操作数类型长度
~      // 按位取反
--     // 前置 后置
++     // 前置 后置
*      // 解引用(间接访问)操作符
&amp;      // 取址       
(type) // 强制类型转换
</code></pre>
<h4 id="551-sizeof">5.5.1 sizeof</h4>
<blockquote>
<p>sizeof是一个操作符，不是函数。单位：字节</p>
</blockquote>
<ul>
<li>
<p>例1</p>
<pre><code class="language-C">int main()
{
  short s = 5;
  int a = 10;
  printf(&quot;%d\n&quot;, sizeof(s = a + 2)); 
  // sizeof括号中放的表达式，不参与运算
  // 在编译期间处理sizeof(s = a + 2); 而s = a + 2在程序运行时计算
  // 大数据放在小空间里被截断
  printf(&quot;%d\n&quot;, s); // 5
  return 0;
}
</code></pre>
<p><img src="image/image_8.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534903316.png" alt="" loading="lazy"></p>
</li>
<li>
<p>例2</p>
<pre><code class="language-C">int main()
{
  int a = 10;
  printf(&quot;%d\n&quot;, sizeof(a));
  printf(&quot;%d\n&quot;, sizeof a);
  printf(&quot;%d\n&quot;, sizeof(int));
  //printf(&quot;%d\n&quot;, sizeof int);

  char arr[10] = { 0 };
  printf(&quot;%d\n&quot;, sizeof(arr));
  printf(&quot;%d\n&quot;, sizeof arr);
  printf(&quot;%d\n&quot;, sizeof(char [10]));
}
</code></pre>
<p><img src="image/image_9.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534911686.png" alt="" loading="lazy"></p>
</li>
<li>
<p>例3</p>
<pre><code class="language-C">void foo1(int arr[10])
{
  printf(&quot;%d\n&quot;, sizeof(arr));
}
void foo2(char arr[10])
{
  printf(&quot;%d\n&quot;, sizeof(arr));
}

int main()
{
  int arr1[10] = { 0 };
  char arr2[10] = { 0 };
  printf(&quot;%d\n&quot;, sizeof(arr1)); // 40
  printf(&quot;%d\n&quot;, sizeof(arr2)); // 10
  foo1(arr1); // 4或8
  foo2(arr2); // 4或8
  return 0;
}
// 数组作为函数参数传递时，实际传递的是数组的指针
</code></pre>
<p><img src="image/image_10.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534919604.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="552-~">5.5.2 ~</h4>
<blockquote>
<p>按位取反</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int a = 13;
  // 00000000000000000000000000001101
  // 将a的二进制位第五位置零
  // 00000000000000000000000000001101  -&gt;  13的二进制
  // 00000000000000000000000000010000  -&gt;  1&lt;&lt;4
  //                                |  -&gt;  按位或
  // 00000000000000000000000000011101  -&gt;  结果29
  a = a | (1 &lt;&lt; 4);
  printf(&quot;%d\n&quot;, a);
  
  // 将a的二进制位第五位置一
  // 00000000000000000000000000011101  -&gt;  29的二进制
  // 11111111111111111111111111101111  -&gt;  ~(1&lt;&lt;4)
  //                                &amp;  -&gt;  按位与
  // 00000000000000000000000000001101  -&gt;  结果13
  a = a &amp; (~(1 &lt;&lt; 4));
  printf(&quot;%d\n&quot;, a);
  return 0;
}
</code></pre>
<p><img src="image/image_11.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534926264.png" alt="" loading="lazy"></p>
<h4 id="553">5.5.3 ++/—</h4>
<pre><code class="language-C">// 前置：先++，再使用
// 后置：先使用，再++
// (使用包括赋值和函数传参)
</code></pre>
<ul>
<li>
<p>后++<br>
<img src="image/image_12.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534936096.png" alt="" loading="lazy"></p>
</li>
<li>
<p>先++<br>
<img src="image/image_13.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534941184.png" alt="" loading="lazy"></p>
</li>
<li>
<p>垃圾代码</p>
<pre><code class="language-C">int main()
{
  int a = 1;
  int b = (++a) + (++a) + (++a);
  printf(&quot;%d\n&quot;, b);
  return 0;
}
// 运行结果：vs2019中结果是12
//         linux中结果是10
// 垃圾代码，不做过多研究 
</code></pre>
<p><img src="image/image_14.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534948743.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="554">5.5.4 &amp; *</h4>
<pre><code class="language-C">&amp; // 取址
* // 解引用
</code></pre>
<ul>
<li>
<p>例</p>
<pre><code class="language-C">int main()
{
  int num = 100; // &amp;获取对象所处的内存地址，取址操作符
  int* pn = &amp;num; // 此处*不是操作符，仅说明pn是一个指针变量
  *pn = 200; // 此处*才是解引用操作符，将200赋值给pn所指的对象
  printf(&quot;pn=%p, num=%d\n&quot;, pn, num);
  return 0;
}
</code></pre>
<p><img src="image/image_15.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534961757.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="555-type">5.5.5 (type)</h4>
<pre><code class="language-C">int main()
{
  int num = (int)3.1315; // 强制类型转换
  printf(&quot;%d\n&quot;, num);
  return 0;
}
</code></pre>
<p><img src="image/image_16.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534968484.png" alt="" loading="lazy"></p>
<h2 id="56-关系操作符">5.6 关系操作符</h2>
<pre><code class="language-C">&gt; &gt;= &lt; &lt;= != ==

// = 赋值
// == 判断是否相等

// 比较两个字符串是否相等不能使用==
</code></pre>
<h2 id="57-逻辑操作符">5.7 逻辑操作符</h2>
<pre><code class="language-C">&amp;&amp; 逻辑与：从前往后找到第一个为假的值返回0，否则返回1
|| 逻辑或：从前往后找到第一个为真的值返回1，否则返回0

</code></pre>
<h4 id="571-习题">5.7.1 习题</h4>
<blockquote>
<p>如下代码运行结果：</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int i = 0, a = 0, b = 2, c = 3, d = 4;
  i = a++ &amp;&amp; ++b &amp;&amp; d++;
  //i = a++ || ++b || d++;
  printf(&quot;a=%d, b=%d, c=%d, d=%d\n&quot;, a, b, c, d);
}

// &amp;&amp;: 左边确定为假，后边不用再进行计算
// ||: 左边确定为真，后边不用再进行计算
</code></pre>
<p><img src="image/image_17.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534978791.png" alt="" loading="lazy"></p>
<p><img src="image/image_18.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534984094.png" alt="" loading="lazy"></p>
<h2 id="58-三目操作符">5.8 三目操作符</h2>
<pre><code class="language-C">exp1 ? exp2 : exp3;
// 如果exp1为真，则计算exp2，整个表达式的结果为exp2的结果，exp3不计算
// 如果exp2为假，则计算exp3，整个表达式的结果为exp3的结果，exp2不计算
</code></pre>
<ul>
<li>
<p>例</p>
<pre><code class="language-C">int main()
{
  int a = 3;
  int b = 4;
  int ret = 0;
  ret = a &gt; b ? a++ : b++;
  printf(&quot;%d\n&quot;, ret);
  printf(&quot;a=%d, b=%d\n&quot;, a, b);
  return 0;
}
</code></pre>
<p><img src="image/image_19.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534997695.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="58-逗号表达式">5.8 逗号表达式</h2>
<pre><code class="language-C">exp1, exp2, exp3;
// 从前往后依次执行，整个表达式的结果为最后一个表达式exp3的计算结果
</code></pre>
<h2 id="59-下标引用">5.9 下标引用</h2>
<blockquote>
<p>下标引用操作符有两个操作数，数组名和下标。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int arr[10] = { 0 }; // 此处[]不是操作符，仅用来指定数组的大小
  arr[4] = 100; // 此处[]为操作符，指定数组中索引(或下标)为4的值为100
  printf(&quot;arr[4]=%d\n&quot;, arr[4]);
  return 0;
}

</code></pre>
<h2 id="510-函数调用">5.10 函数调用</h2>
<blockquote>
<p>有一个或多个操作数，当没有参数时，只有函数名一个操作数；当有参数时，操作时个数为参数个数+1。</p>
</blockquote>
<pre><code class="language-C">// 函数调用
int Add(int x, int y) // 此处()不是操作符，仅用来说明形参及其类型
{
  return x + y;
}

int main() {
  int ret = Add(3, 4); // 此处()为函数调用操作符，即使没有参数，也要有() 操作数：Add 3 4共3个
  printf(&quot;%d\n&quot;, ret);
  return 0;
}

</code></pre>
<p><img src="image/image_20.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535007948.png" alt="" loading="lazy"></p>
<h2 id="511-结构成员访问操作符">5.11 结构成员访问操作符</h2>
<pre><code class="language-C">. 
-&gt; 

// 使用格式：
结构体变量.结构体成员变量名
结构体指针变量-&gt;结构体成员变量名

</code></pre>
<ul>
<li>
<p>例</p>
<pre><code class="language-C">int main()
{
  struct Person
  {
    char name[10];
    int age;
    float height;
  };
  printf(&quot;.操作符\n&quot;);
  struct Person p = { &quot;listen&quot;, 22, 185.0 };
  printf(&quot;name: %s\n&quot;, p.name);
  printf(&quot;age: %d\n&quot;, p.age);
  printf(&quot;height: %f\n&quot;, p.height);

  struct Person* pp = &amp;p;
  printf(&quot;name: %s\n&quot;, (*pp).name);
  printf(&quot;age: %d\n&quot;, (*pp).age);
  printf(&quot;height: %f\n&quot;, (*pp).height);

  printf(&quot;-&gt;操作符\n&quot;);
  printf(&quot;name: %s\n&quot;, pp-&gt;name);
  printf(&quot;age: %d\n&quot;, pp-&gt;age);
  printf(&quot;height: %f\n&quot;, pp-&gt;height);
  return 0;
}

</code></pre>
<p><img src="image/image_21.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535016274.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="512-表达式求值">5.12 表达式求值</h2>
<blockquote>
<p>表达式求值的顺序一般是由操作符的优先级和结合性决定。同样，有些表达式的操作数再求值的过程中可能需要转换为其他类型。</p>
</blockquote>
<h4 id="5121-隐式类型转换">5.12.1 隐式类型转换</h4>
<blockquote>
<p>C的整形算数运算总是至少以缺省整形类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换称为整形提升。</p>
</blockquote>
<p>包括：</p>
<ul>
<li>整形提升</li>
<li>算数转换</li>
</ul>
<h4 id="5122-整型提升">5.12.2 整型提升</h4>
<ul>
<li>
<p>概念</p>
<blockquote>
<p>在表达式计算时，各种整形（只有比int小的类型才会发生整型提升）首先要提升为int类型，如果int类型不足以表示的话，就需要提升为unsigned int类型，然后再执行表达式的运算。</p>
</blockquote>
</li>
<li>
<p>意义</p>
<blockquote>
<p>虽然机器指令中可能有现两个8比特字节这种字节相加指令，但是一般用途的CPU是难以直接实现这样的字节相加运算的。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。而表达式的整型运算要在CPU的相应运算器件内执行。因此，两个char类型的数进行相加运算时，是在CPU中执行，自然而然的需要先转换为CPU内整型操作数的标准长度。</p>
</blockquote>
</li>
<li>
<p>如何提升</p>
<blockquote>
<p>按照最高位进行整型提升</p>
</blockquote>
<ul>
<li>正数整型提升：高位补0</li>
<li>负数整形提升：高位补1</li>
<li>无符号整数整形提升：高位补0</li>
</ul>
</li>
<li>
<p>例1</p>
<pre><code class="language-C">int main()
{
  char a = 3;
  char b = 127;
  char c = a + b;
  printf(&quot;%d\n&quot;, c)
  return 0;
}

// 原理
char a = 3; //二进制： 00000011
char b = 127; //二进制：01111111 
char c = a + b;
// + 操作符 整型提升
//a 提升： 00000000000000000000000000000011
//b 提升： 00000000000000000000000001111111
//  相加： 00000000000000000000000010000010
//c 截断： 10000010
printf(&quot;c=%d\n&quot;, c);
// c是char类型，而使用%d打印，c 整形提升(高位补1)
// 11111111111111111111111110000010 补码
// 11111111111111111111111110000001 反码（补码-1）
// 10000000000000000000000001111110 原码（反码符号位不变，其余位取反）

</code></pre>
<p><img src="image/image_22.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535031092.png" alt="" loading="lazy"></p>
</li>
<li>
<p>例2</p>
<pre><code class="language-C">int main()
{
  char a = 0xFF; // a整形提升之后为11111111111111111111111111111111
  short b = 0xFFFF; // b整形提升之后为11111111111111111111111111111111
  int c = 0xFFFFFFFF;
  if (a == 0xFF) {
    printf(&quot;a\n&quot;);
  }
  if (b == 0xFFFF) {
    printf(&quot;b\n&quot;);
  }
  if (c == 0xFFFFFFFF) {
    printf(&quot;c\n&quot;);
  }
  printf(&quot;%d\n&quot;, a == b);
  return 0;
}
// 其中a, b需要进行整形提升，而c不需要整形提升
// a, b整形提升之后变成了负数，所以a==0xFF和b == 0xFFFF为假
</code></pre>
<p><img src="image/image_23.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535038782.png" alt="" loading="lazy"></p>
</li>
<li>
<p>例3</p>
<pre><code class="language-C">int main()
{
  char a = 1;
  printf(&quot;%u\n&quot;, sizeof a);
  printf(&quot;%u\n&quot;, sizeof -a); // 类型提升为int类型
  printf(&quot;%u\n&quot;, sizeof +a);
  printf(&quot;%u\n&quot;, sizeof !a); // vs2022中为1 gcc中为4
  return 0;
}
</code></pre>
<p><img src="image/image_24.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535044887.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="5123-算数转换">5.12.3 算数转换</h4>
<blockquote>
<p>如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转化为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换。</p>
</blockquote>
<pre><code class="language-C">long double
double
float
unsigned long int
long int 
unsigned int 
int
</code></pre>
<blockquote>
<p>如果某个操作数的类型在上面这个列表中排名较低，那么首先要转化为另一个操作数的类型后执行运算。</p>
</blockquote>
<ul>
<li>
<p>例</p>
<pre><code class="language-C">int main()
{
  float a = 1.23;
  int b = 5;
  float c = 0;
  c = a + b; 
  // a为float类型，b为int类型，
  // float类型值和int类型值相加时，
  // int类型值被转换为float类型
  printf(&quot;%f\n&quot;, c);
  return 0;
}
</code></pre>
<p><img src="image/image_25.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535051661.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="513-表达式的属性">5.13 表达式的属性</h2>
<ul>
<li>值属性(运行后才能确定)</li>
<li>类型属性(可推断，编译时确定)</li>
</ul>
<h2 id="514-操作符的属性">5.14 操作符的属性</h2>
<ul>
<li>复杂表达式的求值有三个影响的因素：
<ul>
<li>操作符的优先级</li>
<li>操作符的结合性</li>
<li>是否控制求值顺序（例如<code>&amp;&amp;</code> <code>||</code> <code>,</code>）</li>
</ul>
</li>
</ul>
<h4 id="5141-优先级">5.14.1 优先级</h4>
<blockquote>
<p>运算符的优先级确定表达式中项的组合。如果优先级相同，则根据结合性确定计算顺序。</p>
</blockquote>
<table>
<thead>
<tr>
<th>类别</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>后缀</td>
<td>() [] -&gt; . ++ - -</td>
<td>从左到右</td>
</tr>
<tr>
<td>一元</td>
<td>+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td>从右到左</td>
</tr>
<tr>
<td>乘除</td>
<td>* / %</td>
<td>从左到右</td>
</tr>
<tr>
<td>加减</td>
<td>+ -</td>
<td>从左到右</td>
</tr>
<tr>
<td>移位</td>
<td>&lt;&lt; &gt;&gt;</td>
<td>从左到右</td>
</tr>
<tr>
<td>关系</td>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>从左到右</td>
</tr>
<tr>
<td>相等</td>
<td>== !=</td>
<td>从左到右</td>
</tr>
<tr>
<td>位与 AND</td>
<td>&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>位异或 XOR</td>
<td>^</td>
<td>从左到右</td>
</tr>
<tr>
<td>位或 OR</td>
<td></td>
<td></td>
</tr>
<tr>
<td>逻辑与 AND</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>逻辑或 OR</td>
<td></td>
<td></td>
</tr>
<tr>
<td>条件</td>
<td>?:</td>
<td>从右到左</td>
</tr>
<tr>
<td>赋值</td>
<td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^=</td>
<td>=</td>
</tr>
<tr>
<td>逗号</td>
<td>,</td>
<td>从左到右</td>
</tr>
</tbody>
</table>
<h4 id="5142-一些问题表达式">5.14.2 一些问题表达式</h4>
<ul>
<li>
<p>表达式1</p>
<pre><code class="language-C">a * b + c * d + e * f;
// 计算原理：
// 方法1：
a * b;
c * d;
e * f;
a * b + c * d + e * f
// 方法2：
a * b;
c * d;
a * b + c * d;
e * f;
a * b + c * d + e * f;

</code></pre>
</li>
<li>
<p>表达式2</p>
<pre><code class="language-C">c + --c;
// 无法确定左操作数是在--c之前还是--c之后确定
// 计算原理：
// 方法1：
--c;
c;
c + --c;

// 方法2：
c;
--c;
c + --c;
</code></pre>
</li>
<li>
<p>代码3-错误代码</p>
<pre><code class="language-C">int main()
{
  int i = 10;
  i = i-- - --i * (i = -3) * i++ + ++i;
  printf(&quot;i = %d\n&quot;, i);
  return 0;
}
// 输出结果在不同的编译器中结果不同
</code></pre>
</li>
<li>
<p>代码4- 错误代码</p>
<pre><code class="language-C">int fun()
{
  static int count = 1;
  return ++count;
}

int main()
{
  int answer;
  answer = fun() - fun() * fun(); // 2 - 3 * 4 (vs2022中)
  printf(&quot;%d\n&quot;, answer); // -10(vs2022中)
  return 0;
}
// 结果不可控，fun()函数的调用顺序不同，结果不同
</code></pre>
</li>
<li>
<p>代码5-错误代码</p>
<pre><code class="language-C">int main()
{
  int i = 1;
  int ret = (++i) + (++i) + (++i);
  printf(&quot;%d\n&quot;, ret);
}
// VS -&gt; 12
// 执行原理
++i;
++i;
++i;
i = 4
4 + 4 + 4;

// gcc -&gt; 10
++i;
++i;
i = 3;
3 + 3;
++i;
i = 4;
3 + 3 + 4;

</code></pre>
<p><img src="image/image_26.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643535067711.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="5143-总结">5.14.3 总结</h4>
<blockquote>
<p>对于同一个表达式或一段代码，即使有确定的优先级和结合性，仍然有不确定的计算或运行方式，且不同方式计算出来的结果不同，则该表达式或代码是存在问题的，不应该使用这样的表达式和代码。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4. C语言--数组]]></title>
        <id>https://listen2022.github.io/4-shu-zu/</id>
        <link href="https://listen2022.github.io/4-shu-zu/">
        </link>
        <updated>2022-01-30T09:22:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="4数组">4.数组</h1>
<blockquote>
<p>数组是一组相同类型元素的集合。</p>
</blockquote>
<h2 id="41-一维数组的创建和初始化">4.1 一维数组的创建和初始化</h2>
<h4 id="411-创建">4.1.1 创建</h4>
<pre><code class="language-C">// 格式：
type_t arr_name [const_n]
// type_t 数组元素类型
// arr_name 数组名称
// const_n 常量表达式，指定数组大小
// 在VS2019、VS2022中不支持变长数组
// 在gcc编译器中支持
</code></pre>
<p><img src="image/image.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534597972.png" alt="" loading="lazy"></p>
<pre><code class="language-C">// 创建
int arr[10];

</code></pre>
<h4 id="412-初始化">4.1.2 初始化</h4>
<pre><code class="language-C">int main()
{  
  int arr1[3] = {0, 1, 2}; // 完全初始化
  int arr2[3] = {1, 2};  // 不完全初始化
  int arr3[] = { 2, 4, 6, 8 }; // 自动确定数组长度
  int arr4[5] = { 2, 4, 6, 8 }; // 与上一条语句等价
  int arr5[10] = { 0 } // 不完全初始化，不是把10个元素全初始化为0
  int arr6[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
  
  char ch1[5] = &quot;ccc&quot;; // 'c' 'c' 'c' '\0' 0
  char ch2[] = &quot;ccc&quot;; // 'c' 'c' 'c' '\0'
  char ch3[] = { 'c', 'c', 'c' }; // 'c' 'c' 'c'
  printf(&quot;%s\n&quot;, ch1);
  printf(&quot;%s\n&quot;, ch2);
  printf(&quot;%s\n&quot;, ch3);
  return 0;
}
</code></pre>
<p><img src="image/image_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534608109.png" alt="" loading="lazy"></p>
<h2 id="42-一维数组的使用">4.2 一维数组的使用</h2>
<h4 id="421-获取">4.2.1 获取</h4>
<pre><code class="language-C">[] // 下标引用操作符
int arr[5] = { 1, 2, 3, 4, 5 };
arr[3]; // 获取数组arr中下标为3的元素的值

</code></pre>
<h4 id="422-赋值">4.2.2 赋值</h4>
<pre><code class="language-C">arr[3] = 444;
</code></pre>
<h4 id="423-数组中元素的个数">4.2.3 数组中元素的个数</h4>
<pre><code class="language-C">int main()
{
  int arr[5] = { 1, 2, 3, 4, 5 };
  int size = sizeof(arr) / sizeof(arr[0]); // 获取数组中元素的个数
  // sizeof(arr)获取的是整个数组的大小，单位是字节
  printf(&quot;%d\n&quot;, size);
}
</code></pre>
<p><img src="image/image_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534617554.png" alt="" loading="lazy"></p>
<h2 id="43-一维数组在内存中的存储">4.3 一维数组在内存中的存储</h2>
<h4 id="431-x和p的区别">4.3.1 %x和%p的区别</h4>
<pre><code class="language-C">int main()
{
  printf(&quot;%x\n&quot;, 0x5f);
  printf(&quot;%p\n&quot;, 0x5f);
  return 0;
}
// 指针是有长度的
</code></pre>
<p><img src="image/image_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534626062.png" alt="" loading="lazy"></p>
<h4 id="432-存储方式">4.3.2 存储方式</h4>
<pre><code class="language-C">int main()
{
  int arr[5] = { 1, 2, 3, 4, 5 };
  for (int i = 0; i &lt; 5; i++)
  {
    printf(&quot;&amp;arr[%d] =&gt; %p\n&quot;, i, &amp;arr[i]);
  }
}
</code></pre>
<p><img src="image/image_4.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534634959.png" alt="" loading="lazy"></p>
<pre><code class="language-C">// 现象：下标每增加1，地址变化4字节，刚好是int类型的大小
// 结论：
//     一维数组在内存中是连续存放的
//     随着数组下标的增长，地址是由低到高变化
</code></pre>
<h4 id="433-应用">4.3.3 应用</h4>
<pre><code class="language-C">// 对于int指针，p++，每次增加int类型的字节数(4byte)
// 对于char指针，p++，每次增加char类型的字节数(1byte)
</code></pre>
<p><img src="image/image_5.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534641494.png" alt="" loading="lazy"></p>
<h2 id="44-二维数组的创建和初始化">4.4 二维数组的创建和初始化</h2>
<pre><code class="language-C">int main()
{
  // 创建
  int arr[3][4]; // 三行四列
  char ch[3][4];
  double dou[3][4];

  // 初始化
  int arr1[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; // 完全初始化
  int arr2[3][4] = { {1, 2},{3, 4},{5, 6} }; // 每行初始化
  int arr3[][4] = { {1, 2},{3, 4},{5, 6} }; // 省略行(但不能省略列)
  int ch[3][4] = {'h','e','l','l','o'}; // 不完全初始化
  return 0;
}
</code></pre>
<h2 id="45-二维数组的使用">4.5 二维数组的使用</h2>
<pre><code class="language-C">int main()
{
  int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
  for (int i = 0; i &lt; 3; i++)
  {
    for ( int j=0; j&lt;4; j++)
    {
      printf(&quot;%d &quot;, arr[i][j]);
    }
    printf(&quot;\n&quot;);
  }
  return 0;
}
</code></pre>
<p><img src="image/image_6.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534647409.png" alt="" loading="lazy"></p>
<h2 id="46-二维数组在内存中的存储">4.6 二维数组在内存中的存储</h2>
<pre><code class="language-C">int main()
{
  int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
  for (int i = 0; i &lt; 3; i++)
  {
    for (int j = 0; j &lt; 4; j++)
    {
      printf(&quot;arr[%d][%d]=%p\n&quot;, i, j, &amp;arr[i][j]);
    }
  }
  return 0;
}

</code></pre>
<p><img src="image/image_7.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534653677.png" alt="" loading="lazy"></p>
<pre><code class="language-C">// 现象：每个元素相差4byte，恰好是int类型的大小
// 二维数组在内存中连续存放
</code></pre>
<h2 id="47-数组作为函数参数">4.7 数组作为函数参数</h2>
<h4 id="471-数组名">4.7.1 数组名</h4>
<blockquote>
<p>数组名是数组首元素的地址。</p>
</blockquote>
<ul>
<li>例外
<ul>
<li>sizeof(arr)获取的是整个数组的长度，单位：byte。</li>
<li>&amp;arr获取的是整个数组的地址。</li>
</ul>
</li>
</ul>
<pre><code class="language-C">int main()
{
  int arr[5] = { 0 };
  printf(&quot;arr =&gt; %p\n&quot;, arr);
  printf(&quot;arr =&gt; %p\n&quot;, arr+1);
  printf(&quot;&amp;arr =&gt; %p\n&quot;, &amp;arr);
  printf(&quot;&amp;arr =&gt; %p\n&quot;, &amp;arr+1);
  printf(&quot;&amp;arr[0] =&gt; %p\n&quot;, &amp;arr[0]);
  printf(&quot;&amp;arr[0] =&gt; %p\n&quot;, &amp;arr[0]+1);
  return 0;
}
</code></pre>
<p><img src="image/image_8.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534661346.png" alt="" loading="lazy"></p>
<h4 id="472-冒泡排序">4.7.2 冒泡排序</h4>
<pre><code class="language-C">// 两两相邻元素进行比较
void bubble_sort(int arr[], int count) // 形参arr本质是指针
{
  int i = 0; // 确定趟数
  for ( i = 0; i &lt; count; i++)
  {
    int j = 0; // 每趟比较元素的次数
    for ( j = 0; j &lt; count-1-i; j++)
    {
      if (arr[j] &gt; arr[j + 1])
      {
        int tmp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tmp;
      }
    }
  }
}


int main()
{
  int arr[] = { 1, 6, 3, 9, 4 };
  int count = sizeof(arr) / sizeof(arr[0]); // 确定数组元素个数
  bubble_sort(arr, count); // 数组在传参时，传递的时arr首元素的地址
  for (int i = 0; i &lt; count; i++) // 打印排序结果
  {
    printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);
  }
  return 0;
}

</code></pre>
<p><img src="image/image_9.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534668445.png" alt="" loading="lazy"></p>
<h2 id="48-练习">4.8 练习</h2>
<h4 id="481-逆序数组中元素个数">4.8.1 逆序数组中元素个数</h4>
<pre><code class="language-C">void reverse(int arr[], int size)
{
  int left = 0;
  int right = size-1;
  while (left&lt;right)
  {
    int tmp = 0;
    tmp = arr[right];
    arr[right] = arr[left];
    arr[left] = tmp;
    left++;
    right--;
  }
}

int main()
{
  int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
  int size = sizeof(arr) / sizeof(arr[0]);
  reverse(arr, size);
  return 0;
}
</code></pre>
<p><img src="image/image_10.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534675078.png" alt="" loading="lazy"></p>
<h4 id="482-交换数组">4.8.2 交换数组</h4>
<blockquote>
<p>将数组A中的内容和数组B中的内容进行交换（数组一样大）</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int arr1[3] = { 1, 2, 3 };
  int arr2[3] = { 4, 5, 6 };
  // 错误操作：
  //int arr3[3] = { 0 };
  //arr3 = arr2;
  //arr2 = arr1;
  //arr1 = arr2;
  // 元素可以相互赋值，但数组名不可以相互赋值，因为数组名是数组首元素的地址
  // 
  // 正确操作：
  int size = sizeof(arr1) / sizeof(arr1[0]);
  for (int i = 0; i &lt; size; i++)
  {
    int tmp = 0;
    tmp = arr1[i];
    arr1[i] = arr2[i];
    arr2[i] = tmp;
  }
  return 0;
}
</code></pre>
<p><img src="image/image_11.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534681163.png" alt="" loading="lazy"></p>
<h2 id="49-实例">4.9 实例</h2>
<h4 id="491-三子棋">4.9.1 三子棋</h4>
<pre><code class="language-C">
</code></pre>
<h4 id="492-扫雷">4.9.2 扫雷</h4>
<pre><code class="language-C"> 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3. C语言--函数]]></title>
        <id>https://listen2022.github.io/3-han-shu/</id>
        <link href="https://listen2022.github.io/3-han-shu/">
        </link>
        <updated>2022-01-30T09:20:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="3函数">3.函数</h1>
<h2 id="31-函数是什么">3.1 函数是什么</h2>
<blockquote>
<p>函数是指一段可以直接被另一段程序或代码引用的程序或代码。也叫做子程序、（OOP中）方法。一个较大的程序一般应分为若干个程序块，每一个模块用来实现一个特定的功能。所有的高级语言中都有子程序这个概念，用子程序实现模块的功能。在C语言中，子程序是由一个主函数和若干个函数构成的。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。</p>
</blockquote>
<h4 id="311-函数分类">3.1.1 函数分类</h4>
<ul>
<li>自定义函数</li>
<li>库函数</li>
</ul>
<h2 id="32-库函数">3.2 库函数</h2>
<blockquote>
<p>一般是指编译器提供的可在C源程序中调用的函数。分为两类，C语言标准规定的库函数和编译器特定的库函数。</p>
</blockquote>
<h4 id="321-网站">3.2.1 网站</h4>
<p><a href="https://www.cprogramming.com/">Learn C and C++ Programming - Cprogramming.com</a></p>
<p><a href="https://zh.cppreference.com/w/c/header">C 标准库头文件 - cppreference.com</a></p>
<p><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/c-run-time-library-reference?view=msvc-170">https://docs.microsoft.com/en-us/cpp/c-runtime-library/c-run-time-library-reference?view=msvc-170</a></p>
<h4 id="322-strcp">3.2.2 <a href="https://www.runoob.com/cprogramming/c-function-strcpy.html">strcp</a></h4>
<h4 id="323-memset">3.2.3 <a href="https://www.runoob.com/cprogramming/c-function-memset.html">memset</a></h4>
<h2 id="33-自定义函数">3.3 自定义函数</h2>
<pre><code class="language-C">// 格式：
ret_type func_name( parameter list )
{
   body of the function
}
// return_type 函数的返回类型
// function_name 函数名称
// parameter list 参数列表
// body of the function 函数体
// 当函数不返回任何类型，ret_type为关键字void
</code></pre>
<ul>
<li>
<p>实例</p>
<pre><code class="language-C">void Swap(int* pa, int* pb)
{
  int z = 0;
  z = *pa;
  *pa = *pb;
  *pb = z;
}

int main() 
{
  int a = 10;
  int b = 20;
  printf(&quot;交换前 a=%d, b=%d\n&quot;, a, b);
  Swap(&amp;a, &amp;b);
  printf(&quot;交换后 a=%d, b=%d\n&quot;, a, b);
}
</code></pre>
<p><img src="image/image.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534473083.png" alt="" loading="lazy"></p>
</li>
<li>
<p>重点</p>
<pre><code class="language-C">void Swap(int* pa, int* pb)
{
  int* z = NULL;
  printf(&quot;%p %p %p\n&quot;, pa, pb, z);
  z = pa;
  pa = pb;
  pb = z;
  printf(&quot;%p %p %p\n&quot;, pa, pb, z);
}

// 不能通过交换a、b的地址交换a、b的数据

int main() 
{
  int a = 10;
  int b = 20;
  printf(&quot;交换前 a=%d, b=%d\n&quot;, a, b);
  Swap(&amp;a, &amp;b);
  printf(&quot;交换后 a=%d, b=%d\n&quot;, a, b);
}

</code></pre>
<p><img src="image/image_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534479607.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="34-函数参数">3.4 函数参数</h2>
<h4 id="341-实际参数argument">3.4.1 实际参数(argument)</h4>
<blockquote>
<p>真实传递给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在进行调用时，它们都必须有确定的值，以便把这些值传送给形参。</p>
</blockquote>
<h4 id="342-形式参数parameter">3.4.2 形式参数(parameter)</h4>
<blockquote>
<p>形式参数是指函数名后括号中的变量，因为形参只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成后就自动销毁。因此形式参数只在函数中有效。</p>
</blockquote>
<h4 id="343-形参实例化之后其实相当于实参的一份临时拷贝">3.4.3 形参实例化之后其实相当于实参的一份临时拷贝。</h4>
<h2 id="35-函数调用">3.5 函数调用</h2>
<h4 id="351-传值调用">3.5.1 传值调用</h4>
<blockquote>
<p>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</p>
</blockquote>
<h4 id="352-引用调用">3.5.2 引用调用</h4>
<blockquote>
<p>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p>
</blockquote>
<h2 id="36-函数的嵌套调用和链式访问">3.6 函数的嵌套调用和链式访问</h2>
<h4 id="361-嵌套调用">3.6.1 嵌套调用</h4>
<blockquote>
<p>在函数A()中调用函数B()</p>
</blockquote>
<pre><code class="language-C">#include &lt;stdio.h&gt;
int main() {
  printf(&quot;Hello World!\n&quot;);
  return 0;
}

// 最简单的嵌套调用，在main函数中调用prinf函数
</code></pre>
<p><img src="image/image_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534488639.png" alt="" loading="lazy"></p>
<h4 id="362-链式访问">3.6.2 链式访问</h4>
<blockquote>
<p>把一个函数的返回值作为另一个函数的参数。</p>
</blockquote>
<pre><code class="language-C">#include &lt;stdio.h&gt;
int add(int x, int y)
{
  return x + y;
}

int main() 
{
  printf(&quot;输出：%d\n&quot;, add(3, 4));
}


// 将add(3, 4)的返回值作为参数，传递给printf函数
</code></pre>
<p><img src="image/image_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534494500.png" alt="" loading="lazy"></p>
<h2 id="37-函数的声明和定义">3.7 函数的声明和定义</h2>
<h4 id="371-声明">3.7.1 声明</h4>
<blockquote>
<p>告诉编译器函数名称及如何调用函数。</p>
</blockquote>
<pre><code class="language-C">return_type function_name( parameter list );
// 在函数声明中
// 参数的名称并不重要
// 只有参数的类型是必需的
// 因此可省略声明中形参的名称
</code></pre>
<h4 id="372-定义">3.7.2 定义</h4>
<pre><code class="language-C">return_type function_name( parameter list )
{
   body of the function
}
</code></pre>
<h2 id="38-函数递归">3.8 函数递归</h2>
<blockquote>
<p>函数对自身的调用。</p>
</blockquote>
<ul>
<li>递归的必要条件
<ul>
<li>递归调用的过程</li>
<li>递归终止的条件</li>
</ul>
</li>
</ul>
<h2 id="39-小知识">3.9 小知识</h2>
<blockquote>
<p>#include &quot; &quot; 与 &lt;&gt;有什么区别？</p>
</blockquote>
<pre><code class="language-C"> // 若 #include &quot;&quot; 查找成功，则遮蔽 #include &lt;&gt; 所能找到的同名文件
 // 否则再按照 #include &lt;&gt; 的方式查找文件
 
 // #include &lt;&gt; 的查找位置是标准库头文件所在目录
 // #include &quot;&quot; 的查找位置是当前源文件所在目录
 
 // &lt;&gt;先去系统目录中找头文件，如果没有在到当前目录下找
 // &quot;&quot;首先在当前目录下寻找，如果找不到，再到系统目录中寻找
</code></pre>
<blockquote>
<p>C语言函数默认返回类型</p>
</blockquote>
<pre><code class="language-C">// C语言中函数如果没有定义返回值类型，则默认返回类型是int

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2. C语言--分支和循环语句]]></title>
        <id>https://listen2022.github.io/2fen-zhi-he-xun-huan-yu-ju/</id>
        <link href="https://listen2022.github.io/2fen-zhi-he-xun-huan-yu-ju/">
        </link>
        <updated>2022-01-30T09:15:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="2分支和循环语句">2.分支和循环语句</h1>
<h2 id="21-分支语句">2.1 分支语句</h2>
<blockquote>
<p>C语言把任何非零和非空的值假定为 true，把零或 null 假定为 false</p>
</blockquote>
<h4 id="211-if-else">2.1.1 if else</h4>
<ul>
<li>
<p>if语句</p>
<pre><code class="language-C">if(boolean_expression)
{
   /* 如果布尔表达式为真将执行的语句 */
}
</code></pre>
</li>
<li>
<p>if...else...</p>
<pre><code class="language-C">if(boolean_expression)
{
   /* 如果布尔表达式为真将执行的语句 */
}
else
{
   /* 如果布尔表达式为假将执行的语句 */
}
</code></pre>
</li>
<li>
<p>if...else if...else...</p>
<ul>
<li>一个if后可跟一个或零个else语句，else必须在所有else if之后</li>
<li>一个if后可跟多个或零个else if语句，else if必须在else之前</li>
<li>一旦某个else if匹配成功，其他的else if或else将不会被测试</li>
</ul>
<pre><code class="language-C">if(boolean_expression1)
{
   /* 当布尔表达式1为真时执行 */
}
else if(boolean_expression2)
{
   /* 当布尔表达式2为真时执行 */
}
else if(boolean_expression3)
{
   /*当布尔表达式3为真时执行*/
}
else 
{
   /* 当上面条件都不为真时执行 */
}
</code></pre>
</li>
<li>
<p>嵌套if语句</p>
<pre><code class="language-C">if( boolean_expression1)
{
   /* 当布尔表达式1为真时执行 */
   if(boolean_expression2)
   {
      /* 当布尔表达式2为真时执行 */
   }
}
// 可以在一个if...else...或if...else if...else..语句中
// 嵌套一个if...else...或if...else if...else..语句
</code></pre>
</li>
</ul>
<h4 id="212-switch">2.1.2 switch</h4>
<ul>
<li>
<p>switch</p>
<pre><code class="language-C">switch(expression){
    case constant-expression  :
       statement(s);
       break; /* 可选 */
    case constant-expression  :
       statement(s);
       break; /* 可选 */
    default : /* 可选 */
       statement(s);
}
</code></pre>
<ul>
<li>expression为常量表达式，必须是一个整形或枚举类型</li>
<li>constant-expression必须和expression的数据类型相同，且为一个常量或字面量</li>
<li>当被测试的变量等于case中的常量时，case后面的语句执行，直到遇到break语句</li>
<li>default case中的break语句不是必须的</li>
<li>default语句可以放在任意位置</li>
</ul>
</li>
<li>
<p>嵌套switch</p>
<blockquote>
<p>一个switch语句种包含另一个switch语句</p>
</blockquote>
<pre><code class="language-C">switch(expression1) {
    case constant-expression: 
        switch(expression2) {
            case constant-expression:
                ...
                break;
            case constant-expression:
                ...
        }
        break;
    case constant-expression: 
        ...
}
</code></pre>
</li>
</ul>
<h4 id="213-运算符三目运算符">2.1.3 :?运算符(三目运算符)</h4>
<pre><code class="language-C">Exp1 ? Exp2 : Exp3;
// ? 表达式的值是由 Exp1 决定的。
// 如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值
// 如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值
</code></pre>
<h2 id="22-循环语句">2.2 循环语句</h2>
<h4 id="221-for">2.2.1 for</h4>
<pre><code class="language-C">for ( init; condition; increment )
{
   statement(s);
}
// init: 首先执行，声明并初始化循环控制变量，可留空
// condition: 判断，如果为真，执行statement(s)，否则结束循环
// increment: 执行完for循环主体statement(s);之后，执行increment语句。该语句一般是更新循环控制变量，可留空
</code></pre>
<h4 id="222-while">2.2.2 while</h4>
<pre><code class="language-C">while(condition)
{
   statement(s); // 一条语句或语句块
}

</code></pre>
<h4 id="223-do-while">2.2.3 do while</h4>
<blockquote>
<p>for和while循环在循环开始时测试循环条件，而do...while...在每次循环中执行statement(s)语句之后，测试循环条件。</p>
</blockquote>
<pre><code class="language-C">do
{
   statement(s);
}while( condition )
// statement(s);至少被执行一次
</code></pre>
<h4 id="224-嵌套循环">2.2.4 嵌套循环</h4>
<ul>
<li>
<p>嵌套for循环</p>
<pre><code class="language-C">for (initialization; condition; increment/decrement)
{
    statement(s);
    for (initialization; condition; increment/decrement)
    {
        statement(s);
    }
}
</code></pre>
</li>
<li>
<p>嵌套while循环</p>
<pre><code class="language-C">while (condition1)
{
    statement(s);
    while (condition2)
    {
        statement(s);
    }
}
</code></pre>
</li>
<li>
<p>嵌套 do while 循环</p>
<pre><code class="language-C">do
{
    statement(s);
    do
    {
        statement(s);
    }while (condition2);
}while (condition1)
</code></pre>
</li>
<li>
<p>混合嵌套</p>
</li>
</ul>
<h2 id="23-循环控制语句">2.3 循环控制语句</h2>
<h4 id="231-break">2.3.1 break</h4>
<blockquote>
<p>终止循环或switch语句。在嵌套语句中，终止break所在的最内层的循环或switch语句。</p>
</blockquote>
<h4 id="232-continue">2.3.2 continue</h4>
<blockquote>
<p>结束本次循环，进行下一次迭代。</p>
</blockquote>
<h4 id="233-goto">2.3.3 goto</h4>
<blockquote>
<p>控制转移到被标记的语句。但是不建议在程序中使用goto语句（使得程序的控制流难以跟踪，使程序难以理解和难以修改）。</p>
</blockquote>
<pre><code class="language-C">goto label;
...
...
label: statement;

// goto语句只能在一个函数范围内跳转，不能跨函数
// 一般不使用，跳出多层嵌套时使用
</code></pre>
<h2 id="24-无限循环">2.4 无限循环</h2>
<pre><code class="language-C">for( ; ; )
    {
        ...
    }
// 倾向于使用该语句实现无限循环
</code></pre>
<h2 id="23-习题">2.3 习题</h2>
<h4 id="231-最大公约数">2.3.1 最大公约数</h4>
<blockquote>
<p>最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。</p>
</blockquote>
<ul>
<li>
<p>一般方法</p>
<pre><code class="language-C">int main()
{  
  int a = 12;
  int b = 16;
  int max = a; // 为a、b中较小的一个赋值给最大公约数
  if (max &gt; b)
  {
    max = b;
  }
  for (; max &gt;= 1 ; max--)
  {  
    if (a % max == 0 &amp;&amp; b % max == 0)
    {
      printf(&quot;%d\n&quot;, max);
      break;
    }
  }
  return 0;
}
</code></pre>
<p><img src="image/image.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534297610.png" alt="" loading="lazy"></p>
</li>
<li>
<p>辗转相除法</p>
<blockquote>
<p>欧几里得算法：gcd(a, b) = gcd(b, a mod b)</p>
</blockquote>
<pre><code class="language-C">int main()
{  
  int a = 12;
  int b = 16;
  int t = 0;
  while (t = a % b)
  {
    a = b;
    b = t;
  }
  printf(&quot;%d&quot;, b);
  return 0;
}
</code></pre>
<p><img src="image/image_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534307968.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="232-最小公倍数">2.3.2 最小公倍数</h4>
<blockquote>
<p>两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。</p>
</blockquote>
<ul>
<li>
<p>一般方法</p>
<pre><code class="language-C">int main()
{
  int a = 12;
  int b = 16;
  int min = a; // 存放a、b中较大值
  if (min&lt;b)
  {
    min = b;
  }
  for ( ; ; min++)
  {
    if (min % a == 0 &amp;&amp; min % b == 0)
    {
      printf(&quot;%d&quot;, min);
      break;
    }
  }
  return 0;
}

</code></pre>
<p><img src="image/image_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534319776.png" alt="" loading="lazy"></p>
</li>
<li>
<p>公式法</p>
<blockquote>
<p>最小公倍数 × 最大公约数 = a × b</p>
</blockquote>
<pre><code class="language-C">int main()
{  
  int a = 12;
  int b = 16;
  int mul = a * b; // a和b的乘积
  int t = 0;
  while (t = a % b)
  {
    a = b;
    b = t;
  }
  printf(&quot;%d&quot;, mul / b);
  return 0;
}

</code></pre>
<p><img src="image/image_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534326084.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="233-排序">2.3.3 排序</h4>
<blockquote>
<p>问题描述：给定三个数，从大到小输出</p>
</blockquote>
<pre><code class="language-C">int main()
{
  int a = 3;
  int b = 8;
  int c = 5;
  if (a &lt; b)
  {
    int t = a;
    a = b;
    b = t;
  }  
  if (a &lt; c)
  {
    int t = a;
    a = c;
    c = t;
  }  
  if (b &lt; c)
  {
    int t = b;
    b = c;
    c = t;
  }
  printf(&quot;%d %d %d&quot;, a, b, c);
  return 0;
}
</code></pre>
<p><img src="image/image_4.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534332990.png" alt="" loading="lazy"></p>
<h4 id="234-闰年">2.3.4 闰年</h4>
<blockquote>
<p>闰年（Leap Year）是为了弥补因人为历法规定造成的年度天数与地球实际公转周期的时间差而设立的。补上时间差的年份为闰年。闰年共有366天（1月~12月分别为31天、29天、31天、30天、31天、30天、31天、31天、30天、31天、30天、31天）。</p>
</blockquote>
<ul>
<li>
<p>规则：四年一闰，百年不闰，四百年再闰。</p>
</li>
<li>
<p>方法一：</p>
<pre><code class="language-C">int main()
{
  int sum = 0;
  for (int i = 0; i &lt;= 2050; i++)
  {
    if ( 0 == i % 4)
    {
      if (0 == i % 100)
      {
        if (0 == i % 400)
        {
          printf(&quot;%d\n&quot;, i);
        }
      }
      else
      {
        printf(&quot;%d\n&quot;, i);
      }
    }
  }
  return 0;
}
</code></pre>
<p><img src="image/image_5.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534340145.png" alt="" loading="lazy"></p>
</li>
<li>
<p>方法二：</p>
<pre><code class="language-C">int main() {
  int sum = 0;
  for (int i = 0; i &lt;= 2050; i++)
  {
    if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || (i % 400 == 0 ))
    { 
      printf(&quot;%d是闰年\n&quot;, i);
      sum++;
    }
  }
  printf(&quot;sum = %d\n&quot;, sum);
}

</code></pre>
<p><img src="image/image_6.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534347242.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="235-素数质数">2.3.5 素数(质数)</h4>
<blockquote>
<p>在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
</blockquote>
<pre><code class="language-C">int main()
{
  for (int i = 2; i &lt;= 100; i++)
  {
    int j = i - 1;
    for ( ; j&gt;=1; j-- )
    {
      if (0 == i % j)
      {
        break;
      }
    }
    if (j == 1)
    {
      printf(&quot;%d\n&quot;, i);
    }
  }
}

</code></pre>
<p><img src="image/image_7.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534353474.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>优化：</p>
<pre><code class="language-C">int main()
{
  for (int i = 2; i &lt;= 100; i++)
  {
    int flag = 1; // flag=1时为素数
    int j = 2;
    for ( ; j*j &lt;= i ; j++)
    {
      if (0 == i % j)
      {
        flag = 0; // flag为0时不为素数
        break;
      }
    }
    if (flag)
    {
      printf(&quot;%d\n&quot;, i);
    }
  }
}
</code></pre>
<p><img src="image/image_8.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534359942.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="236-goto使用">2.3.6 goto使用</h4>
<pre><code class="language-PowerShell"># Windows关机命令
shutdown -s -t 60      # 设置关机 
shutdown -a            # 取消关机
</code></pre>
<pre><code class="language-C">// C语言中使用system(&quot;&quot;)执行系统命令
// system()函数在&lt;stdlib.h&gt;头文件中

// C语言中两个字符串不能使用`==`比较大小
// 可使用strcmp(str1, str2)函数
// 字符串相等函数返回0，该函数在&lt;string.h&gt;头文件中
</code></pre>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main() 
{
  char input[20] = { 0 };
  Lable:
  system(&quot;shutdown -s -t 60&quot;);
  printf(&quot;电脑将在1min之后关机，请输入密码进行取消：&quot;);
  scanf(&quot;%s&quot;, input);
  if (0 == strcmp(input, &quot;123&quot;))
  {
    system(&quot;shutdown -a&quot;);
  }
  else {
    goto Lable;
  }
  return 0;
}

</code></pre>
<ul>
<li>小问题</li>
</ul>
<p><img src="image/image_9.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643534369082.png" alt="" loading="lazy"></p>
<pre><code class="language-C">#define _CRT_SECURE_NO_WARNINGS // 源文件第一行（忽略VS的安全检测）
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1. C语言--初始C语言]]></title>
        <id>https://listen2022.github.io/1chu-shi-c-yu-yan/</id>
        <link href="https://listen2022.github.io/1chu-shi-c-yu-yan/">
        </link>
        <updated>2022-01-30T06:15:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-初始c语言">1. 初始C语言</h1>
<h2 id="11-介绍">1.1 介绍</h2>
<blockquote>
<p>广泛应用于底层开发（如：驱动）。有完整的美国国家标准语法，称为ANDI C。C语言是一门面向过程的的计算机语言。主要的编译器有Clang、GCC、WIN-TC、Turbo C等。</p>
</blockquote>
<blockquote>
<p>国际标准：C89、C90、C99、C11（C90之后的标准没有火起来）</p>
</blockquote>
<h2 id="12-第一个c程序">1.2 第一个C程序</h2>
<h4 id="121-编译器">1.2.1 编译器</h4>
<blockquote>
<p>Visual Studio、Dev C++、Visual C++ 6.0、GCC、Clang、Pelles C、Watcom C/C++、Tiny C Compiler、Code::Blocks、Turbo C、C-Free等</p>
</blockquote>
<h4 id="122-继承开发环境ide">1.2.2 继承开发环境（IDE）</h4>
<blockquote>
<p>VS2013/VS2019：集成开发环境，集成了windows下的C语言编译器</p>
</blockquote>
<h4 id="123-文件">1.2.3 文件</h4>
<ul>
<li>xxx.c 源文件</li>
<li>xxx.h 头文件</li>
</ul>
<h4 id="124-步骤">1.2.4 步骤</h4>
<ul>
<li>
<p>创建项目<br>
<img src="image/image.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525335573.png" alt="" loading="lazy"></p>
</li>
<li>
<p>创建源文件<br>
<img src="image/image_1.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525353924.png" alt="" loading="lazy"><br>
<img src="image/image_2.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525361628.png" alt="" loading="lazy"><br>
<img src="image/image_3.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525367497.png" alt="" loading="lazy"><br>
<img src="image/image_4.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525373449.png" alt="" loading="lazy"></p>
</li>
<li>
<p>编写代码</p>
<ul>
<li>主函数（main函数）</li>
</ul>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int main()
{
  printf(&quot;Hello World!&quot;);
  return 0;
}
</code></pre>
<p><img src="image/image_5.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525403966.png" alt="" loading="lazy"></p>
</li>
<li>
<p>编译、链接、运行代码<br>
<img src="image/image_6.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525411791.png" alt="" loading="lazy"><br>
<img src="image/image_7.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525417572.png" alt="" loading="lazy"></p>
</li>
</ul>
<h4 id="125-补充">1.2.5 补充</h4>
<ul>
<li>一个项目中可以有多个.c文件</li>
<li>多个.c文件中有且仅有一个main函数</li>
</ul>
<h2 id="13-基本数据类型">1.3 基本数据类型</h2>
<blockquote>
<p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p>
</blockquote>
<h4 id="131-整数类型">1.3.1 整数类型</h4>
<pre><code class="language-C">short (int)
int
long (int)
long long (int)
// 不同数据类型的大小因不同的计算机系统而异
// 编译器可以决定数据类型的大小但必须保证：short &lt;= int &lt;= long &lt;= long long
</code></pre>
<h4 id="132-浮点类型">1.3.2 浮点类型</h4>
<pre><code class="language-C">float // 单精度浮点型
double // 双精度浮点型
</code></pre>
<h4 id="133-字符型">1.3.3 字符型</h4>
<pre><code class="language-C">char // 可以当作整数类型处理
</code></pre>
<p><img src="image/image_8.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525426958.png" alt="" loading="lazy"></p>
<h4 id="134-sizeof运算符">1.3.4 sizeof运算符</h4>
<pre><code class="language-C">// sizeof(type) 得到对象或类型的存储字节大小
// 使用sizeof查看数据类型大小
int main()
{
  printf(&quot;size of short %d\n&quot;, sizeof(short));
  printf(&quot;size of short %d\n&quot;, sizeof(int));
  printf(&quot;size of short %d\n&quot;, sizeof(long));
  printf(&quot;size of short %d\n&quot;, sizeof(long long));
  printf(&quot;size of short %d\n&quot;, sizeof(float));
  printf(&quot;size of short %d\n&quot;, sizeof(double));
  return 0;
}

</code></pre>
<p><img src="image/image_9.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525434925.png" alt="" loading="lazy"></p>
<h2 id="14-常量变量">1.4 常量变量</h2>
<h4 id="141-变量">1.4.1 变量</h4>
<blockquote>
<p>程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
</blockquote>
<ul>
<li>
<p>变量定义<br>
告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表。</p>
<pre><code class="language-C">type var_list;
// type为C数据类型或自定义的对象
// var_list由一个或多个标识符组成，多个标识符之间使用逗号隔开
// eg:
int a, b;
char c;

// 初始化：变量可以在声明时初始化（指定一个初始值）
// eg:
int a = 666;
int x = 3, y = 4;
</code></pre>
</li>
<li>
<p>变量声明<br>
向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<pre><code class="language-C">变量声明的两种情况：
  1.需要建立存储空间。int a; 在声明时建立了存储空间
  2.不需要建立存储空间。extern关键字声明变量而不定义 extern int a 其中变量a可以在其他c文件中定义
    除非有extern关键字，其余都是变量的定义

</code></pre>
</li>
<li>
<p>左值和右值</p>
<ul>
<li>左值（lvalue）：指向内存位置的表达式。左值可以出现在赋值号的左边或右边。变量时左值。</li>
<li>右值（rvalue）：存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。数值型字面量是右值。</li>
</ul>
</li>
</ul>
<h4 id="142-常量">1.4.2 常量</h4>
<blockquote>
<p>固定值。程序执行期间不会改变。又称为字面量。</p>
</blockquote>
<ul>
<li>可以是任何数据类型。比如：整数常量、浮点常量、字符常量、字符串字面值、枚举常量。</li>
<li>可认为是常规的变量，只不过在定义后不能修改。</li>
<li>转义字符：特定字符前有反斜杠，具有特殊含义。</li>
</ul>
<pre><code class="language-C">/*
常量定义的方式：
  1. #define预处理器
     格式：#define identifier value
  2. const关键字（const声明常量要在一条语句内完成）
     格式：const type variable = value;
  3. 枚举常量（本质：数字由字符来表达）
     格式：enum 枚举类型名称 {符号变量a, 符号变量b, 符号变量c}; a、b、c的值从零开始递增
          指定值：enum COLOR {red=1,yellow,green=5}; 则red=1,yellow=2,green=5(默认递增)
     重点：枚举类型只能是int
*/
</code></pre>
<h2 id="15-字符串">1.5 字符串</h2>
<blockquote>
<p>本质：使用null字符<code>\0</code>终止的一维字符数组</p>
</blockquote>
<h2 id="16-注释">1.6 注释</h2>
<blockquote>
<p>解释代码</p>
</blockquote>
<pre><code class="language-C">// C++注释风格，最后引入C语言中/*C语言注释风格不支持嵌套注释*/
</code></pre>
<p><img src="image/image_10.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525451984.png" alt="" loading="lazy"></p>
<h2 id="17-选择语句">1.7 选择语句</h2>
<pre><code class="language-C">/*分支语句*/
int main() {
  int a = 1;
  if (a==1)
  {
    printf(&quot;a = 1&quot;);
  }
  else
  {
    printf(&quot;a != 1&quot;);
  }
  return 0;
}
</code></pre>
<p><img src="image/image_11.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525459799.png" alt="" loading="lazy"></p>
<blockquote>
<p>当if或else内只有一条语句时可省略大括号</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="image/image_12.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://listen2022.github.io/post-images/1643525467217.png" alt="" loading="lazy"></figure>
<h2 id="18-循环语句">1.8 循环语句</h2>
<pre><code class="language-C">/* 循环语句 */int main() {  int line = 0;  while (line &lt; 30000)  {    printf(&quot;coding: %d\n&quot;, line);    line++;  }  if (line==30000)  {    printf(&quot;进大厂 拿高薪\n&quot;);  }  return 0;}
</code></pre>
<p><img src="image/image_13.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525475697.png" alt="" loading="lazy"></p>
<blockquote>
<p>while循环内只有一条语句时可省略大括号</p>
</blockquote>
<h2 id="19-函数">1.9 函数</h2>
<pre><code class="language-C">/* 函数 */int main(){  int a = 3;  int b = 4;  int result = 0;  result = Add(a, b);  printf(&quot;result =&gt; %d\n&quot;, result);  return 0;}int Add(int x, int y){  int result = 0;  result = x + y;  return result;}
</code></pre>
<p><img src="image/image_14.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525482852.png" alt="" loading="lazy"></p>
<h2 id="110-数组">1.10 数组</h2>
<blockquote>
<p>一组相同类型的元素的集合</p>
</blockquote>
<pre><code class="language-C">// 数组int main(){  // 创建  int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };  // 其中arr为数组名 int为数组中每个元素的类型 10为数组中元素的个数  char ch[10] = { 'a', 'b', 'c', 'd', 'e' }; // 不完全初始化，其余值默认为0  // 访问(利用每个元素的下标 索引从零开始依次往后)  int i = 0;  while (i&lt;10)  {    printf(&quot;arr[%d] =&gt; %d\n&quot;, i, arr[i]);    i++;  }  return 0;}
</code></pre>
<p><img src="image/image_15.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525490094.png" alt="" loading="lazy"></p>
<h2 id="111-操作符">1.11 操作符</h2>
<h4 id="1111-算数操作符">1.11.1 算数操作符</h4>
<pre><code class="language-C">+ - * / %
</code></pre>
<h4 id="1112-移位操作符">1.11.2 移位操作符</h4>
<pre><code class="language-C">&gt;&gt; &lt;&lt;
</code></pre>
<h4 id="1113-位操作符">1.11.3 位操作符</h4>
<pre><code class="language-C">&amp; 按位与| 按位或^ 按位异或
</code></pre>
<h4 id="1114-赋值操作符">1.11.4 赋值操作符</h4>
<pre><code class="language-C">= += -= *= /= &gt;&gt;= &lt;&lt;=
</code></pre>
<h4 id="1115-单目操作符">1.11.5 单目操作符</h4>
<pre><code class="language-C">！ // 逻辑非运算符~ // 按位取反运算符++ -- // 自增自减运算符- // 负号运算符(type) // 类型转换运算符*和&amp; // 指针运算符和取地址运算符sizeof // 长度运算符 sizeof求变量时后面的括号可以省略 求类型时不可以省略       // sizeof(int) sizeof(a)       // 可以计算数组，单位是字节
</code></pre>
<h4 id="1116-关系操作符">1.11.6 关系操作符</h4>
<pre><code class="language-C">==
!=
&gt;
&gt;=
&lt;
&lt;=
</code></pre>
<h4 id="1117-逻辑运算符">1.11.7 逻辑运算符</h4>
<pre><code class="language-C">&amp;&amp; // 逻辑与
|| // 逻辑或
!  // 逻辑非
</code></pre>
<h4 id="1118-条件操作符">1.11.8 条件操作符</h4>
<pre><code class="language-C">// 三目操作符
exp1 ? exp2 : exp3;
// exp1成立，exp2执行，整个表达式的结果为exp2的结果
// exp1不成立，exp3执行，整个表达式结果为exp3的结果
</code></pre>
<h4 id="1119-逗号表达式">1.11.9 逗号表达式</h4>
<pre><code class="language-C">// 逗号隔开的一串表达式
exp1, exp2, exp3;
eg: (2, 2+1, 2+2, 2+3);
// 从前往后计算，整个表达式的结果是最后一个表达式的结果
</code></pre>
<h4 id="11110-其他">1.11.10 其他</h4>
<pre><code class="language-C">[] // 下标引用操作符() // 函数调用操作符.-&gt;
</code></pre>
<ul>
<li>
<p>自增/自减</p>
<pre><code class="language-C">// 前置++： 先++后使用int main(){  int a = 6;  int b = ++a;  printf(&quot;%d\n&quot;, a); // 7  printf(&quot;%d\n&quot;, b); // 7  return 0;}
</code></pre>
<p><img src="image/image_16.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525506704.png" alt="" loading="lazy"></p>
<pre><code class="language-C">// 后置++： 先使用后++int main(){  int a = 6;  int b = a++;  printf(&quot;%d\n&quot;, a); // 7  printf(&quot;%d\n&quot;, b); // 7  return 0;}
</code></pre>
<p><img src="image/image_17.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525515337.png" alt="" loading="lazy"></p>
</li>
<li>
<p>强制类型转换</p>
<pre><code class="language-C">int main() 
{
  int pi = (int)3.1415926;
  return 0;
}

</code></pre>
</li>
</ul>
<h2 id="112-关键字32个">1.12 关键字(32个)</h2>
<blockquote>
<p>C语言保留的一些有特殊作用词语。变量名不能是关键字。</p>
</blockquote>
<pre><code class="language-C">auto     声明自动变量。自动创建、自动销毁。修饰局部变量，可省略。
double   声明双精度变量或函数
typedef  用以给数据类型取别名
register 声明寄存器变量
short    声明短整型变量或函数
char     声明字符型变量或函数
const    声明只读变量
static   声明静态变量
int      声明整型变量或函数
struct   声明结构体变量或函数
unsigned 声明无符号类型变量或函数
volatile 说明变量在程序执行中可被隐含地改变
long     声明长整型变量或函数
union    声明共用数据类型，共用体
signed   声明有符号类型变量或函数
void     声明函数无返回值或无参数，声明无类型指针
float    声明浮点型变量或函数
enum     声明枚举类型
extern   声明变量是在其他文件正声明
if       条件语句
else     条件语句否定分支（与 if 连用）
switch   用于开关语句
case     开关语句分支
for      一种循环语句
do       循环语句的循环体
while    循环语句的循环条件
goto     无条件跳转语句
continue 结束当前循环，开始下一轮循环
break    跳出当前循环
default  开关语句中的&quot;其他&quot;分支
sizeof   计算数据类型长度
return   子程序返回语句（可以带参数，也可不带参数）循环条件

</code></pre>
<h4 id="其他">其他</h4>
<pre><code class="language-C">define、include不是关键字，是预处理指令 
</code></pre>
<ul>
<li>
<p>typedef</p>
<pre><code class="language-C">// 类型别名 类型重命名 用来简化代码
</code></pre>
<p><img src="image/image_18.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525525157.png" alt="" loading="lazy"></p>
</li>
<li>
<p>static</p>
<pre><code class="language-C">/*三种用法：  1.修饰局部变量：局部变量生命周期延长（本质：改变了数据类型，从栈区-&gt;静态区）  2.修饰全局变量：使全局变量只能在自己所在的源文件.c内部使用，即使在其他源文件种声明也不能使用改全局变量  3.修饰函数：使函数只能在自己的内部源文件.c种使用，项目中其他源文件不能使用*/ 
</code></pre>
<p><strong>示例</strong></p>
<ol>
<li>static修饰局部变量<br>
<img src="image/image_19.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525540111.png" alt="" loading="lazy"></li>
<li>static修饰全局变量<br>
<img src="image/image_20.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525548670.png" alt="" loading="lazy"></li>
<li>static修饰函数<br>
<img src="image/image_21.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525587921.png" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
<h2 id="113-define">1.13 define</h2>
<blockquote>
<p>define使预处理指令</p>
</blockquote>
<pre><code class="language-C">/*作用：  1. 定义常量  2. 定义宏（宏用来完成替换）*/
</code></pre>
<h4 id="1131-定义变量">1.13.1 定义变量</h4>
<p><img src="image/image_22.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525597325.png" alt="" loading="lazy"></p>
<h4 id="1132-定义宏">1.13.2 定义宏</h4>
<p><img src="image/image_23.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525605286.png" alt="" loading="lazy"></p>
<pre><code class="language-C">// 宏只完成替换// 为保证正常运行，应使用小括号将函数体括起来
</code></pre>
<p><img src="image/image_24.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525614422.png" alt="" loading="lazy"></p>
<h2 id="114-指针">1.14 指针</h2>
<blockquote>
<p>指针描述了数据在内存中的位置（内存地址），标示了一个占据存储空间的实体。 C/C++语言中，指针一般被认为是指针变量，指针变量的内容存储的是其指向的对象的首地址，指向的对象可以是变量（指针变量也是变量），数组，函数等占据存储空间的实体。</p>
</blockquote>
<h4 id="1141-指针变量的声明">1.14.1 指针变量的声明</h4>
<pre><code class="language-C">// 格式；type *var_name;// type使指针的基类型，*表示该变量是一个指针变量，var_name使变量名// eg:int* pi;double* pd;
</code></pre>
<h4 id="1142-指针变量的大小">1.14.2 指针变量的大小</h4>
<pre><code class="language-C">// 在32位系统种，指针变量大小为4byte// 在64位系统种，指针变量大小位8byte// 指针变量大小与指针指向的数据类型无关// 下图为64位系统种，指针大小演示：
</code></pre>
<p><img src="image/image_25.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525625321.png" alt="" loading="lazy"></p>
<h4 id="1142-访问数据地址">1.14.2 访问数据地址</h4>
<pre><code class="language-C">// 格式：
&amp;var_name
// 通过&amp;获取var_name所在的内存地址
// eg:
int main() 
{
  int a = 666;
  int* pa = &amp;a; // 去除变量a的地址并赋值给指针变量pa
  printf(&quot;%p\n&quot;, pa);
  return 0;
}

</code></pre>
<p><img src="image/image_26.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525634547.png" alt="" loading="lazy"></p>
<h4 id="1143-null指针">1.14.3 NULL指针</h4>
<pre><code class="language-C">// NULL指针：空指针，是一个定义在标准库中的值为零的常量。

</code></pre>
<p><img src="image/image_27.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525642059.png" alt="" loading="lazy"></p>
<blockquote>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。</p>
</blockquote>
<h2 id="115-结构体">1.15 结构体</h2>
<blockquote>
<p><strong>结构</strong>是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构用于表示一条记录。</p>
</blockquote>
<h4 id="1151-定义">1.15.1 定义</h4>
<pre><code class="language-C">// 格式：struct 结构体名 {     结构体所包含的变量};// eg:struct Student{  char name[16]; // 姓名  int age;       // 年龄  double height; // 身高};
</code></pre>
<h4 id="1152-结构体变量">1.15.2 结构体变量</h4>
<ul>
<li>
<p>定义结构体时定义结构体变量</p>
<pre><code class="language-C">struct Student
{
  char name[16]; // 姓名
  int age;       // 年龄
  double height; // 身高
} s1, s2;
// 将变量放在结构体的最后
</code></pre>
</li>
<li>
<p>如果只需要是使用s1和s2，此后不再使用结构体，则可省略结构体名称</p>
<pre><code class="language-C">struct{
  char name[16]; // 姓名
  int age;       // 年龄
  double height; // 身高
} s1, s2;
</code></pre>
</li>
</ul>
<h4 id="1153-成员获取和赋值">1.15.3 成员获取和赋值</h4>
<ul>
<li>
<p>获取</p>
<pre><code class="language-C">// 1).结构体变量名.成员名
printf(&quot;name: %s, age: %d, height: %lf\n&quot;, s.name, s.age, s.height);
// 2).结构体指针变量名-&gt;成员名
struct Student* ps = &amp;s;
printf(&quot;name: %s, age: %d, height: %lf\n&quot;, (*ps).name, (*ps).age, (*ps).height);
printf(&quot;name: %s, age: %d, height: %lf\n&quot;, ps-&gt;name, ps-&gt;age, ps-&gt;height);
</code></pre>
</li>
<li>
<p>赋值</p>
<pre><code class="language-C">// 1).单个赋值：结构体变量名.成员名 = &quot;Value&quot;;
// 2).整体赋值，eg：
//    a.定义结构体时整体赋值：
      struct{
        char name[16]; // 姓名
        int age;       // 年龄
        double height; // 身高
      } s = {&quot;listen&quot;, 20, 180.5};
//    b.定义结构体后整体赋值：
      struct Student s = {&quot;listen&quot;, 20, 185};

// 结构体是创建变量的模板，不占用内存空间
// -&gt; 先找到指针指向的对象，再找到他的成员
</code></pre>
</li>
</ul>
<p><img src="image/image_28.png" alt="" loading="lazy"><br>
<img src="https://listen2022.github.io/post-images/1643525654342.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>