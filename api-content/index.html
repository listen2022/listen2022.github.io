{"posts":[{"title":"5. C语言--操作符","content":"5.操作符 5.1 算术操作符 + - * / % 除%操作符之外，其他几个操作符可以作用于整数和浮点数。 对于/操作符如果两个操作符都为整数，执行整数除法。只要有一个浮点数，则执行浮点数除法。 float num = 1 / 2; // num=0.000000; float num = 1 / 2.0; // num=0.500000; // 这里的2.0 是double类型 而num为float类型 // 可以做如下调整 float num = 1f / 2.0f; double num = 1 / 2.0; %操作符两端必须都是整数，可以是负数，但不能为0。 5.2 移位操作符 &gt;&gt; &lt;&lt; 5.2.1 非负整数的二进制表示形式 原码：直接根据数值写出二进制 反码：原码符号位不变，其他位按位取反 补码：反码加1 // 非负整数在内存中存放的是原码（非负整数的原码、反码、补码相同） // 负整数在内存中存放的是补码 5.2.2 左移 算数左移和逻辑左移相同，都是左边抛弃，右边补0。 5.2.3 右移 算术右移（通常采用） 向右移动，首位补原二进制位的第一位 逻辑右移 向右移动，首位补0 // 只能移动非负整数位 int main() { int ret = -1 &gt;&gt; 1; printf(&quot;%d\\n&quot;, ret); return 0; } 5.3 位操作符 &amp; | ^ // 操作数必须为整数 5.3.1 按位与 int main() { int ret = 3 &amp; 4; // 00000000000000000000000000000011 // &amp; // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } 5.3.2 按位或 // 按位或 int main() { int ret = 3 | 4; // 00000000000000000000000000000011 // | // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } 5.3.3 按位异或 相同为0，相异为1 int main() { int ret = 3 ^ 4; // 00000000000000000000000000000011 // ^ // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } // 奇数^奇数=偶数 // 奇数^偶数=奇数 // 偶数^偶数=偶数 5.3.4 题目 交换两个int变量的值，不使用第三个变量 方法一 int main() { int a = 3; int b = 4; a = a + b; b = a - b; a = a - b; printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } // 问题：数字过大，内存溢出 方法二 int main() { int a = 3; int b = 4; a = a ^ b; b = a ^ b; a = a ^ b; printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } // 没有进位，不可能发生溢出 // 异或特点： // 1.任何数和他本身异或，结果为0 // 2.任何数和0异或，结果为他本身 // 底层逻辑： // b = a ^ b ^ b = a (前两行代码) // a = a ^ b ^ b ^ a ^ b = b (第三行代码) 5.3.5 练习 编写代码实现：求一个整数存储在内存中的二进制中1的个数 方法一 int main() { int num = 5; int count = 0; for (int i = 0; i &lt; 32; i++) { if (num % 2 == 1) { count++; } num = num &gt;&gt; 1; } printf(&quot;count=%d\\n&quot;, count); return 0; } 缺点：不能统计负数的二进制中1的个数。 方法二 int main() { int num = -5; int count = 0; for (int i = 0; i &lt; 32; i++) { if ((num &gt;&gt; i) &amp; 1) { count++; } } printf(&quot;count=%d\\n&quot;, count); return 0; } // -5 // 原码 10000000000000000000000000000101 // 补码 11111111111111111111111111111011 // 右移0位 // 11111111111111111111111111111011 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 // 右移一位 // 01111111111111111111111111111101 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 // 右移二位 // 00111111111111111111111111111110 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000000 -&gt; 0 // ... // 右移31位 // 00000000000000000000000000000001 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 方法三 int main() { int num = -5; int count = 0; while (num) { num = num &amp; (num - 1); count++; } printf(&quot;count=%d\\n&quot;, count); return 0; } // num &amp; (num - 1) // 11111111111111111111111111111011 =&gt; num // 11111111111111111111111111111011 &amp; (11111111111111111111111111111011 - 1) // 11111111111111111111111111111011 &amp; 11111111111111111111111111111010 // 11111111111111111111111111111010 =&gt; num // 11111111111111111111111111111010 &amp; (11111111111111111111111111111010 - 1) // 11111111111111111111111111111010 &amp; 11111111111111111111111111111001 // 11111111111111111111111111111000 =&gt; num // ... // 每次把num&amp;(num-1)的结果再赋值给num // 每num&amp;(num-1)运算一次，就会将num中的1变成0 // 通过n次num&amp;(num-1)运算使得num=0 // 此时n为num的二进制中1的个数 5.4 赋值操作符 = += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= |= ^= // 连续赋值： int a = 0; int b = 0; int c = 1; a = b = c + 1; // 从由向左赋值（不推荐） 5.5 单目操作符 只有一个操作数 ! // 逻辑反操作 - // 负 + // 正 sizeof // 操作数类型长度 ~ // 按位取反 -- // 前置 后置 ++ // 前置 后置 * // 解引用(间接访问)操作符 &amp; // 取址 (type) // 强制类型转换 5.5.1 sizeof sizeof是一个操作符，不是函数。单位：字节 例1 int main() { short s = 5; int a = 10; printf(&quot;%d\\n&quot;, sizeof(s = a + 2)); // sizeof括号中放的表达式，不参与运算 // 在编译期间处理sizeof(s = a + 2); 而s = a + 2在程序运行时计算 // 大数据放在小空间里被截断 printf(&quot;%d\\n&quot;, s); // 5 return 0; } 例2 int main() { int a = 10; printf(&quot;%d\\n&quot;, sizeof(a)); printf(&quot;%d\\n&quot;, sizeof a); printf(&quot;%d\\n&quot;, sizeof(int)); //printf(&quot;%d\\n&quot;, sizeof int); char arr[10] = { 0 }; printf(&quot;%d\\n&quot;, sizeof(arr)); printf(&quot;%d\\n&quot;, sizeof arr); printf(&quot;%d\\n&quot;, sizeof(char [10])); } 例3 void foo1(int arr[10]) { printf(&quot;%d\\n&quot;, sizeof(arr)); } void foo2(char arr[10]) { printf(&quot;%d\\n&quot;, sizeof(arr)); } int main() { int arr1[10] = { 0 }; char arr2[10] = { 0 }; printf(&quot;%d\\n&quot;, sizeof(arr1)); // 40 printf(&quot;%d\\n&quot;, sizeof(arr2)); // 10 foo1(arr1); // 4或8 foo2(arr2); // 4或8 return 0; } // 数组作为函数参数传递时，实际传递的是数组的指针 5.5.2 ~ 按位取反 int main() { int a = 13; // 00000000000000000000000000001101 // 将a的二进制位第五位置零 // 00000000000000000000000000001101 -&gt; 13的二进制 // 00000000000000000000000000010000 -&gt; 1&lt;&lt;4 // | -&gt; 按位或 // 00000000000000000000000000011101 -&gt; 结果29 a = a | (1 &lt;&lt; 4); printf(&quot;%d\\n&quot;, a); // 将a的二进制位第五位置一 // 00000000000000000000000000011101 -&gt; 29的二进制 // 11111111111111111111111111101111 -&gt; ~(1&lt;&lt;4) // &amp; -&gt; 按位与 // 00000000000000000000000000001101 -&gt; 结果13 a = a &amp; (~(1 &lt;&lt; 4)); printf(&quot;%d\\n&quot;, a); return 0; } 5.5.3 ++/— // 前置：先++，再使用 // 后置：先使用，再++ // (使用包括赋值和函数传参) 后++ 先++ 垃圾代码 int main() { int a = 1; int b = (++a) + (++a) + (++a); printf(&quot;%d\\n&quot;, b); return 0; } // 运行结果：vs2019中结果是12 // linux中结果是10 // 垃圾代码，不做过多研究 5.5.4 &amp; * &amp; // 取址 * // 解引用 例 int main() { int num = 100; // &amp;获取对象所处的内存地址，取址操作符 int* pn = &amp;num; // 此处*不是操作符，仅说明pn是一个指针变量 *pn = 200; // 此处*才是解引用操作符，将200赋值给pn所指的对象 printf(&quot;pn=%p, num=%d\\n&quot;, pn, num); return 0; } 5.5.5 (type) int main() { int num = (int)3.1315; // 强制类型转换 printf(&quot;%d\\n&quot;, num); return 0; } 5.6 关系操作符 &gt; &gt;= &lt; &lt;= != == // = 赋值 // == 判断是否相等 // 比较两个字符串是否相等不能使用== 5.7 逻辑操作符 &amp;&amp; 逻辑与：从前往后找到第一个为假的值返回0，否则返回1 || 逻辑或：从前往后找到第一个为真的值返回1，否则返回0 5.7.1 习题 如下代码运行结果： int main() { int i = 0, a = 0, b = 2, c = 3, d = 4; i = a++ &amp;&amp; ++b &amp;&amp; d++; //i = a++ || ++b || d++; printf(&quot;a=%d, b=%d, c=%d, d=%d\\n&quot;, a, b, c, d); } // &amp;&amp;: 左边确定为假，后边不用再进行计算 // ||: 左边确定为真，后边不用再进行计算 5.8 三目操作符 exp1 ? exp2 : exp3; // 如果exp1为真，则计算exp2，整个表达式的结果为exp2的结果，exp3不计算 // 如果exp2为假，则计算exp3，整个表达式的结果为exp3的结果，exp2不计算 例 int main() { int a = 3; int b = 4; int ret = 0; ret = a &gt; b ? a++ : b++; printf(&quot;%d\\n&quot;, ret); printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } 5.8 逗号表达式 exp1, exp2, exp3; // 从前往后依次执行，整个表达式的结果为最后一个表达式exp3的计算结果 5.9 下标引用 下标引用操作符有两个操作数，数组名和下标。 int main() { int arr[10] = { 0 }; // 此处[]不是操作符，仅用来指定数组的大小 arr[4] = 100; // 此处[]为操作符，指定数组中索引(或下标)为4的值为100 printf(&quot;arr[4]=%d\\n&quot;, arr[4]); return 0; } 5.10 函数调用 有一个或多个操作数，当没有参数时，只有函数名一个操作数；当有参数时，操作时个数为参数个数+1。 // 函数调用 int Add(int x, int y) // 此处()不是操作符，仅用来说明形参及其类型 { return x + y; } int main() { int ret = Add(3, 4); // 此处()为函数调用操作符，即使没有参数，也要有() 操作数：Add 3 4共3个 printf(&quot;%d\\n&quot;, ret); return 0; } 5.11 结构成员访问操作符 . -&gt; // 使用格式： 结构体变量.结构体成员变量名 结构体指针变量-&gt;结构体成员变量名 例 int main() { struct Person { char name[10]; int age; float height; }; printf(&quot;.操作符\\n&quot;); struct Person p = { &quot;listen&quot;, 22, 185.0 }; printf(&quot;name: %s\\n&quot;, p.name); printf(&quot;age: %d\\n&quot;, p.age); printf(&quot;height: %f\\n&quot;, p.height); struct Person* pp = &amp;p; printf(&quot;name: %s\\n&quot;, (*pp).name); printf(&quot;age: %d\\n&quot;, (*pp).age); printf(&quot;height: %f\\n&quot;, (*pp).height); printf(&quot;-&gt;操作符\\n&quot;); printf(&quot;name: %s\\n&quot;, pp-&gt;name); printf(&quot;age: %d\\n&quot;, pp-&gt;age); printf(&quot;height: %f\\n&quot;, pp-&gt;height); return 0; } 5.12 表达式求值 表达式求值的顺序一般是由操作符的优先级和结合性决定。同样，有些表达式的操作数再求值的过程中可能需要转换为其他类型。 5.12.1 隐式类型转换 C的整形算数运算总是至少以缺省整形类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换称为整形提升。 包括： 整形提升 算数转换 5.12.2 整型提升 概念 在表达式计算时，各种整形（只有比int小的类型才会发生整型提升）首先要提升为int类型，如果int类型不足以表示的话，就需要提升为unsigned int类型，然后再执行表达式的运算。 意义 虽然机器指令中可能有现两个8比特字节这种字节相加指令，但是一般用途的CPU是难以直接实现这样的字节相加运算的。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。而表达式的整型运算要在CPU的相应运算器件内执行。因此，两个char类型的数进行相加运算时，是在CPU中执行，自然而然的需要先转换为CPU内整型操作数的标准长度。 如何提升 按照最高位进行整型提升 正数整型提升：高位补0 负数整形提升：高位补1 无符号整数整形提升：高位补0 例1 int main() { char a = 3; char b = 127; char c = a + b; printf(&quot;%d\\n&quot;, c) return 0; } // 原理 char a = 3; //二进制： 00000011 char b = 127; //二进制：01111111 char c = a + b; // + 操作符 整型提升 //a 提升： 00000000000000000000000000000011 //b 提升： 00000000000000000000000001111111 // 相加： 00000000000000000000000010000010 //c 截断： 10000010 printf(&quot;c=%d\\n&quot;, c); // c是char类型，而使用%d打印，c 整形提升(高位补1) // 11111111111111111111111110000010 补码 // 11111111111111111111111110000001 反码（补码-1） // 10000000000000000000000001111110 原码（反码符号位不变，其余位取反） 例2 int main() { char a = 0xFF; // a整形提升之后为11111111111111111111111111111111 short b = 0xFFFF; // b整形提升之后为11111111111111111111111111111111 int c = 0xFFFFFFFF; if (a == 0xFF) { printf(&quot;a\\n&quot;); } if (b == 0xFFFF) { printf(&quot;b\\n&quot;); } if (c == 0xFFFFFFFF) { printf(&quot;c\\n&quot;); } printf(&quot;%d\\n&quot;, a == b); return 0; } // 其中a, b需要进行整形提升，而c不需要整形提升 // a, b整形提升之后变成了负数，所以a==0xFF和b == 0xFFFF为假 例3 int main() { char a = 1; printf(&quot;%u\\n&quot;, sizeof a); printf(&quot;%u\\n&quot;, sizeof -a); // 类型提升为int类型 printf(&quot;%u\\n&quot;, sizeof +a); printf(&quot;%u\\n&quot;, sizeof !a); // vs2022中为1 gcc中为4 return 0; } 5.12.3 算数转换 如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转化为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换。 long double double float unsigned long int long int unsigned int int 如果某个操作数的类型在上面这个列表中排名较低，那么首先要转化为另一个操作数的类型后执行运算。 例 int main() { float a = 1.23; int b = 5; float c = 0; c = a + b; // a为float类型，b为int类型， // float类型值和int类型值相加时， // int类型值被转换为float类型 printf(&quot;%f\\n&quot;, c); return 0; } 5.13 表达式的属性 值属性(运行后才能确定) 类型属性(可推断，编译时确定) 5.14 操作符的属性 复杂表达式的求值有三个影响的因素： 操作符的优先级 操作符的结合性 是否控制求值顺序（例如&amp;&amp; || ,） 5.14.1 优先级 运算符的优先级确定表达式中项的组合。如果优先级相同，则根据结合性确定计算顺序。 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= = 逗号 , 从左到右 5.14.2 一些问题表达式 表达式1 a * b + c * d + e * f; // 计算原理： // 方法1： a * b; c * d; e * f; a * b + c * d + e * f // 方法2： a * b; c * d; a * b + c * d; e * f; a * b + c * d + e * f; 表达式2 c + --c; // 无法确定左操作数是在--c之前还是--c之后确定 // 计算原理： // 方法1： --c; c; c + --c; // 方法2： c; --c; c + --c; 代码3-错误代码 int main() { int i = 10; i = i-- - --i * (i = -3) * i++ + ++i; printf(&quot;i = %d\\n&quot;, i); return 0; } // 输出结果在不同的编译器中结果不同 代码4- 错误代码 int fun() { static int count = 1; return ++count; } int main() { int answer; answer = fun() - fun() * fun(); // 2 - 3 * 4 (vs2022中) printf(&quot;%d\\n&quot;, answer); // -10(vs2022中) return 0; } // 结果不可控，fun()函数的调用顺序不同，结果不同 代码5-错误代码 int main() { int i = 1; int ret = (++i) + (++i) + (++i); printf(&quot;%d\\n&quot;, ret); } // VS -&gt; 12 // 执行原理 ++i; ++i; ++i; i = 4 4 + 4 + 4; // gcc -&gt; 10 ++i; ++i; i = 3; 3 + 3; ++i; i = 4; 3 + 3 + 4; 5.14.3 总结 对于同一个表达式或一段代码，即使有确定的优先级和结合性，仍然有不确定的计算或运行方式，且不同方式计算出来的结果不同，则该表达式或代码是存在问题的，不应该使用这样的表达式和代码。 ","link":"https://listen2022.github.io/5-c-yu-yan-cao-zuo-fu/"},{"title":"4. C语言--数组","content":"4.数组 数组是一组相同类型元素的集合。 4.1 一维数组的创建和初始化 4.1.1 创建 // 格式： type_t arr_name [const_n] // type_t 数组元素类型 // arr_name 数组名称 // const_n 常量表达式，指定数组大小 // 在VS2019、VS2022中不支持变长数组 // 在gcc编译器中支持 // 创建 int arr[10]; 4.1.2 初始化 int main() { int arr1[3] = {0, 1, 2}; // 完全初始化 int arr2[3] = {1, 2}; // 不完全初始化 int arr3[] = { 2, 4, 6, 8 }; // 自动确定数组长度 int arr4[5] = { 2, 4, 6, 8 }; // 与上一条语句等价 int arr5[10] = { 0 } // 不完全初始化，不是把10个元素全初始化为0 int arr6[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } char ch1[5] = &quot;ccc&quot;; // 'c' 'c' 'c' '\\0' 0 char ch2[] = &quot;ccc&quot;; // 'c' 'c' 'c' '\\0' char ch3[] = { 'c', 'c', 'c' }; // 'c' 'c' 'c' printf(&quot;%s\\n&quot;, ch1); printf(&quot;%s\\n&quot;, ch2); printf(&quot;%s\\n&quot;, ch3); return 0; } 4.2 一维数组的使用 4.2.1 获取 [] // 下标引用操作符 int arr[5] = { 1, 2, 3, 4, 5 }; arr[3]; // 获取数组arr中下标为3的元素的值 4.2.2 赋值 arr[3] = 444; 4.2.3 数组中元素的个数 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int size = sizeof(arr) / sizeof(arr[0]); // 获取数组中元素的个数 // sizeof(arr)获取的是整个数组的大小，单位是字节 printf(&quot;%d\\n&quot;, size); } 4.3 一维数组在内存中的存储 4.3.1 %x和%p的区别 int main() { printf(&quot;%x\\n&quot;, 0x5f); printf(&quot;%p\\n&quot;, 0x5f); return 0; } // 指针是有长度的 4.3.2 存储方式 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; for (int i = 0; i &lt; 5; i++) { printf(&quot;&amp;arr[%d] =&gt; %p\\n&quot;, i, &amp;arr[i]); } } // 现象：下标每增加1，地址变化4字节，刚好是int类型的大小 // 结论： // 一维数组在内存中是连续存放的 // 随着数组下标的增长，地址是由低到高变化 4.3.3 应用 // 对于int指针，p++，每次增加int类型的字节数(4byte) // 对于char指针，p++，每次增加char类型的字节数(1byte) 4.4 二维数组的创建和初始化 int main() { // 创建 int arr[3][4]; // 三行四列 char ch[3][4]; double dou[3][4]; // 初始化 int arr1[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; // 完全初始化 int arr2[3][4] = { {1, 2},{3, 4},{5, 6} }; // 每行初始化 int arr3[][4] = { {1, 2},{3, 4},{5, 6} }; // 省略行(但不能省略列) int ch[3][4] = {'h','e','l','l','o'}; // 不完全初始化 return 0; } 4.5 二维数组的使用 int main() { int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; for (int i = 0; i &lt; 3; i++) { for ( int j=0; j&lt;4; j++) { printf(&quot;%d &quot;, arr[i][j]); } printf(&quot;\\n&quot;); } return 0; } 4.6 二维数组在内存中的存储 int main() { int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 4; j++) { printf(&quot;arr[%d][%d]=%p\\n&quot;, i, j, &amp;arr[i][j]); } } return 0; } // 现象：每个元素相差4byte，恰好是int类型的大小 // 二维数组在内存中连续存放 4.7 数组作为函数参数 4.7.1 数组名 数组名是数组首元素的地址。 例外 sizeof(arr)获取的是整个数组的长度，单位：byte。 &amp;arr获取的是整个数组的地址。 int main() { int arr[5] = { 0 }; printf(&quot;arr =&gt; %p\\n&quot;, arr); printf(&quot;arr =&gt; %p\\n&quot;, arr+1); printf(&quot;&amp;arr =&gt; %p\\n&quot;, &amp;arr); printf(&quot;&amp;arr =&gt; %p\\n&quot;, &amp;arr+1); printf(&quot;&amp;arr[0] =&gt; %p\\n&quot;, &amp;arr[0]); printf(&quot;&amp;arr[0] =&gt; %p\\n&quot;, &amp;arr[0]+1); return 0; } 4.7.2 冒泡排序 // 两两相邻元素进行比较 void bubble_sort(int arr[], int count) // 形参arr本质是指针 { int i = 0; // 确定趟数 for ( i = 0; i &lt; count; i++) { int j = 0; // 每趟比较元素的次数 for ( j = 0; j &lt; count-1-i; j++) { if (arr[j] &gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } } int main() { int arr[] = { 1, 6, 3, 9, 4 }; int count = sizeof(arr) / sizeof(arr[0]); // 确定数组元素个数 bubble_sort(arr, count); // 数组在传参时，传递的时arr首元素的地址 for (int i = 0; i &lt; count; i++) // 打印排序结果 { printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); } return 0; } 4.8 练习 4.8.1 逆序数组中元素个数 void reverse(int arr[], int size) { int left = 0; int right = size-1; while (left&lt;right) { int tmp = 0; tmp = arr[right]; arr[right] = arr[left]; arr[left] = tmp; left++; right--; } } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int size = sizeof(arr) / sizeof(arr[0]); reverse(arr, size); return 0; } 4.8.2 交换数组 将数组A中的内容和数组B中的内容进行交换（数组一样大） int main() { int arr1[3] = { 1, 2, 3 }; int arr2[3] = { 4, 5, 6 }; // 错误操作： //int arr3[3] = { 0 }; //arr3 = arr2; //arr2 = arr1; //arr1 = arr2; // 元素可以相互赋值，但数组名不可以相互赋值，因为数组名是数组首元素的地址 // // 正确操作： int size = sizeof(arr1) / sizeof(arr1[0]); for (int i = 0; i &lt; size; i++) { int tmp = 0; tmp = arr1[i]; arr1[i] = arr2[i]; arr2[i] = tmp; } return 0; } 4.9 实例 4.9.1 三子棋 4.9.2 扫雷 ","link":"https://listen2022.github.io/4-shu-zu/"},{"title":"3. C语言--函数","content":"3.函数 3.1 函数是什么 函数是指一段可以直接被另一段程序或代码引用的程序或代码。也叫做子程序、（OOP中）方法。一个较大的程序一般应分为若干个程序块，每一个模块用来实现一个特定的功能。所有的高级语言中都有子程序这个概念，用子程序实现模块的功能。在C语言中，子程序是由一个主函数和若干个函数构成的。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。 3.1.1 函数分类 自定义函数 库函数 3.2 库函数 一般是指编译器提供的可在C源程序中调用的函数。分为两类，C语言标准规定的库函数和编译器特定的库函数。 3.2.1 网站 Learn C and C++ Programming - Cprogramming.com C 标准库头文件 - cppreference.com https://docs.microsoft.com/en-us/cpp/c-runtime-library/c-run-time-library-reference?view=msvc-170 3.2.2 strcp 3.2.3 memset 3.3 自定义函数 // 格式： ret_type func_name( parameter list ) { body of the function } // return_type 函数的返回类型 // function_name 函数名称 // parameter list 参数列表 // body of the function 函数体 // 当函数不返回任何类型，ret_type为关键字void 实例 void Swap(int* pa, int* pb) { int z = 0; z = *pa; *pa = *pb; *pb = z; } int main() { int a = 10; int b = 20; printf(&quot;交换前 a=%d, b=%d\\n&quot;, a, b); Swap(&amp;a, &amp;b); printf(&quot;交换后 a=%d, b=%d\\n&quot;, a, b); } 重点 void Swap(int* pa, int* pb) { int* z = NULL; printf(&quot;%p %p %p\\n&quot;, pa, pb, z); z = pa; pa = pb; pb = z; printf(&quot;%p %p %p\\n&quot;, pa, pb, z); } // 不能通过交换a、b的地址交换a、b的数据 int main() { int a = 10; int b = 20; printf(&quot;交换前 a=%d, b=%d\\n&quot;, a, b); Swap(&amp;a, &amp;b); printf(&quot;交换后 a=%d, b=%d\\n&quot;, a, b); } 3.4 函数参数 3.4.1 实际参数(argument) 真实传递给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在进行调用时，它们都必须有确定的值，以便把这些值传送给形参。 3.4.2 形式参数(parameter) 形式参数是指函数名后括号中的变量，因为形参只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成后就自动销毁。因此形式参数只在函数中有效。 3.4.3 形参实例化之后其实相当于实参的一份临时拷贝。 3.5 函数调用 3.5.1 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 3.5.2 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 3.6 函数的嵌套调用和链式访问 3.6.1 嵌套调用 在函数A()中调用函数B() #include &lt;stdio.h&gt; int main() { printf(&quot;Hello World!\\n&quot;); return 0; } // 最简单的嵌套调用，在main函数中调用prinf函数 3.6.2 链式访问 把一个函数的返回值作为另一个函数的参数。 #include &lt;stdio.h&gt; int add(int x, int y) { return x + y; } int main() { printf(&quot;输出：%d\\n&quot;, add(3, 4)); } // 将add(3, 4)的返回值作为参数，传递给printf函数 3.7 函数的声明和定义 3.7.1 声明 告诉编译器函数名称及如何调用函数。 return_type function_name( parameter list ); // 在函数声明中 // 参数的名称并不重要 // 只有参数的类型是必需的 // 因此可省略声明中形参的名称 3.7.2 定义 return_type function_name( parameter list ) { body of the function } 3.8 函数递归 函数对自身的调用。 递归的必要条件 递归调用的过程 递归终止的条件 3.9 小知识 #include &quot; &quot; 与 &lt;&gt;有什么区别？ // 若 #include &quot;&quot; 查找成功，则遮蔽 #include &lt;&gt; 所能找到的同名文件 // 否则再按照 #include &lt;&gt; 的方式查找文件 // #include &lt;&gt; 的查找位置是标准库头文件所在目录 // #include &quot;&quot; 的查找位置是当前源文件所在目录 // &lt;&gt;先去系统目录中找头文件，如果没有在到当前目录下找 // &quot;&quot;首先在当前目录下寻找，如果找不到，再到系统目录中寻找 C语言函数默认返回类型 // C语言中函数如果没有定义返回值类型，则默认返回类型是int ","link":"https://listen2022.github.io/3-han-shu/"},{"title":"2. C语言--分支和循环语句","content":"2.分支和循环语句 2.1 分支语句 C语言把任何非零和非空的值假定为 true，把零或 null 假定为 false 2.1.1 if else if语句 if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } if...else... if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } else { /* 如果布尔表达式为假将执行的语句 */ } if...else if...else... 一个if后可跟一个或零个else语句，else必须在所有else if之后 一个if后可跟多个或零个else if语句，else if必须在else之前 一旦某个else if匹配成功，其他的else if或else将不会被测试 if(boolean_expression1) { /* 当布尔表达式1为真时执行 */ } else if(boolean_expression2) { /* 当布尔表达式2为真时执行 */ } else if(boolean_expression3) { /*当布尔表达式3为真时执行*/ } else { /* 当上面条件都不为真时执行 */ } 嵌套if语句 if( boolean_expression1) { /* 当布尔表达式1为真时执行 */ if(boolean_expression2) { /* 当布尔表达式2为真时执行 */ } } // 可以在一个if...else...或if...else if...else..语句中 // 嵌套一个if...else...或if...else if...else..语句 2.1.2 switch switch switch(expression){ case constant-expression : statement(s); break; /* 可选 */ case constant-expression : statement(s); break; /* 可选 */ default : /* 可选 */ statement(s); } expression为常量表达式，必须是一个整形或枚举类型 constant-expression必须和expression的数据类型相同，且为一个常量或字面量 当被测试的变量等于case中的常量时，case后面的语句执行，直到遇到break语句 default case中的break语句不是必须的 default语句可以放在任意位置 嵌套switch 一个switch语句种包含另一个switch语句 switch(expression1) { case constant-expression: switch(expression2) { case constant-expression: ... break; case constant-expression: ... } break; case constant-expression: ... } 2.1.3 :?运算符(三目运算符) Exp1 ? Exp2 : Exp3; // ? 表达式的值是由 Exp1 决定的。 // 如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值 // 如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值 2.2 循环语句 2.2.1 for for ( init; condition; increment ) { statement(s); } // init: 首先执行，声明并初始化循环控制变量，可留空 // condition: 判断，如果为真，执行statement(s)，否则结束循环 // increment: 执行完for循环主体statement(s);之后，执行increment语句。该语句一般是更新循环控制变量，可留空 2.2.2 while while(condition) { statement(s); // 一条语句或语句块 } 2.2.3 do while for和while循环在循环开始时测试循环条件，而do...while...在每次循环中执行statement(s)语句之后，测试循环条件。 do { statement(s); }while( condition ) // statement(s);至少被执行一次 2.2.4 嵌套循环 嵌套for循环 for (initialization; condition; increment/decrement) { statement(s); for (initialization; condition; increment/decrement) { statement(s); } } 嵌套while循环 while (condition1) { statement(s); while (condition2) { statement(s); } } 嵌套 do while 循环 do { statement(s); do { statement(s); }while (condition2); }while (condition1) 混合嵌套 2.3 循环控制语句 2.3.1 break 终止循环或switch语句。在嵌套语句中，终止break所在的最内层的循环或switch语句。 2.3.2 continue 结束本次循环，进行下一次迭代。 2.3.3 goto 控制转移到被标记的语句。但是不建议在程序中使用goto语句（使得程序的控制流难以跟踪，使程序难以理解和难以修改）。 goto label; ... ... label: statement; // goto语句只能在一个函数范围内跳转，不能跨函数 // 一般不使用，跳出多层嵌套时使用 2.4 无限循环 for( ; ; ) { ... } // 倾向于使用该语句实现无限循环 2.3 习题 2.3.1 最大公约数 最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。 一般方法 int main() { int a = 12; int b = 16; int max = a; // 为a、b中较小的一个赋值给最大公约数 if (max &gt; b) { max = b; } for (; max &gt;= 1 ; max--) { if (a % max == 0 &amp;&amp; b % max == 0) { printf(&quot;%d\\n&quot;, max); break; } } return 0; } 辗转相除法 欧几里得算法：gcd(a, b) = gcd(b, a mod b) int main() { int a = 12; int b = 16; int t = 0; while (t = a % b) { a = b; b = t; } printf(&quot;%d&quot;, b); return 0; } 2.3.2 最小公倍数 两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。 一般方法 int main() { int a = 12; int b = 16; int min = a; // 存放a、b中较大值 if (min&lt;b) { min = b; } for ( ; ; min++) { if (min % a == 0 &amp;&amp; min % b == 0) { printf(&quot;%d&quot;, min); break; } } return 0; } 公式法 最小公倍数 × 最大公约数 = a × b int main() { int a = 12; int b = 16; int mul = a * b; // a和b的乘积 int t = 0; while (t = a % b) { a = b; b = t; } printf(&quot;%d&quot;, mul / b); return 0; } 2.3.3 排序 问题描述：给定三个数，从大到小输出 int main() { int a = 3; int b = 8; int c = 5; if (a &lt; b) { int t = a; a = b; b = t; } if (a &lt; c) { int t = a; a = c; c = t; } if (b &lt; c) { int t = b; b = c; c = t; } printf(&quot;%d %d %d&quot;, a, b, c); return 0; } 2.3.4 闰年 闰年（Leap Year）是为了弥补因人为历法规定造成的年度天数与地球实际公转周期的时间差而设立的。补上时间差的年份为闰年。闰年共有366天（1月~12月分别为31天、29天、31天、30天、31天、30天、31天、31天、30天、31天、30天、31天）。 规则：四年一闰，百年不闰，四百年再闰。 方法一： int main() { int sum = 0; for (int i = 0; i &lt;= 2050; i++) { if ( 0 == i % 4) { if (0 == i % 100) { if (0 == i % 400) { printf(&quot;%d\\n&quot;, i); } } else { printf(&quot;%d\\n&quot;, i); } } } return 0; } 方法二： int main() { int sum = 0; for (int i = 0; i &lt;= 2050; i++) { if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || (i % 400 == 0 )) { printf(&quot;%d是闰年\\n&quot;, i); sum++; } } printf(&quot;sum = %d\\n&quot;, sum); } 2.3.5 素数(质数) 在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 int main() { for (int i = 2; i &lt;= 100; i++) { int j = i - 1; for ( ; j&gt;=1; j-- ) { if (0 == i % j) { break; } } if (j == 1) { printf(&quot;%d\\n&quot;, i); } } } 优化： int main() { for (int i = 2; i &lt;= 100; i++) { int flag = 1; // flag=1时为素数 int j = 2; for ( ; j*j &lt;= i ; j++) { if (0 == i % j) { flag = 0; // flag为0时不为素数 break; } } if (flag) { printf(&quot;%d\\n&quot;, i); } } } 2.3.6 goto使用 # Windows关机命令 shutdown -s -t 60 # 设置关机 shutdown -a # 取消关机 // C语言中使用system(&quot;&quot;)执行系统命令 // system()函数在&lt;stdlib.h&gt;头文件中 // C语言中两个字符串不能使用`==`比较大小 // 可使用strcmp(str1, str2)函数 // 字符串相等函数返回0，该函数在&lt;string.h&gt;头文件中 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char input[20] = { 0 }; Lable: system(&quot;shutdown -s -t 60&quot;); printf(&quot;电脑将在1min之后关机，请输入密码进行取消：&quot;); scanf(&quot;%s&quot;, input); if (0 == strcmp(input, &quot;123&quot;)) { system(&quot;shutdown -a&quot;); } else { goto Lable; } return 0; } 小问题 #define _CRT_SECURE_NO_WARNINGS // 源文件第一行（忽略VS的安全检测） ","link":"https://listen2022.github.io/2fen-zhi-he-xun-huan-yu-ju/"},{"title":"1. C语言--初始C语言","content":"1. 初始C语言 1.1 介绍 广泛应用于底层开发（如：驱动）。有完整的美国国家标准语法，称为ANDI C。C语言是一门面向过程的的计算机语言。主要的编译器有Clang、GCC、WIN-TC、Turbo C等。 国际标准：C89、C90、C99、C11（C90之后的标准没有火起来） 1.2 第一个C程序 1.2.1 编译器 Visual Studio、Dev C++、Visual C++ 6.0、GCC、Clang、Pelles C、Watcom C/C++、Tiny C Compiler、Code::Blocks、Turbo C、C-Free等 1.2.2 继承开发环境（IDE） VS2013/VS2019：集成开发环境，集成了windows下的C语言编译器 1.2.3 文件 xxx.c 源文件 xxx.h 头文件 1.2.4 步骤 创建项目 创建源文件 编写代码 主函数（main函数） #include &lt;stdio.h&gt; int main() { printf(&quot;Hello World!&quot;); return 0; } 编译、链接、运行代码 1.2.5 补充 一个项目中可以有多个.c文件 多个.c文件中有且仅有一个main函数 1.3 基本数据类型 在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。 1.3.1 整数类型 short (int) int long (int) long long (int) // 不同数据类型的大小因不同的计算机系统而异 // 编译器可以决定数据类型的大小但必须保证：short &lt;= int &lt;= long &lt;= long long 1.3.2 浮点类型 float // 单精度浮点型 double // 双精度浮点型 1.3.3 字符型 char // 可以当作整数类型处理 1.3.4 sizeof运算符 // sizeof(type) 得到对象或类型的存储字节大小 // 使用sizeof查看数据类型大小 int main() { printf(&quot;size of short %d\\n&quot;, sizeof(short)); printf(&quot;size of short %d\\n&quot;, sizeof(int)); printf(&quot;size of short %d\\n&quot;, sizeof(long)); printf(&quot;size of short %d\\n&quot;, sizeof(long long)); printf(&quot;size of short %d\\n&quot;, sizeof(float)); printf(&quot;size of short %d\\n&quot;, sizeof(double)); return 0; } 1.4 常量变量 1.4.1 变量 程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量定义 告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表。 type var_list; // type为C数据类型或自定义的对象 // var_list由一个或多个标识符组成，多个标识符之间使用逗号隔开 // eg: int a, b; char c; // 初始化：变量可以在声明时初始化（指定一个初始值） // eg: int a = 666; int x = 3, y = 4; 变量声明 向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 变量声明的两种情况： 1.需要建立存储空间。int a; 在声明时建立了存储空间 2.不需要建立存储空间。extern关键字声明变量而不定义 extern int a 其中变量a可以在其他c文件中定义 除非有extern关键字，其余都是变量的定义 左值和右值 左值（lvalue）：指向内存位置的表达式。左值可以出现在赋值号的左边或右边。变量时左值。 右值（rvalue）：存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。数值型字面量是右值。 1.4.2 常量 固定值。程序执行期间不会改变。又称为字面量。 可以是任何数据类型。比如：整数常量、浮点常量、字符常量、字符串字面值、枚举常量。 可认为是常规的变量，只不过在定义后不能修改。 转义字符：特定字符前有反斜杠，具有特殊含义。 /* 常量定义的方式： 1. #define预处理器 格式：#define identifier value 2. const关键字（const声明常量要在一条语句内完成） 格式：const type variable = value; 3. 枚举常量（本质：数字由字符来表达） 格式：enum 枚举类型名称 {符号变量a, 符号变量b, 符号变量c}; a、b、c的值从零开始递增 指定值：enum COLOR {red=1,yellow,green=5}; 则red=1,yellow=2,green=5(默认递增) 重点：枚举类型只能是int */ 1.5 字符串 本质：使用null字符\\0终止的一维字符数组 1.6 注释 解释代码 // C++注释风格，最后引入C语言中/*C语言注释风格不支持嵌套注释*/ 1.7 选择语句 /*分支语句*/ int main() { int a = 1; if (a==1) { printf(&quot;a = 1&quot;); } else { printf(&quot;a != 1&quot;); } return 0; } 当if或else内只有一条语句时可省略大括号 1.8 循环语句 /* 循环语句 */int main() { int line = 0; while (line &lt; 30000) { printf(&quot;coding: %d\\n&quot;, line); line++; } if (line==30000) { printf(&quot;进大厂 拿高薪\\n&quot;); } return 0;} while循环内只有一条语句时可省略大括号 1.9 函数 /* 函数 */int main(){ int a = 3; int b = 4; int result = 0; result = Add(a, b); printf(&quot;result =&gt; %d\\n&quot;, result); return 0;}int Add(int x, int y){ int result = 0; result = x + y; return result;} 1.10 数组 一组相同类型的元素的集合 // 数组int main(){ // 创建 int arr[10] = { 0,1,2,3,4,5,6,7,8,9 }; // 其中arr为数组名 int为数组中每个元素的类型 10为数组中元素的个数 char ch[10] = { 'a', 'b', 'c', 'd', 'e' }; // 不完全初始化，其余值默认为0 // 访问(利用每个元素的下标 索引从零开始依次往后) int i = 0; while (i&lt;10) { printf(&quot;arr[%d] =&gt; %d\\n&quot;, i, arr[i]); i++; } return 0;} 1.11 操作符 1.11.1 算数操作符 + - * / % 1.11.2 移位操作符 &gt;&gt; &lt;&lt; 1.11.3 位操作符 &amp; 按位与| 按位或^ 按位异或 1.11.4 赋值操作符 = += -= *= /= &gt;&gt;= &lt;&lt;= 1.11.5 单目操作符 ！ // 逻辑非运算符~ // 按位取反运算符++ -- // 自增自减运算符- // 负号运算符(type) // 类型转换运算符*和&amp; // 指针运算符和取地址运算符sizeof // 长度运算符 sizeof求变量时后面的括号可以省略 求类型时不可以省略 // sizeof(int) sizeof(a) // 可以计算数组，单位是字节 1.11.6 关系操作符 == != &gt; &gt;= &lt; &lt;= 1.11.7 逻辑运算符 &amp;&amp; // 逻辑与 || // 逻辑或 ! // 逻辑非 1.11.8 条件操作符 // 三目操作符 exp1 ? exp2 : exp3; // exp1成立，exp2执行，整个表达式的结果为exp2的结果 // exp1不成立，exp3执行，整个表达式结果为exp3的结果 1.11.9 逗号表达式 // 逗号隔开的一串表达式 exp1, exp2, exp3; eg: (2, 2+1, 2+2, 2+3); // 从前往后计算，整个表达式的结果是最后一个表达式的结果 1.11.10 其他 [] // 下标引用操作符() // 函数调用操作符.-&gt; 自增/自减 // 前置++： 先++后使用int main(){ int a = 6; int b = ++a; printf(&quot;%d\\n&quot;, a); // 7 printf(&quot;%d\\n&quot;, b); // 7 return 0;} // 后置++： 先使用后++int main(){ int a = 6; int b = a++; printf(&quot;%d\\n&quot;, a); // 7 printf(&quot;%d\\n&quot;, b); // 7 return 0;} 强制类型转换 int main() { int pi = (int)3.1415926; return 0; } 1.12 关键字(32个) C语言保留的一些有特殊作用词语。变量名不能是关键字。 auto 声明自动变量。自动创建、自动销毁。修饰局部变量，可省略。 double 声明双精度变量或函数 typedef 用以给数据类型取别名 register 声明寄存器变量 short 声明短整型变量或函数 char 声明字符型变量或函数 const 声明只读变量 static 声明静态变量 int 声明整型变量或函数 struct 声明结构体变量或函数 unsigned 声明无符号类型变量或函数 volatile 说明变量在程序执行中可被隐含地改变 long 声明长整型变量或函数 union 声明共用数据类型，共用体 signed 声明有符号类型变量或函数 void 声明函数无返回值或无参数，声明无类型指针 float 声明浮点型变量或函数 enum 声明枚举类型 extern 声明变量是在其他文件正声明 if 条件语句 else 条件语句否定分支（与 if 连用） switch 用于开关语句 case 开关语句分支 for 一种循环语句 do 循环语句的循环体 while 循环语句的循环条件 goto 无条件跳转语句 continue 结束当前循环，开始下一轮循环 break 跳出当前循环 default 开关语句中的&quot;其他&quot;分支 sizeof 计算数据类型长度 return 子程序返回语句（可以带参数，也可不带参数）循环条件 其他 define、include不是关键字，是预处理指令 typedef // 类型别名 类型重命名 用来简化代码 static /*三种用法： 1.修饰局部变量：局部变量生命周期延长（本质：改变了数据类型，从栈区-&gt;静态区） 2.修饰全局变量：使全局变量只能在自己所在的源文件.c内部使用，即使在其他源文件种声明也不能使用改全局变量 3.修饰函数：使函数只能在自己的内部源文件.c种使用，项目中其他源文件不能使用*/ 示例 static修饰局部变量 static修饰全局变量 static修饰函数 1.13 define define使预处理指令 /*作用： 1. 定义常量 2. 定义宏（宏用来完成替换）*/ 1.13.1 定义变量 1.13.2 定义宏 // 宏只完成替换// 为保证正常运行，应使用小括号将函数体括起来 1.14 指针 指针描述了数据在内存中的位置（内存地址），标示了一个占据存储空间的实体。 C/C++语言中，指针一般被认为是指针变量，指针变量的内容存储的是其指向的对象的首地址，指向的对象可以是变量（指针变量也是变量），数组，函数等占据存储空间的实体。 1.14.1 指针变量的声明 // 格式；type *var_name;// type使指针的基类型，*表示该变量是一个指针变量，var_name使变量名// eg:int* pi;double* pd; 1.14.2 指针变量的大小 // 在32位系统种，指针变量大小为4byte// 在64位系统种，指针变量大小位8byte// 指针变量大小与指针指向的数据类型无关// 下图为64位系统种，指针大小演示： 1.14.2 访问数据地址 // 格式： &amp;var_name // 通过&amp;获取var_name所在的内存地址 // eg: int main() { int a = 666; int* pa = &amp;a; // 去除变量a的地址并赋值给指针变量pa printf(&quot;%p\\n&quot;, pa); return 0; } 1.14.3 NULL指针 // NULL指针：空指针，是一个定义在标准库中的值为零的常量。 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。 1.15 结构体 结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构用于表示一条记录。 1.15.1 定义 // 格式：struct 结构体名 { 结构体所包含的变量};// eg:struct Student{ char name[16]; // 姓名 int age; // 年龄 double height; // 身高}; 1.15.2 结构体变量 定义结构体时定义结构体变量 struct Student { char name[16]; // 姓名 int age; // 年龄 double height; // 身高 } s1, s2; // 将变量放在结构体的最后 如果只需要是使用s1和s2，此后不再使用结构体，则可省略结构体名称 struct{ char name[16]; // 姓名 int age; // 年龄 double height; // 身高 } s1, s2; 1.15.3 成员获取和赋值 获取 // 1).结构体变量名.成员名 printf(&quot;name: %s, age: %d, height: %lf\\n&quot;, s.name, s.age, s.height); // 2).结构体指针变量名-&gt;成员名 struct Student* ps = &amp;s; printf(&quot;name: %s, age: %d, height: %lf\\n&quot;, (*ps).name, (*ps).age, (*ps).height); printf(&quot;name: %s, age: %d, height: %lf\\n&quot;, ps-&gt;name, ps-&gt;age, ps-&gt;height); 赋值 // 1).单个赋值：结构体变量名.成员名 = &quot;Value&quot;; // 2).整体赋值，eg： // a.定义结构体时整体赋值： struct{ char name[16]; // 姓名 int age; // 年龄 double height; // 身高 } s = {&quot;listen&quot;, 20, 180.5}; // b.定义结构体后整体赋值： struct Student s = {&quot;listen&quot;, 20, 185}; // 结构体是创建变量的模板，不占用内存空间 // -&gt; 先找到指针指向的对象，再找到他的成员 ","link":"https://listen2022.github.io/1chu-shi-c-yu-yan/"}]}