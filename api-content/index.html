{"posts":[{"title":"6. C语言--指针","content":"6.指针 6.1 指针是什么？ 在计算机中，所有的数据都是存放在存储器中的，不同的数据类型占有的内存空间的大小各不相同。内存是以字节为单位的连续编址空间，每一个字节单元对应着一个独一的编号，这个编号被称为内存单元的地址。比如：int 类型占 4 个字节，char 类型占 1 个字节等。系统在内存中，为变量分配存储空间的首个字节单元的地址，称之为该变量的地址。地址用来标识每一个存储单元，方便用户对存储单元中的数据进行正确的访问。在高级语言中地址形象地称为指针。 6.1.1 内存与地址 指针相对于一个内存单元来说，指的是单元的地址，该单元的内容里面存放的是数据。在 C 语言中，允许用指针变量来存放指针，因此，一个指针变量的值就是某个内存单元的地址或称为某内存单元的指针。 6.1.2 内存空间的访问 直接访问：变量代表有名字的内存单元，通过变量名直接访问内存空间。 间接访问：指针是内存空间的地址，通过指针解引用间接访问内存空间。 6.1.3 指针声明 type* pointer_name; // type指明该指针变量的类型 // *说明该变量是一个指针变量 6.1.4 指针大小 int main() { printf(&quot;%u\\n&quot;, sizeof(int*)); printf(&quot;%u\\n&quot;, sizeof(char*)); printf(&quot;%u\\n&quot;, sizeof(float*)); return 0; } 32位平台，占据4byte 64位平台，占据8byte 6.2 指针和指针类型 6.2.1 指针的类型 指针的类型和指针所指向的对象的类型是两个不同的概。 int main() { int a = 100; int* pa = &amp;a; // 其中`*`表示pa是一个指针变量，`int`表示pa是一个int类型指针 return 0; } 指针的大小都是一样的，为什么不创建一个通用类型指针？ 6.2.2 指针类型的意义 指针类型决定了指针解引用的权限（能访问字节的数目） int main() { int a = 0xffffffff; int* pi = &amp;a; // int类型指针 *pi = 1; // 解引用操作四个字节 printf(&quot;%x\\n&quot;, a); // char* pc = &amp;a; // *pc = 1; // printf(&quot;%x\\n&quot;, a); return 0; } int main() { int a = 0xffffffff; // int* pi = &amp;a; // *pi = 1; // printf(&quot;%x\\n&quot;, a); char* pc = &amp;a; // char类型指针 *pc = 1; // 解引用只操作一个字节 printf(&quot;%x\\n&quot;, a); return 0; } 指针类型决定了指针的步长 int main() { int arr[10] = { 0 }; int* pi = arr; char* pc = arr; printf(&quot;%x&quot;, pi); printf(&quot;%x&quot;, pi+1); // int类型指针+1，改变4个字节，步长为4byte printf(&quot;%x&quot;, pc); printf(&quot;%x&quot;, pc+1); // char类型指针+1，改变1个字节，步长为1byte return 0; } 6.2.3 使用 int main() { int arr[10] = { 0 }; int* pa = arr; // 数组名是数组第一个元素的指针 for (int i = 0; i &lt; 10; i++) { *pa = 100; pa++; } for (int i = 0; i &lt; 10; i++) { printf(&quot;%d\\n&quot;, arr[i]); } return 0; } 如果将int类型指针换为char类型指针，如下 6.3 野指针 定义：指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）。 6.3.1 野指针的成因 指针变量未初始化 类似于：去酒店，没有办理入住手续，直接随便找个房间就住。 int main() { int* p; // 局部变量指针未初始化，默认为随机值 *p = 100; return 0; } 指针越界访问 类似于：酒店房间号只有000~100，而你非要去找房间号为111的房间。 int main() { int arr[10] = { 0 }; int* p = arr; for (int i = 0; i &lt;= 10; i++) { *p = i; p++; } } 指针指向的空间释放 类似于：都已经办理退房手续，你仍然要在房间里住。 // 非法访问内存，指针指向的空间不属于该程序 int* func() { int a = 10; return &amp;a; // 函数返回之后，将a的内存空间释放，还给操作系统 } int main() { int* p = func(); *p = 20; return 0; } 6.3.2 如何避免野指针 指针初始化 // 方式一 int* p = NULL // NULL在stdio.h头文件中 // 方式二 int a = 100; int* p = &amp;a; 小心指针越界 // 数组越界 // C语言本身是不会检查数组是否越界 指针指向空间及时置NULL *p = NULL; // 此时p依然不能使用 // 例如： int main() { int* p = NULL; *p = 100; // NULL属于操作系统，空间地址并没有分配给用户，所以用户不能访问 return 0; } 指针使用前检查有效性 int *p = NULL; if(p != NULL){ code... } 6.3.3 实例 #include &lt;stdio.h&gt; main() { int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p = a + 5, *q = NULL; *q = *(p+5); printf(&quot;%d %d\\n&quot;, *p, *q); } // 结果：运行后报错 6.4 指针运算 6.4.1 + - int main() { int arr[5]; int* p; for (p = &amp;arr[0]; p &lt; &amp;arr[5]; ) { *p++ = 0; // 相当于： // *p = 0; // p++; } return 0; } // 随着数组索引增大，地址由低到高变化 6.4.2 &gt; ≥ &lt; ≤ == 指针的关系运算。 // 打印数组中的元素 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int* p = arr; // arr第一个元素的地址 int* pend = p + 4; // arr最后一个元素的地址 while (p&lt;=pend) { printf(&quot;%d\\n&quot;, *p); p++; } return 0; } 6.4.3 指针-指针 两个指针相减的结果是数组中两个元素之间的个数。指针相加是没有意义的（类似日期与日期相加）。 int main() { int arr[10] = { 0 }; printf(&quot;%d\\n&quot;, &amp;arr[9]-&amp;arr[0]); return 0; } 指针相减的前提：两个指针指向同一块区域。 6.4.4 应用（求字符串长度len） 方法一：库函数 #include &lt;string.h&gt; int main() { char s[] = &quot;Hello&quot;; int len = strlen(s); printf(&quot;%d\\n&quot;, len); } 方法二：计数器 int my_strlen(char* p) { int count = 0; while (*p != '\\0') { count++; p++; } return count; } int main() { char s[] = &quot;Hello&quot;; int len = my_strlen(s); // 传参时，传递的是字符串的第一个字符的地址 printf(&quot;%d\\n&quot;, len); } 方法三：指针相减 int my_strlen(char* p) { char* p0 = p; while (*p != '\\0') { p++; } return p - p0; } int main() { char s[] = &quot;Hello&quot;; int len = my_strlen(s); // 传参时，传递的是字符串的第一个字符的地址 printf(&quot;%d\\n&quot;, len); } 6.4.4 其他 for(vp = &amp;values[N_VALUES-1]; vp &gt;= &amp;values[0]; vp--) { *vp = 0; } // 在大部分的编译器上可以正常运行，然而应避免这样编码，因为标准并不保证它可行。 标准规定 允许指向数组元素的指针与指向数组最后一个元素后面的哪个内存位置的指针比较，但不允许与指向第一个元素之前的那个内存位置的指针进行比较。 6.5 指针和数组 6.5.1 数组名是数组首元素的地址 int main() { int arr[5] = { 0 }; printf(&quot;%p\\n&quot;, arr); printf(&quot;%p\\n&quot;, &amp;arr[0]); return 0; } 6.5.2 通过指针操作数组元素 int main() { int arr[5] = { 0 }; int* p = arr; for (int i = 0; i &lt; 5; i++) { *(p + i) = i; } for (int i = 0; i &lt; 5; i++) { printf(&quot;%d\\n&quot;, *(p+i)); } } 6.5.3 下标引用操作符的交换律 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int* p = arr; // 访问下标为3的元素的底层原理： // arr[3] =&gt; *(p+3) // 根据加法的交换律，可得 // *(p+3) = *(3+p) // 则 // arr[3] = 3[arr]; // []下标引用操作符也具有交换律 printf(&quot;%d\\n&quot;, arr[3]); printf(&quot;%d\\n&quot;, 3[arr]); printf(&quot;%d\\n&quot;, p[3]); printf(&quot;%d\\n&quot;, 3[p]); } 6.6 二级指针 6.6.1 创建 int main() { int n = 100; int* pn = &amp;n; // 一级指针 int** ppn = &amp;pn; // 二级指针 } // 依次类推，还有三级、四级... // 指针变量中存储了地址，跟普通变量一样，需要开辟一块内存空间用来存放数据 // 而指针变量所在的地址，用二级指针来表示 // pnn中存放的是pn的地址 // pn中存放的是n的地址 // n中存放的是数据 6.6.2 访问 int main() { int n = 100; int* pn = &amp;n; // 一级指针 int** ppn = &amp;pn; // 二级指针 // *pnn = pn; // *pn = n; // 所以：**pnn = n; 即通过**pnn即可访问变量n } 6.7 指针数组 int arr1[10]; // 整形数组 float arr2[10]; // 浮点型数组 char arr3[10]; // 字符型数组 int* parr1[10]; // 整形指针数组 float* parr2[10]; // 浮点型指针数组 char* parr3[10]; // 字符型指针数组 ","link":"https://listen2022.github.io/6-c-yu-yan-zhi-zhen/"},{"title":"5. C语言--操作符","content":"5.操作符 5.1 算术操作符 + - * / % 除%操作符之外，其他几个操作符可以作用于整数和浮点数。 对于/操作符如果两个操作符都为整数，执行整数除法。只要有一个浮点数，则执行浮点数除法。 float num = 1 / 2; // num=0.000000; float num = 1 / 2.0; // num=0.500000; // 这里的2.0 是double类型 而num为float类型 // 可以做如下调整 float num = 1f / 2.0f; double num = 1 / 2.0; %操作符两端必须都是整数，可以是负数，但不能为0。 5.2 移位操作符 &gt;&gt; &lt;&lt; 5.2.1 非负整数的二进制表示形式 原码：直接根据数值写出二进制 反码：原码符号位不变，其他位按位取反 补码：反码加1 // 非负整数在内存中存放的是原码（非负整数的原码、反码、补码相同） // 负整数在内存中存放的是补码 5.2.2 左移 算数左移和逻辑左移相同，都是左边抛弃，右边补0。 5.2.3 右移 算术右移（通常采用） 向右移动，首位补原二进制位的第一位 逻辑右移 向右移动，首位补0 // 只能移动非负整数位 int main() { int ret = -1 &gt;&gt; 1; printf(&quot;%d\\n&quot;, ret); return 0; } 5.3 位操作符 &amp; | ^ // 操作数必须为整数 5.3.1 按位与 int main() { int ret = 3 &amp; 4; // 00000000000000000000000000000011 // &amp; // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } 5.3.2 按位或 // 按位或 int main() { int ret = 3 | 4; // 00000000000000000000000000000011 // | // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } 5.3.3 按位异或 相同为0，相异为1 int main() { int ret = 3 ^ 4; // 00000000000000000000000000000011 // ^ // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } // 奇数^奇数=偶数 // 奇数^偶数=奇数 // 偶数^偶数=偶数 5.3.4 题目 交换两个int变量的值，不使用第三个变量 方法一 int main() { int a = 3; int b = 4; a = a + b; b = a - b; a = a - b; printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } // 问题：数字过大，内存溢出 方法二 int main() { int a = 3; int b = 4; a = a ^ b; b = a ^ b; a = a ^ b; printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } // 没有进位，不可能发生溢出 // 异或特点： // 1.任何数和他本身异或，结果为0 // 2.任何数和0异或，结果为他本身 // 底层逻辑： // b = a ^ b ^ b = a (前两行代码) // a = a ^ b ^ b ^ a ^ b = b (第三行代码) 5.3.5 练习 编写代码实现：求一个整数存储在内存中的二进制中1的个数 方法一 int main() { int num = 5; int count = 0; for (int i = 0; i &lt; 32; i++) { if (num % 2 == 1) { count++; } num = num &gt;&gt; 1; } printf(&quot;count=%d\\n&quot;, count); return 0; } 缺点：不能统计负数的二进制中1的个数。 方法二 int main() { int num = -5; int count = 0; for (int i = 0; i &lt; 32; i++) { if ((num &gt;&gt; i) &amp; 1) { count++; } } printf(&quot;count=%d\\n&quot;, count); return 0; } // -5 // 原码 10000000000000000000000000000101 // 补码 11111111111111111111111111111011 // 右移0位 // 11111111111111111111111111111011 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 // 右移一位 // 01111111111111111111111111111101 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 // 右移二位 // 00111111111111111111111111111110 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000000 -&gt; 0 // ... // 右移31位 // 00000000000000000000000000000001 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 方法三 int main() { int num = -5; int count = 0; while (num) { num = num &amp; (num - 1); count++; } printf(&quot;count=%d\\n&quot;, count); return 0; } // num &amp; (num - 1) // 11111111111111111111111111111011 =&gt; num // 11111111111111111111111111111011 &amp; (11111111111111111111111111111011 - 1) // 11111111111111111111111111111011 &amp; 11111111111111111111111111111010 // 11111111111111111111111111111010 =&gt; num // 11111111111111111111111111111010 &amp; (11111111111111111111111111111010 - 1) // 11111111111111111111111111111010 &amp; 11111111111111111111111111111001 // 11111111111111111111111111111000 =&gt; num // ... // 每次把num&amp;(num-1)的结果再赋值给num // 每num&amp;(num-1)运算一次，就会将num中的1变成0 // 通过n次num&amp;(num-1)运算使得num=0 // 此时n为num的二进制中1的个数 5.4 赋值操作符 = += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= |= ^= // 连续赋值： int a = 0; int b = 0; int c = 1; a = b = c + 1; // 从由向左赋值（不推荐） 5.5 单目操作符 只有一个操作数 ! // 逻辑反操作 - // 负 + // 正 sizeof // 操作数类型长度 ~ // 按位取反 -- // 前置 后置 ++ // 前置 后置 * // 解引用(间接访问)操作符 &amp; // 取址 (type) // 强制类型转换 5.5.1 sizeof sizeof是一个操作符，不是函数。单位：字节 例1 int main() { short s = 5; int a = 10; printf(&quot;%d\\n&quot;, sizeof(s = a + 2)); // sizeof括号中放的表达式，不参与运算 // 在编译期间处理sizeof(s = a + 2); 而s = a + 2在程序运行时计算 // 大数据放在小空间里被截断 printf(&quot;%d\\n&quot;, s); // 5 return 0; } 例2 int main() { int a = 10; printf(&quot;%d\\n&quot;, sizeof(a)); printf(&quot;%d\\n&quot;, sizeof a); printf(&quot;%d\\n&quot;, sizeof(int)); //printf(&quot;%d\\n&quot;, sizeof int); char arr[10] = { 0 }; printf(&quot;%d\\n&quot;, sizeof(arr)); printf(&quot;%d\\n&quot;, sizeof arr); printf(&quot;%d\\n&quot;, sizeof(char [10])); } 例3 void foo1(int arr[10]) { printf(&quot;%d\\n&quot;, sizeof(arr)); } void foo2(char arr[10]) { printf(&quot;%d\\n&quot;, sizeof(arr)); } int main() { int arr1[10] = { 0 }; char arr2[10] = { 0 }; printf(&quot;%d\\n&quot;, sizeof(arr1)); // 40 printf(&quot;%d\\n&quot;, sizeof(arr2)); // 10 foo1(arr1); // 4或8 foo2(arr2); // 4或8 return 0; } // 数组作为函数参数传递时，实际传递的是数组的指针 5.5.2 ~ 按位取反 int main() { int a = 13; // 00000000000000000000000000001101 // 将a的二进制位第五位置零 // 00000000000000000000000000001101 -&gt; 13的二进制 // 00000000000000000000000000010000 -&gt; 1&lt;&lt;4 // | -&gt; 按位或 // 00000000000000000000000000011101 -&gt; 结果29 a = a | (1 &lt;&lt; 4); printf(&quot;%d\\n&quot;, a); // 将a的二进制位第五位置一 // 00000000000000000000000000011101 -&gt; 29的二进制 // 11111111111111111111111111101111 -&gt; ~(1&lt;&lt;4) // &amp; -&gt; 按位与 // 00000000000000000000000000001101 -&gt; 结果13 a = a &amp; (~(1 &lt;&lt; 4)); printf(&quot;%d\\n&quot;, a); return 0; } 5.5.3 ++/— // 前置：先++，再使用 // 后置：先使用，再++ // (使用包括赋值和函数传参) 后++ 先++ 垃圾代码 int main() { int a = 1; int b = (++a) + (++a) + (++a); printf(&quot;%d\\n&quot;, b); return 0; } // 运行结果：vs2019中结果是12 // linux中结果是10 // 垃圾代码，不做过多研究 5.5.4 &amp; * &amp; // 取址 * // 解引用 例 int main() { int num = 100; // &amp;获取对象所处的内存地址，取址操作符 int* pn = &amp;num; // 此处*不是操作符，仅说明pn是一个指针变量 *pn = 200; // 此处*才是解引用操作符，将200赋值给pn所指的对象 printf(&quot;pn=%p, num=%d\\n&quot;, pn, num); return 0; } 5.5.5 (type) int main() { int num = (int)3.1315; // 强制类型转换 printf(&quot;%d\\n&quot;, num); return 0; } 5.6 关系操作符 &gt; &gt;= &lt; &lt;= != == // = 赋值 // == 判断是否相等 // 比较两个字符串是否相等不能使用== 5.7 逻辑操作符 &amp;&amp; 逻辑与：从前往后找到第一个为假的值返回0，否则返回1 || 逻辑或：从前往后找到第一个为真的值返回1，否则返回0 5.7.1 习题 如下代码运行结果： int main() { int i = 0, a = 0, b = 2, c = 3, d = 4; i = a++ &amp;&amp; ++b &amp;&amp; d++; //i = a++ || ++b || d++; printf(&quot;a=%d, b=%d, c=%d, d=%d\\n&quot;, a, b, c, d); } // &amp;&amp;: 左边确定为假，后边不用再进行计算 // ||: 左边确定为真，后边不用再进行计算 5.8 三目操作符 exp1 ? exp2 : exp3; // 如果exp1为真，则计算exp2，整个表达式的结果为exp2的结果，exp3不计算 // 如果exp2为假，则计算exp3，整个表达式的结果为exp3的结果，exp2不计算 例 int main() { int a = 3; int b = 4; int ret = 0; ret = a &gt; b ? a++ : b++; printf(&quot;%d\\n&quot;, ret); printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } 5.8 逗号表达式 exp1, exp2, exp3; // 从前往后依次执行，整个表达式的结果为最后一个表达式exp3的计算结果 5.9 下标引用 下标引用操作符有两个操作数，数组名和下标。 int main() { int arr[10] = { 0 }; // 此处[]不是操作符，仅用来指定数组的大小 arr[4] = 100; // 此处[]为操作符，指定数组中索引(或下标)为4的值为100 printf(&quot;arr[4]=%d\\n&quot;, arr[4]); return 0; } 5.10 函数调用 有一个或多个操作数，当没有参数时，只有函数名一个操作数；当有参数时，操作时个数为参数个数+1。 // 函数调用 int Add(int x, int y) // 此处()不是操作符，仅用来说明形参及其类型 { return x + y; } int main() { int ret = Add(3, 4); // 此处()为函数调用操作符，即使没有参数，也要有() 操作数：Add 3 4共3个 printf(&quot;%d\\n&quot;, ret); return 0; } 5.11 结构成员访问操作符 . -&gt; // 使用格式： 结构体变量.结构体成员变量名 结构体指针变量-&gt;结构体成员变量名 例 int main() { struct Person { char name[10]; int age; float height; }; printf(&quot;.操作符\\n&quot;); struct Person p = { &quot;listen&quot;, 22, 185.0 }; printf(&quot;name: %s\\n&quot;, p.name); printf(&quot;age: %d\\n&quot;, p.age); printf(&quot;height: %f\\n&quot;, p.height); struct Person* pp = &amp;p; printf(&quot;name: %s\\n&quot;, (*pp).name); printf(&quot;age: %d\\n&quot;, (*pp).age); printf(&quot;height: %f\\n&quot;, (*pp).height); printf(&quot;-&gt;操作符\\n&quot;); printf(&quot;name: %s\\n&quot;, pp-&gt;name); printf(&quot;age: %d\\n&quot;, pp-&gt;age); printf(&quot;height: %f\\n&quot;, pp-&gt;height); return 0; } 5.12 表达式求值 表达式求值的顺序一般是由操作符的优先级和结合性决定。同样，有些表达式的操作数再求值的过程中可能需要转换为其他类型。 5.12.1 隐式类型转换 C的整形算数运算总是至少以缺省整形类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换称为整形提升。 包括： 整形提升 算数转换 5.12.2 整型提升 概念 在表达式计算时，各种整形（只有比int小的类型才会发生整型提升）首先要提升为int类型，如果int类型不足以表示的话，就需要提升为unsigned int类型，然后再执行表达式的运算。 意义 虽然机器指令中可能有现两个8比特字节这种字节相加指令，但是一般用途的CPU是难以直接实现这样的字节相加运算的。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。而表达式的整型运算要在CPU的相应运算器件内执行。因此，两个char类型的数进行相加运算时，是在CPU中执行，自然而然的需要先转换为CPU内整型操作数的标准长度。 如何提升 按照最高位进行整型提升 正数整型提升：高位补0 负数整形提升：高位补1 无符号整数整形提升：高位补0 例1 int main() { char a = 3; char b = 127; char c = a + b; printf(&quot;%d\\n&quot;, c) return 0; } // 原理 char a = 3; //二进制： 00000011 char b = 127; //二进制：01111111 char c = a + b; // + 操作符 整型提升 //a 提升： 00000000000000000000000000000011 //b 提升： 00000000000000000000000001111111 // 相加： 00000000000000000000000010000010 //c 截断： 10000010 printf(&quot;c=%d\\n&quot;, c); // c是char类型，而使用%d打印，c 整形提升(高位补1) // 11111111111111111111111110000010 补码 // 11111111111111111111111110000001 反码（补码-1） // 10000000000000000000000001111110 原码（反码符号位不变，其余位取反） 例2 int main() { char a = 0xFF; // a整形提升之后为11111111111111111111111111111111 short b = 0xFFFF; // b整形提升之后为11111111111111111111111111111111 int c = 0xFFFFFFFF; if (a == 0xFF) { printf(&quot;a\\n&quot;); } if (b == 0xFFFF) { printf(&quot;b\\n&quot;); } if (c == 0xFFFFFFFF) { printf(&quot;c\\n&quot;); } printf(&quot;%d\\n&quot;, a == b); return 0; } // 其中a, b需要进行整形提升，而c不需要整形提升 // a, b整形提升之后变成了负数，所以a==0xFF和b == 0xFFFF为假 例3 int main() { char a = 1; printf(&quot;%u\\n&quot;, sizeof a); printf(&quot;%u\\n&quot;, sizeof -a); // 类型提升为int类型 printf(&quot;%u\\n&quot;, sizeof +a); printf(&quot;%u\\n&quot;, sizeof !a); // vs2022中为1 gcc中为4 return 0; } 5.12.3 算数转换 如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转化为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换。 long double double float unsigned long int long int unsigned int int 如果某个操作数的类型在上面这个列表中排名较低，那么首先要转化为另一个操作数的类型后执行运算。 例 int main() { float a = 1.23; int b = 5; float c = 0; c = a + b; // a为float类型，b为int类型， // float类型值和int类型值相加时， // int类型值被转换为float类型 printf(&quot;%f\\n&quot;, c); return 0; } 5.13 表达式的属性 值属性(运行后才能确定) 类型属性(可推断，编译时确定) 5.14 操作符的属性 复杂表达式的求值有三个影响的因素： 操作符的优先级 操作符的结合性 是否控制求值顺序（例如&amp;&amp; || ,） 5.14.1 优先级 运算符的优先级确定表达式中项的组合。如果优先级相同，则根据结合性确定计算顺序。 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= = 逗号 , 从左到右 5.14.2 一些问题表达式 表达式1 a * b + c * d + e * f; // 计算原理： // 方法1： a * b; c * d; e * f; a * b + c * d + e * f // 方法2： a * b; c * d; a * b + c * d; e * f; a * b + c * d + e * f; 表达式2 c + --c; // 无法确定左操作数是在--c之前还是--c之后确定 // 计算原理： // 方法1： --c; c; c + --c; // 方法2： c; --c; c + --c; 代码3-错误代码 int main() { int i = 10; i = i-- - --i * (i = -3) * i++ + ++i; printf(&quot;i = %d\\n&quot;, i); return 0; } // 输出结果在不同的编译器中结果不同 代码4- 错误代码 int fun() { static int count = 1; return ++count; } int main() { int answer; answer = fun() - fun() * fun(); // 2 - 3 * 4 (vs2022中) printf(&quot;%d\\n&quot;, answer); // -10(vs2022中) return 0; } // 结果不可控，fun()函数的调用顺序不同，结果不同 代码5-错误代码 int main() { int i = 1; int ret = (++i) + (++i) + (++i); printf(&quot;%d\\n&quot;, ret); } // VS -&gt; 12 // 执行原理 ++i; ++i; ++i; i = 4 4 + 4 + 4; // gcc -&gt; 10 ++i; ++i; i = 3; 3 + 3; ++i; i = 4; 3 + 3 + 4; 5.14.3 总结 对于同一个表达式或一段代码，即使有确定的优先级和结合性，仍然有不确定的计算或运行方式，且不同方式计算出来的结果不同，则该表达式或代码是存在问题的，不应该使用这样的表达式和代码。 ","link":"https://listen2022.github.io/5-c-yu-yan-cao-zuo-fu/"},{"title":"4. C语言--数组","content":"4.数组 数组是一组相同类型元素的集合。 4.1 一维数组的创建和初始化 4.1.1 创建 // 格式： type_t arr_name [const_n] // type_t 数组元素类型 // arr_name 数组名称 // const_n 常量表达式，指定数组大小 // 在VS2019、VS2022中不支持变长数组 // 在gcc编译器中支持 // 创建 int arr[10]; 4.1.2 初始化 int main() { int arr1[3] = {0, 1, 2}; // 完全初始化 int arr2[3] = {1, 2}; // 不完全初始化 int arr3[] = { 2, 4, 6, 8 }; // 自动确定数组长度 int arr4[5] = { 2, 4, 6, 8 }; // 与上一条语句等价 int arr5[10] = { 0 } // 不完全初始化，不是把10个元素全初始化为0 int arr6[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } char ch1[5] = &quot;ccc&quot;; // 'c' 'c' 'c' '\\0' 0 char ch2[] = &quot;ccc&quot;; // 'c' 'c' 'c' '\\0' char ch3[] = { 'c', 'c', 'c' }; // 'c' 'c' 'c' printf(&quot;%s\\n&quot;, ch1); printf(&quot;%s\\n&quot;, ch2); printf(&quot;%s\\n&quot;, ch3); return 0; } 4.2 一维数组的使用 4.2.1 获取 [] // 下标引用操作符 int arr[5] = { 1, 2, 3, 4, 5 }; arr[3]; // 获取数组arr中下标为3的元素的值 4.2.2 赋值 arr[3] = 444; 4.2.3 数组中元素的个数 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int size = sizeof(arr) / sizeof(arr[0]); // 获取数组中元素的个数 // sizeof(arr)获取的是整个数组的大小，单位是字节 printf(&quot;%d\\n&quot;, size); } 4.3 一维数组在内存中的存储 4.3.1 %x和%p的区别 int main() { printf(&quot;%x\\n&quot;, 0x5f); printf(&quot;%p\\n&quot;, 0x5f); return 0; } // 指针是有长度的 4.3.2 存储方式 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; for (int i = 0; i &lt; 5; i++) { printf(&quot;&amp;arr[%d] =&gt; %p\\n&quot;, i, &amp;arr[i]); } } // 现象：下标每增加1，地址变化4字节，刚好是int类型的大小 // 结论： // 一维数组在内存中是连续存放的 // 随着数组下标的增长，地址是由低到高变化 4.3.3 应用 // 对于int指针，p++，每次增加int类型的字节数(4byte) // 对于char指针，p++，每次增加char类型的字节数(1byte) 4.4 二维数组的创建和初始化 int main() { // 创建 int arr[3][4]; // 三行四列 char ch[3][4]; double dou[3][4]; // 初始化 int arr1[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; // 完全初始化 int arr2[3][4] = { {1, 2},{3, 4},{5, 6} }; // 每行初始化 int arr3[][4] = { {1, 2},{3, 4},{5, 6} }; // 省略行(但不能省略列) int ch[3][4] = {'h','e','l','l','o'}; // 不完全初始化 return 0; } 4.5 二维数组的使用 int main() { int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; for (int i = 0; i &lt; 3; i++) { for ( int j=0; j&lt;4; j++) { printf(&quot;%d &quot;, arr[i][j]); } printf(&quot;\\n&quot;); } return 0; } 4.6 二维数组在内存中的存储 int main() { int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 4; j++) { printf(&quot;arr[%d][%d]=%p\\n&quot;, i, j, &amp;arr[i][j]); } } return 0; } // 现象：每个元素相差4byte，恰好是int类型的大小 // 二维数组在内存中连续存放 4.7 数组作为函数参数 4.7.1 数组名 数组名是数组首元素的地址。 例外 sizeof(arr)获取的是整个数组的长度，单位：byte。 &amp;arr获取的是整个数组的地址。 int main() { int arr[5] = { 0 }; printf(&quot;arr =&gt; %p\\n&quot;, arr); printf(&quot;arr =&gt; %p\\n&quot;, arr+1); printf(&quot;&amp;arr =&gt; %p\\n&quot;, &amp;arr); printf(&quot;&amp;arr =&gt; %p\\n&quot;, &amp;arr+1); printf(&quot;&amp;arr[0] =&gt; %p\\n&quot;, &amp;arr[0]); printf(&quot;&amp;arr[0] =&gt; %p\\n&quot;, &amp;arr[0]+1); return 0; } 4.7.2 冒泡排序 // 两两相邻元素进行比较 void bubble_sort(int arr[], int count) // 形参arr本质是指针 { int i = 0; // 确定趟数 for ( i = 0; i &lt; count; i++) { int j = 0; // 每趟比较元素的次数 for ( j = 0; j &lt; count-1-i; j++) { if (arr[j] &gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } } int main() { int arr[] = { 1, 6, 3, 9, 4 }; int count = sizeof(arr) / sizeof(arr[0]); // 确定数组元素个数 bubble_sort(arr, count); // 数组在传参时，传递的时arr首元素的地址 for (int i = 0; i &lt; count; i++) // 打印排序结果 { printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); } return 0; } 4.8 练习 4.8.1 逆序数组中元素个数 void reverse(int arr[], int size) { int left = 0; int right = size-1; while (left&lt;right) { int tmp = 0; tmp = arr[right]; arr[right] = arr[left]; arr[left] = tmp; left++; right--; } } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int size = sizeof(arr) / sizeof(arr[0]); reverse(arr, size); return 0; } 4.8.2 交换数组 将数组A中的内容和数组B中的内容进行交换（数组一样大） int main() { int arr1[3] = { 1, 2, 3 }; int arr2[3] = { 4, 5, 6 }; // 错误操作： //int arr3[3] = { 0 }; //arr3 = arr2; //arr2 = arr1; //arr1 = arr2; // 元素可以相互赋值，但数组名不可以相互赋值，因为数组名是数组首元素的地址 // // 正确操作： int size = sizeof(arr1) / sizeof(arr1[0]); for (int i = 0; i &lt; size; i++) { int tmp = 0; tmp = arr1[i]; arr1[i] = arr2[i]; arr2[i] = tmp; } return 0; } 4.9 实例 4.9.1 三子棋 4.9.2 扫雷 ","link":"https://listen2022.github.io/4-shu-zu/"},{"title":"3. C语言--函数","content":"3.函数 3.1 函数是什么 函数是指一段可以直接被另一段程序或代码引用的程序或代码。也叫做子程序、（OOP中）方法。一个较大的程序一般应分为若干个程序块，每一个模块用来实现一个特定的功能。所有的高级语言中都有子程序这个概念，用子程序实现模块的功能。在C语言中，子程序是由一个主函数和若干个函数构成的。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。 3.1.1 函数分类 自定义函数 库函数 3.2 库函数 一般是指编译器提供的可在C源程序中调用的函数。分为两类，C语言标准规定的库函数和编译器特定的库函数。 3.2.1 网站 Learn C and C++ Programming - Cprogramming.com C 标准库头文件 - cppreference.com https://docs.microsoft.com/en-us/cpp/c-runtime-library/c-run-time-library-reference?view=msvc-170 3.2.2 strcp 3.2.3 memset 3.3 自定义函数 // 格式： ret_type func_name( parameter list ) { body of the function } // return_type 函数的返回类型 // function_name 函数名称 // parameter list 参数列表 // body of the function 函数体 // 当函数不返回任何类型，ret_type为关键字void 实例 void Swap(int* pa, int* pb) { int z = 0; z = *pa; *pa = *pb; *pb = z; } int main() { int a = 10; int b = 20; printf(&quot;交换前 a=%d, b=%d\\n&quot;, a, b); Swap(&amp;a, &amp;b); printf(&quot;交换后 a=%d, b=%d\\n&quot;, a, b); } 重点 void Swap(int* pa, int* pb) { int* z = NULL; printf(&quot;%p %p %p\\n&quot;, pa, pb, z); z = pa; pa = pb; pb = z; printf(&quot;%p %p %p\\n&quot;, pa, pb, z); } // 不能通过交换a、b的地址交换a、b的数据 int main() { int a = 10; int b = 20; printf(&quot;交换前 a=%d, b=%d\\n&quot;, a, b); Swap(&amp;a, &amp;b); printf(&quot;交换后 a=%d, b=%d\\n&quot;, a, b); } 3.4 函数参数 3.4.1 实际参数(argument) 真实传递给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在进行调用时，它们都必须有确定的值，以便把这些值传送给形参。 3.4.2 形式参数(parameter) 形式参数是指函数名后括号中的变量，因为形参只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成后就自动销毁。因此形式参数只在函数中有效。 3.4.3 形参实例化之后其实相当于实参的一份临时拷贝。 3.5 函数调用 3.5.1 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 3.5.2 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 3.6 函数的嵌套调用和链式访问 3.6.1 嵌套调用 在函数A()中调用函数B() #include &lt;stdio.h&gt; int main() { printf(&quot;Hello World!\\n&quot;); return 0; } // 最简单的嵌套调用，在main函数中调用prinf函数 3.6.2 链式访问 把一个函数的返回值作为另一个函数的参数。 #include &lt;stdio.h&gt; int add(int x, int y) { return x + y; } int main() { printf(&quot;输出：%d\\n&quot;, add(3, 4)); } // 将add(3, 4)的返回值作为参数，传递给printf函数 3.7 函数的声明和定义 3.7.1 声明 告诉编译器函数名称及如何调用函数。 return_type function_name( parameter list ); // 在函数声明中 // 参数的名称并不重要 // 只有参数的类型是必需的 // 因此可省略声明中形参的名称 3.7.2 定义 return_type function_name( parameter list ) { body of the function } 3.8 函数递归 函数对自身的调用。 递归的必要条件 递归调用的过程 递归终止的条件 3.9 小知识 #include &quot; &quot; 与 &lt;&gt;有什么区别？ // 若 #include &quot;&quot; 查找成功，则遮蔽 #include &lt;&gt; 所能找到的同名文件 // 否则再按照 #include &lt;&gt; 的方式查找文件 // #include &lt;&gt; 的查找位置是标准库头文件所在目录 // #include &quot;&quot; 的查找位置是当前源文件所在目录 // &lt;&gt;先去系统目录中找头文件，如果没有在到当前目录下找 // &quot;&quot;首先在当前目录下寻找，如果找不到，再到系统目录中寻找 C语言函数默认返回类型 // C语言中函数如果没有定义返回值类型，则默认返回类型是int ","link":"https://listen2022.github.io/3-han-shu/"},{"title":"2.C语言--分支和循环语句","content":"2.分支和循环语句 2.1 分支语句 C语言把任何非零和非空的值假定为 true，把零或 null 假定为 false 2.1.1 if else if语句 if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } if...else... if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } else { /* 如果布尔表达式为假将执行的语句 */ } if...else if...else... 一个if后可跟一个或零个else语句，else必须在所有else if之后 一个if后可跟多个或零个else if语句，else if必须在else之前 一旦某个else if匹配成功，其他的else if或else将不会被测试 if(boolean_expression1) { /* 当布尔表达式1为真时执行 */ } else if(boolean_expression2) { /* 当布尔表达式2为真时执行 */ } else if(boolean_expression3) { /*当布尔表达式3为真时执行*/ } else { /* 当上面条件都不为真时执行 */ } 嵌套if语句 if( boolean_expression1) { /* 当布尔表达式1为真时执行 */ if(boolean_expression2) { /* 当布尔表达式2为真时执行 */ } } // 可以在一个if...else...或if...else if...else..语句中 // 嵌套一个if...else...或if...else if...else..语句 2.1.2 switch switch switch(expression){ case constant-expression : statement(s); break; /* 可选 */ case constant-expression : statement(s); break; /* 可选 */ default : /* 可选 */ statement(s); } expression为常量表达式，必须是一个整形或枚举类型 constant-expression必须和expression的数据类型相同，且为一个常量或字面量 当被测试的变量等于case中的常量时，case后面的语句执行，直到遇到break语句 default case中的break语句不是必须的 default语句可以放在任意位置 嵌套switch 一个switch语句种包含另一个switch语句 switch(expression1) { case constant-expression: switch(expression2) { case constant-expression: ... break; case constant-expression: ... } break; case constant-expression: ... } 2.1.3 :?运算符(三目运算符) Exp1 ? Exp2 : Exp3; // ? 表达式的值是由 Exp1 决定的。 // 如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值 // 如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值 2.2 循环语句 2.2.1 for for ( init; condition; increment ) { statement(s); } // init: 首先执行，声明并初始化循环控制变量，可留空 // condition: 判断，如果为真，执行statement(s)，否则结束循环 // increment: 执行完for循环主体statement(s);之后，执行increment语句。该语句一般是更新循环控制变量，可留空 2.2.2 while while(condition) { statement(s); // 一条语句或语句块 } 2.2.3 do while for和while循环在循环开始时测试循环条件，而do...while...在每次循环中执行statement(s)语句之后，测试循环条件。 do { statement(s); }while( condition ) // statement(s);至少被执行一次 2.2.4 嵌套循环 嵌套for循环 for (initialization; condition; increment/decrement) { statement(s); for (initialization; condition; increment/decrement) { statement(s); } } 嵌套while循环 while (condition1) { statement(s); while (condition2) { statement(s); } } 嵌套 do while 循环 do { statement(s); do { statement(s); }while (condition2); }while (condition1) 混合嵌套 2.3 循环控制语句 2.3.1 break 终止循环或switch语句。在嵌套语句中，终止break所在的最内层的循环或switch语句。 2.3.2 continue 结束本次循环，进行下一次迭代。 2.3.3 goto 控制转移到被标记的语句。但是不建议在程序中使用goto语句（使得程序的控制流难以跟踪，使程序难以理解和难以修改）。 goto label; ... ... label: statement; // goto语句只能在一个函数范围内跳转，不能跨函数 // 一般不使用，跳出多层嵌套时使用 2.4 无限循环 for( ; ; ) { ... } // 倾向于使用该语句实现无限循环 2.3 习题 2.3.1 最大公约数 最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。 一般方法 int main() { int a = 12; int b = 16; int max = a; // 为a、b中较小的一个赋值给最大公约数 if (max &gt; b) { max = b; } for (; max &gt;= 1 ; max--) { if (a % max == 0 &amp;&amp; b % max == 0) { printf(&quot;%d\\n&quot;, max); break; } } return 0; } 辗转相除法 欧几里得算法：gcd(a, b) = gcd(b, a mod b) int main() { int a = 12; int b = 16; int t = 0; while (t = a % b) { a = b; b = t; } printf(&quot;%d&quot;, b); return 0; } 2.3.2 最小公倍数 两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。 一般方法 int main() { int a = 12; int b = 16; int min = a; // 存放a、b中较大值 if (min&lt;b) { min = b; } for ( ; ; min++) { if (min % a == 0 &amp;&amp; min % b == 0) { printf(&quot;%d&quot;, min); break; } } return 0; } 公式法 最小公倍数 × 最大公约数 = a × b int main() { int a = 12; int b = 16; int mul = a * b; // a和b的乘积 int t = 0; while (t = a % b) { a = b; b = t; } printf(&quot;%d&quot;, mul / b); return 0; } 2.3.3 排序 问题描述：给定三个数，从大到小输出 int main() { int a = 3; int b = 8; int c = 5; if (a &lt; b) { int t = a; a = b; b = t; } if (a &lt; c) { int t = a; a = c; c = t; } if (b &lt; c) { int t = b; b = c; c = t; } printf(&quot;%d %d %d&quot;, a, b, c); return 0; } 2.3.4 闰年 闰年（Leap Year）是为了弥补因人为历法规定造成的年度天数与地球实际公转周期的时间差而设立的。补上时间差的年份为闰年。闰年共有366天（1月~12月分别为31天、29天、31天、30天、31天、30天、31天、31天、30天、31天、30天、31天）。 规则：四年一闰，百年不闰，四百年再闰。 方法一： int main() { int sum = 0; for (int i = 0; i &lt;= 2050; i++) { if ( 0 == i % 4) { if (0 == i % 100) { if (0 == i % 400) { printf(&quot;%d\\n&quot;, i); } } else { printf(&quot;%d\\n&quot;, i); } } } return 0; } 方法二： int main() { int sum = 0; for (int i = 0; i &lt;= 2050; i++) { if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || (i % 400 == 0 )) { printf(&quot;%d是闰年\\n&quot;, i); sum++; } } printf(&quot;sum = %d\\n&quot;, sum); } 2.3.5 素数(质数) 在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 int main() { for (int i = 2; i &lt;= 100; i++) { int j = i - 1; for ( ; j&gt;=1; j-- ) { if (0 == i % j) { break; } } if (j == 1) { printf(&quot;%d\\n&quot;, i); } } } 优化： int main() { for (int i = 2; i &lt;= 100; i++) { int flag = 1; // flag=1时为素数 int j = 2; for ( ; j*j &lt;= i ; j++) { if (0 == i % j) { flag = 0; // flag为0时不为素数 break; } } if (flag) { printf(&quot;%d\\n&quot;, i); } } } 2.3.6 goto使用 # Windows关机命令 shutdown -s -t 60 # 设置关机 shutdown -a # 取消关机 // C语言中使用system(&quot;&quot;)执行系统命令 // system()函数在&lt;stdlib.h&gt;头文件中 // C语言中两个字符串不能使用`==`比较大小 // 可使用strcmp(str1, str2)函数 // 字符串相等函数返回0，该函数在&lt;string.h&gt;头文件中 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char input[20] = { 0 }; Lable: system(&quot;shutdown -s -t 60&quot;); printf(&quot;电脑将在1min之后关机，请输入密码进行取消：&quot;); scanf(&quot;%s&quot;, input); if (0 == strcmp(input, &quot;123&quot;)) { system(&quot;shutdown -a&quot;); } else { goto Lable; } return 0; } 小问题 #define _CRT_SECURE_NO_WARNINGS // 源文件第一行（忽略VS的安全检测） ","link":"https://listen2022.github.io/2fen-zhi-he-xun-huan-yu-ju/"}]}