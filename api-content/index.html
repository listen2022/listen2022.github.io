{"posts":[{"title":"2022","content":"2022年度规划 22年目标 考研成功 学会自律 感情顺利 坚持运动 考研目标：深圳大学 自律 自律 自律 做自己 日安排 周安排 月安排 寒假（2月1号周二—2月17号周四 共16天） 安排 | 日期 | 安排 | | ------ | ------ | | 1-2号 | 心态调整 | | 3-10号 | | | 10-17号 | | | 17-20号 | 开学准备 | 目标： 结束C语言、操作系统、计算机组成原理 每天25min跑步（天晴） gitee上每天一个绿点 牛客网C语言：5道选择和1道编程题 ","link":"https://listen2022.github.io/6Tad6moOG/"},{"title":"10. C语言进阶--指针进阶","content":"2. 指针进阶 2.1 字符指针 2.1.1 介绍 char c = 'h'; char* pc = &amp;c; // 访问权限为1bbyte // ++/--为1byte 2.1.2 例 int main() { char str1[] = &quot;Hello World!&quot;; char str2[] = &quot;Hello World!&quot;; char* str3 = &quot;Hello World!&quot;; char* str4 = &quot;Hello World!&quot;; // 将常量字符串的首字母H存放到指针变量str中 // 常量是不可修改的 // 在内存中只需要存在一份 // 所以str3和str4指向的是同一块内存区域 // 则str3和str4的指针值相等 if (str1 == str2) { printf(&quot;same\\n&quot;); }else { printf(&quot;not same\\n&quot;); } if (str3== str4) { printf(&quot;same\\n&quot;); } else { printf(&quot;not same\\n&quot;); } return 0; } ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image.png) 2.2 数组指针 指向数组的指针。 2.2.1 格式 int arr[10] = { 0 }; int (*p)[10] = &amp;arr; // p 变量名 // *表示p是一个指针 // [10]表示该指针指向一个数组 // int 表示该指针指向的数组每个元素的类型为int // 注意 int (*p)[10] 与 int *p[10] 区分 // 如果没有小括号 p先于[]结合 成数组 // 若有小括号p先于*结合 成指针 2.2.2 数组名 // 数组名是数组首元素的地址 // 但是有2个例外 // 1. sizeof(arr) 数组名表示整个数组，计算的是整个数组大小，单位是字节 // 2. &amp;arr 数组名表示整个数组，取出的是整个数组的地址 2.2.3 arr和&amp;arr int main() { int arr[10] = { 0 }; printf(&quot;arr: %p\\n&quot;, arr); printf(&quot;arr+1: %p\\n&quot;, arr + 1); printf(&quot;&amp;arr: %p\\n&quot;, &amp;arr); printf(&quot;&amp;arr+1:%p\\n&quot;, &amp;arr + 1); return 0; } // arr是数组首元素的地址 // &amp;arr是数组指针 // 指针值相同，但含义完全不同 ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_1.png) 2.2.4 应用 // 数组指针一般用于二维数组中，在一维数组中体现不出优势 // 普通方法 void print1(int arr[3][4], int r, int c) { int i = 0; int j = 0; for ( i = 0; i &lt; r; i++) { for (j = 0; j &lt; c; j++) { printf(&quot;%d &quot;, arr[i][j]); } printf(&quot;\\n&quot;); } } // 数组指针 void print2(int(*p)[4], int r, int c) { int i = 0; int j = 0; for (i = 0; i &lt; r; i++) { for (j = 0; j &lt; c; j++) { printf(&quot;%d &quot;, *(*(p+i) + j)); } printf(&quot;\\n&quot;); } } int main() { int arr[3][4] = { { 1, 2, 3, 4 }, { 11, 22, 33, 44 }, { 111, 222, 333, 444} }; print1(arr, 3, 4); print2(arr, 3, 4); // arr数组名，传递的是数组首元素的地址 // 对于二维数组，则首元素就是第一行的一维数组 // 则arr为一维数组指针 // print2函数的需要使用数组指针接收 return 0; } 2.2.5 类型判断 int (*parr1)[10]; // parr1是数组指针变量 // 该指针指向元素个数为10、每个元素为int类型的数组 int (*parr2[10])[5]; // parr2先和[10]结合 所以parr2是一个数组 // 数组的类型为 int (*)[5]; 是数组指针 // 则parr2是一个存储10个数组指针的数组 // 且每个数组指针指向元素类型为int、元素个数为5的数组 2.3 指针数组 2.3.1 介绍 int* arr1[10]; // 整形指针的数组 char *arr2[4]; // 一级字符指针的数组 char **arr3[5]; // 二级字符指针的数组 2.3.2 例 int main() { int a[] = {1, 2, 3, 4, 5}; int b[] = {11, 22 ,33, 44, 55}; int c[] = {111, 222 ,333, 444, 555}; int* arr[] = { a, b, c }; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 5; j++) { printf(&quot;%d &quot;, arr[i][j]); printf(&quot;%d &quot;, *(arr[i] + j)); } printf(&quot;\\n&quot;); } return 0; } // 模拟二维指针 ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_2.png) 2.4 数组传参和指针传参 2.4.1 一维数组传参 void test1(int arr[]) {} // 数组(省略大小) // √ void test1(int arr[10]) {} // 数组(未省略大小) // √ void test1(int *arr) {} // int指针 // √ void test2(int *arr[]) {} // 指针数组(省略大小) // √ void test2(int **arr) {} // 二级指针 // √ int main() { int arr1[5] = { 0 }; // 一维整形数组 int* arr2[35] = { 0 }; // 一维整形指针数组 test1(arr1); test2(arr2); } 2.4.2 二维数组传参 void test(int arr[3][4]) {} // 二维数组（未省略） // √ void test(int arr[][]) {} // 二维数组（行列都省略） // × void test(int arr[][4]) {} // 二维数组（行省略） // √ // 总结：二维数组传参，函数形参的设计只能省略第一个[]的数组 // 因为对一个二维数组，可以不知道有多少行，但必须一行有多少个元素 // 方便运算 void test(int *arr) {} // int指针（传递过来的是第一行数组的指针） // × void test(int *arr[4]) {} // 指针数组 // × void test(int (*arr)[4]) {} // 数组指针 // √ void test(int **arr) {} // 二级指针 // × int main() { int arr[3][4] = { 0 }; test(arr); return 0; } 2.4.3 一级指针传参 // eg: void print(int* ptr, int sz) { int i = 0; for (i = 0; i &lt; sz; i++) { printf(&quot;%d &quot;, *(ptr + i)); } } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int* p = arr; int sz = sizeof(arr) / sizeof(arr[0]); print(p, sz); return 0; } // 当函数的形参为指针时 // 实参可以是对应类型变量的地址 &amp;var // 也可以是一级指针变量 ptr 2.4.4 二级指针传参 void print(int** ptr) { // ... } int main() { // 指针数组首元素 int* arr[10] = { 0 }; int** p = arr; print(p); // 二级指针变量 int a = 7; int* pa = &amp;a; int** ppa = &amp;pa; print(ppa); print(&amp;pa); return 0; } // 当函数的形参是二级指针时 // 实参可以是指针数组首元素 // 也可以是二级指针变量 2.5 函数指针 2.5.1 介绍 指向函数的指针。存放函数地址的指针。 int Add(int x, int y) { return x + y; } int main() { printf(&quot;%p\\n&quot;, &amp;Add); printf(&quot;%p\\n&quot;, Add); // 两种打印方式打印结果相同 // 都是函数的地址 // Add和&amp;Add完全等价 // 函数名本质上就是地址 return 0; } ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_3.png) 2.5.2 格式 返回值类型 (*函数指针变量)(参数类型); // eg: int (*pf)(int, int) = &amp;Add; int (*pf)(int, int) = Add; // * 表示pf是一个指针变量 // () 表示该指针指向一个函数 // (int, int) 表示指针指向的函数的参数类型 // int (*pf) 前面的int表示指针指向的函数的返回值类型 2.5.3 调用 int Add(int x, int y) { return x + y; } int main() { int (*pf)(int, int) = Add; // Add === pf int ret1 = (*pf)(1, 2); // 其中pf前的*只是摆设 可以省略 也可以有多个 int ret2 = pf(2, 3); int ret3 = Add(3, 4); return 0; } 2.5.4 应用 代码一 (*(void (*)())0)(); // 调用0地址处的函数 // 该函数无参，返回值类型为void // 1. void(*)() - 函数指针类型 // 2. (void(*)())0 - 将0强制类型转换为函数指针类型 即函数地址 // 3. *(void (*)())0 - 将该函数地址进行指针解引用 // 4. (*(void (*)())0)() - 调用0地址处的函数 代码二 void (* signal(int, void(*)(int)))(int); // 1. signal和()先结合 说明signal是一个函数名 // 2. signal函数的参数是一个int和函数指针 // 该函数指针类型 void(*)(int) 指向参数为int 返回值类型为void的函数 // 3. signal函数的返回类型为函数指针 // 将void (* signal(int, void(*)(int)))(int); 中的 signal(int, void(*)(int)) 剔除 // 结果为void (*)(int) 即为函数的返回类型 // 该函数指针类型 void(*)(int) 指向参数为int 返回值类型为void的函数 // 总结：signal是一个 参数为int和函数指针 返回类型为函数指针 的函数声明 // 简化如下（含义相同 表达更清晰） typedef void(*func_ptr)(int); func_ptr signal(int, func_ptr); ![代码片段来源：C陷阱和缺陷（15页）](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_4.png) 2.6 函数指针数组 2.6.1 介绍 存放函数指针的数组。 // 定义： // 函数指针 int (*fp)(int, int); // fp为指针变量，*表示该变量为指针，其余 int (int, int) 为函数指针指向的函数类型 // 函数指针数组 int (*arr[5])(int, int); // arr3为数组名，其余 int (* [5])(int, int) 为数组类型，int (* )(int, int) 为数组元素类型 2.6.2 应用 计算器实现 基本实现 #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; void menu() { // 打印菜单 printf(&quot;*************************\\n&quot;); printf(&quot;**** 两位数加减乘除 *****\\n&quot;); printf(&quot;*************************\\n&quot;); printf(&quot;**** 1.add 2.sub *****\\n&quot;); printf(&quot;**** 3.mul 4.div *****\\n&quot;); printf(&quot;**** 0.exit *****\\n&quot;); printf(&quot;*************************\\n&quot;); } int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int Mul(int x, int y) { return x * y; } int Div(int x, int y) { return x / y; } int main() { int input = 0; do { menu(); // 打印菜单 printf(&quot;请输入:&gt; &quot;); // 提示 scanf(&quot;%d&quot;, &amp;input); // 获取用户输入 int x = 0; int y = 0; int ret = 0; switch (input) // 确定计算规则 { case 1: scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据 ret = Add(x, y); // 相加 printf(&quot;结果是：%d\\n&quot;, ret); break; case 2: scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据 ret = Sub(x, y); // 相减 printf(&quot;结果是：%d\\n&quot;, ret); break; case 3: scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据 ret = Mul(x, y); // 相乘 printf(&quot;结果是：%d\\n&quot;, ret); break; case 4: scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 获取用户需要计算的数据 ret = Div(x, y); // 相除 printf(&quot;结果是：%d\\n&quot;, ret); break; case 0: break; default: printf(&quot;输入错误，请重新输入！\\n&quot;); break; } } while (input); } 函数指针数组实现 在上面代码的switch语句中发现有大量的代码冗余，接下来通过函数指针数组对main函数进行重写。 int main() { int input = 0; do { menu(); // 打印菜单 printf(&quot;请输入:&gt; &quot;); // 提示 scanf(&quot;%d&quot;, &amp;input); // 获取用户输入 // 创建函数指针数组 int (*pfarr[5])(int, int) = { NULL, Add, Sub, Mul, Div }; // 数组首元素使用NULL补位，使得input值为数组下标 恰好对应相应的函数 if (input == 1 || input == 2 || input == 3 || input == 4) { int x = 0; int y = 0; int ret = 0; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); ret = pfarr[input](x, y); printf(&quot;结果是：%d\\n&quot;, ret); } else if (input == 0) { break; } else { printf(&quot;输入错误，重新输入！\\n&quot;); } } while (input); } 转移表 -- 函数指针数组。 2.7 指向函数指针数组的指针(了解) 指向函数指针数组的指针 指针指向一个数组 数组的每个元素是函数指针 2.7.1 指向整形数组的指针 // 1.整形数组 int arr1[5]; // arr1为数组名，其余 int [5] 为数组类型，int为数组元素类型 // 2.整形数组的指针 int(*parr1)[5] = &amp;arr1; // parr1为指针变量，*表示该变量为指针，其余 int [5] 为指针指向的对象的类型 2.7.2 指向整形指针数组的指针 // 1.整形指针数组 int* arr2[5]; // arr2为数组名，其余int* [5] 为数组类型，int*为数组元素的类型 // 2.整形指针数组的指针 int* (*parr2)[5] = &amp;arr2; // parr2为指针变量，*表示该变量为指针，其余 int* [5] 为指针指向的对象的类型 2.7.3 指向函数指针数组的指针 // 1.函数指针 int (*fp)(int, int); // fp为指针变量，*表示该变量为指针，其余 int (int, int) 为函数指针指向的函数类型 // 2.函数指针数组 int (*arr3[5])(int, int); // arr3为数组名，其余 int (* [5])(int, int) 为数组类型，int (* )(int, int) 为数组元素类型 // 3.函数指针数组的指针 int (*(*parr3)[5])(int, int) = &amp;arr3; // parr3为指针变量，*表示该变量为指针，其余 int (* [5])(int, int) 为指针指向对象的类型 2.8 回调函数 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，这就是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 2.8.1 再次重写计算器 根据回调函数再次重写计算器实例的main函数 int Cal(int (*fp)(int, int)) // 形参为函数指针类型int (* )(int, int) { int x = 0; int y = 0; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); return fp(x, y); } int main() { int input = 0; do { menu(); // 打印菜单 printf(&quot;请输入:&gt; &quot;); // 提示 scanf(&quot;%d&quot;, &amp;input); // 获取用户输入 int (*pfarr[5])(int, int) = { NULL, Add, Sub, Mul, Div }; // 数组指针 if (input == 1 || input == 2 || input == 3 || input == 4) { int ret = Cal(pfarr[input]); // 将函数指针作为参数进行传递 printf(&quot;结果是：%d\\n&quot;, ret); } else if (input == 0) { break; } else { printf(&quot;输入错误，重新输入！\\n&quot;); } } while (input); } 2.8.2 模拟实现qsort库函数 qsort底层是快速排序。此处只需关注如何使用，即qsort函数的参数和返回值。所以使用冒泡排序实现相同使用方法的该函数。 介绍 头文件&lt;stdlib.h&gt; 语法 void qsort( void *base, size_t number, size_t width, int (__cdecl *compare )(const void *, const void *) ); 参数 base：数组的起始地址 number：数组中元素的个数 width：数组中元素的大小（单位：byte） compare：一个指向用户提供的函数的指针，该函数比较数组两个元素并返回一个值，改值表示他们之间的关系 compare compare( (void *) &amp; elem1, (void *) &amp; elem2 ); 比较返回值 描述 &lt;0 elem1&lt;elem2 =0 elem1=elem2 &gt;0 elem1&gt;elem2 &gt; 数组按递增排序，如果要对数组进行递减排序，反转 比较返回值 中的`&gt;`和`&lt;` 使用实例 比较整形 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int compare_int(const void* e1, const void* e2) { return *(int*)e1 - *(int*)e2; } int main() { int arr[] = {5,3,1,2,4,6}; int num = 0; num = sizeof(arr) / sizeof(arr[0]); qsort(arr, num, 4, compare_int); for (int i = 0; i &lt; 6; i++) { printf(&quot;%d &quot;, arr[i]); } return 0; } // void*类型可以存放任意类型地址 // 但是不能解引用和计算（解引用时，并不清楚访问几个字节） // 使用时需要强制类型转换为需求的类型指针 比较字符串 // 字符串比较大小时，按位比较字符的ASCII码 // 如果字符串长度不相等，如&quot;ab&quot;和&quot;abc&quot;比较 // 'a'和'a'比较 相等 右移 // 'b'和'b'比较 相等 右移 // '\\0'和'c'比较 '\\0'&lt;'c' &quot;ab&quot;&lt;&quot;abc&quot; #define _CRT_NONSTDC_NO_DEPRECATE #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; int compare_string(const void* e1, const void* e2) { return stricmp(*(char**)e1, *(char**)e2); } int main() { char* arr[] = { &quot;afd&quot;,&quot;fasf&quot;,&quot;fadew&quot;,&quot;fdfa&quot;,&quot;rqewr&quot;,&quot;fdasf&quot; }; int num = 0; num = sizeof(arr) / sizeof(arr[0]); qsort(arr, num, 4, compare_string); for (int i = 0; i &lt; 6; i++) { printf(&quot;%s &quot;, arr[i]); } return 0; } 比较结构体 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; struct Student { char name[20]; int age; }; int compare_by_name(const void* e1, const void* e2) { return strcmp(((struct Student*)e1)-&gt;name, ((struct Student*)e2)-&gt;name); } int compare_by_age(const void* e1, const void* e2) { return (*((struct Student*)e1)).age - (*((struct Student*)e2)).age; } print_struct_arr(struct Student arr[], int num) { for (int i = 0; i &lt; 4; i++) { printf(&quot;name: %s, age: %d\\n&quot;, (arr[i]).name, (arr[i]).age); } } int main() { struct Student arr[4] = { {&quot;listen&quot;, 20},{&quot;turbo&quot;, 34},{&quot;dummy&quot;, 24},{&quot;free&quot;, 19}}; int num = 0; num = sizeof(arr) / sizeof(arr[0]); qsort(arr, num, sizeof(arr[0]), compare_by_name); printf(&quot;按照姓名排序如下：\\n&quot;); print_struct_arr(arr, num); // 打印结构体数组 qsort(arr, num, sizeof(arr[0]), compare_by_age); printf(&quot;按照年龄排序如下：\\n&quot;); print_struct_arr(arr, num); // 打印结构体数组 return 0; } 冒泡排序实现（升序为例） 原理图 描述：当前元素和下一个元素进行比较。如果小于下一个元素，则保持不变；如果大于下一个元素，则交换位置。然后下标+1，再比较，再下标+1，直到比较完倒数第二个元素和最后一个元素，这个过程称为一趟。接着再从头开始进行比较，如下图所示： ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_5.png) 容易得出：5个数进行排序需要4趟。 代码 void bubble_sort(int* p, int num) { for (int i = 0; i &lt; num-1; i++) { for (int j = 0; j &lt; num-1; j++) { if (p[j] &gt; p[j+1]) { int tmp = p[j]; p[j] = p[j + 1]; p[j + 1] = tmp; } } } } int main() { int arr[] = {5,3,1,2,4,6}; int num = sizeof(arr) / sizeof(arr[0]); bubble_sort(arr, num); for (int i = 0; i &lt; num; i++) { printf(&quot;%d &quot;, arr[i]); } return 0; } 优化 第二趟6和8比较 与 前面的6和8比较 重复 第三趟4和6比较、6和8比较 与 前面的4和6比较、6和8比较 重复 第四趟2和4比较、4和6比较、6和8比较 与 前面的2和4比较、4和6比较、6和8比较 重复 所以：在第二趟中一次重复的比较；在第三趟中二次重复的比较；在第四趟中三次重复的比较。优化的原理就是让每两个数比较只出现一次。 如图中，圈中的是重复进行比较的两元素。 ![](image/image_6.png) ![](https://listen2022.github.io/post-images/1643676911293.png) void bubble_sort(int* p, int num) { for (int i = 0; i &lt; num-1; i++) { for (int j = 0; j &lt; num-i-1; j++) { if (p[j] &gt; p[j+1]) { int tmp = p[j]; p[j] = p[j + 1]; p[j + 1] = tmp; } } } } int main() { int arr[] = {5,3,1,2,4,6}; int num = sizeof(arr) / sizeof(arr[0]); bubble_sort(arr, num); for (int i = 0; i &lt; num; i++) { printf(&quot;%d &quot;, arr[i]); } return 0; } 增强 前面的冒泡排序算法只能比较两个整形，现在将冒泡排序功能进行扩展，使其可以比较任何数据类型（参考sqort库函数）。 void bubble_sort(void* p, int num, int width, int (*compare)(const void*, const void*)) { for (int i = 0; i &lt; num - 1; i++) { for (int j = 0; j &lt; num - i - 1; j++) { // 比较大小，前者&gt;后者返回整数 if (compare((char*)p + j * width, (char*)p + (j+1) * width) &gt; 0) { // 交换值 // 确定大小，但不知道类型 // 按字节交换 char类型刚好代表一个字节，总共交换width次 for (int k = 0; k &lt; width; k++) { char tmp = *((char*)p + j * width + k); *((char*)p + j * width + k) = *((char*)p + (j + 1) * width + k); *((char*)p + (j + 1) * width + k) = tmp; } } } } } 测试 // bubble_sort测试 int compare_int(const void* e1, const void* e2) { return *(int*)e1 - *(int*)e2; } int main() { int arr[] = {5,3,1,2,4,6}; int num = sizeof(arr) / sizeof(arr[0]); bubble_sort(arr, num, sizeof(arr[0]), compare_int); for (int i = 0; i &lt; num; i++) { printf(&quot;%d &quot;, arr[i]); } return 0; } 2.9 习题 2.9.1 指针 int a[] = { 1,2,3,4 }; int main() { int a[] = { 1,2,3,4 }; printf(&quot;%d\\n&quot;, sizeof(a)); // 16 // 解释：a 单独放在 sizeof() 中时，a 表示整个数组， // 计算的是整个数组的大小，整个数组 4 个元素，且数组元素为 int 类型 // 所以数组大小为 4 × 4 = 16byte printf(&quot;%d\\n&quot;, sizeof(a + 0)); // 4/8 // 解释：a 表示数组首元素的地址，+0 之后依然是数组是首元素的地址， // 作为地址在32位计算机中为 4byte，64位系统中为 8byte printf(&quot;%d\\n&quot;, sizeof(*a)); // 4 // 解释：a 表示数组首元素的地址，*a 对 a 解引用，得到的是数组首元素 1， // 数组元素的类型为 int，所以 *a 的大小为 4byte printf(&quot;%d\\n&quot;, sizeof(a+1)); // 4/8 // 解释：a 表示数组首元素的地址，a+1 表示数组第二个元素的地址， // 作为地址，其大小为 4byte(32位系统) 或 8byte(64位系统) printf(&quot;%d\\n&quot;, sizeof(a[1])); // 4 // 解释：a[1] 表示数组首元素，数组元素的类型为 int，其大小为 4byte printf(&quot;%d\\n&quot;, sizeof(&amp;a)); // 4/8 // 解释：&amp;a 中 a 表示的是整个数组，获取的是整个数组的指针 // 作为地址，其大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(*&amp;a)); // 16 // 解释：&amp;a 获取的是整个数组的地址，再解引用得到的是整个数组 // 整个数组的大小为 4 × 4 = 16byte printf(&quot;%d\\n&quot;, sizeof(&amp;a + 1)); // 4/8 // 解释：&amp;a 获取的是整个数组的指针，&amp;a+1 跳过一个 int [4] 类型的数组 // &amp;a+1 指向数组 arr 之后第一个位置的地址 // 作为指针，其大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(&amp;a[0])); // 4/8 // 解释：a[0] 获取数组首元素，&amp;a[0] 对数组首元素取地址，即数组首元素的地址 // 作为指针，其大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(&amp;a[0] + 1)); // 4/8 // 解释：易得 &amp;a[0] 为数组首元素的地址，&amp;a[0]+1 跳过一个元素， // 即数组第二个元素的地址，作为指针，其大小为 4/8byte } ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_7.png) char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' }; #include &lt;string.h&gt; int main() { char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' }; printf(&quot;%d\\n&quot;, sizeof(arr)); // 6 // 解释：arr 表示整个数组，数组共6个元素，且元素类型为 char // 所以，数组的大小为 6byte printf(&quot;%d\\n&quot;, sizeof(arr + 0)); // 4/8 // 解释：arr 表示数组首元素的地址，arr+0 表示跳过 0byte， // 同样是数组首元素的地址，作为指针，其大小为 4 / 8byte printf(&quot;%d\\n&quot;, sizeof(*arr)); // 1 // 解释：arr 表示数组首元素的地址，*arr 对数组首元素的地址解引用 // *arr 表示数组首元素，数组元素为char类型，则数组首元素的大小为 1byte printf(&quot;%d\\n&quot;, sizeof(arr[1])); // 1 // 解释：arr[1] 表示数组第二个元素，数组元素为char类型， // 则数组第二个元素的大小为 1byte printf(&quot;%d\\n&quot;, sizeof(&amp;arr)); // 4/8 // 解释：arr 表示整个数组，&amp;arr 对整个数组取地址， // 作为地址，其大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(&amp;arr + 1)); // 4/8 // 解释：arr 表示真个数组，&amp;arr 对整个数组取地址， // &amp;arr+1 表示跳过一个 char [6] 类型数组的大小， // 则指向数组后第一个位置的地址， // 作为地址，其大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(&amp;arr[0] + 1)); // 4/8 // 解释：arr[0] 表示数组首元素，&amp;arr[0] 获取数组首元素的地址 // &amp;arr[0]+1 跳过一个char类型元素的大小， // 则表示数组第二元素的地址，作为地址，其大小为 4/8byte printf(&quot;%d\\n&quot;, strlen(arr)); // 随机值 // 解释：arr表示数组首元素的地址，从arr开始向后找 \\0 ， // 所以，结果为随机值 printf(&quot;%d\\n&quot;, strlen(arr + 1)); // 随机值 // 解释：arr表示数组首元素的地址，则 arr+1 表示数组第二个元素的地址 // 从数组第二个元素开始向后查找 \\0 ，所以结果为随机值 // 但相对于上一个随机值，相差1 //printf(&quot;%d\\n&quot;, strlen(*arr)); // error //// 解释：arr表示数组首元素的地址，*arr 表示对首元素地址解引用，则得到首元素 'a' //// 而 strlen 函数的参数是指针类型，所以 error //printf(&quot;%d\\n&quot;, strlen(arr[1])); // error //// 解释：arr[1] 表示数组第二个元素 'b' ，同样参数类型不否，error printf(&quot;%d\\n&quot;, strlen(&amp;arr)); // 随机值 // 解释：&amp;arr 取真个数组的地址，但是其值与数组首元素地址相等 // 所以，从数组首元素开始向后找 '\\0' ，结果为随机值 printf(&quot;%d\\n&quot;, strlen(&amp;arr + 1)); // 随机值 // 解释：&amp;arr 取整个数组的地址，&amp;arr+1 指向数组后第一个位置的地址 // 从该位置开始向后找 '\\0' 结果为随机值 // 但相对于上一个随机值，相差6 printf(&quot;%d\\n&quot;, strlen(&amp;arr[0] + 1)); // 随机值 // 解释：arr[0] 表示数组第一个元素，&amp;arr[0] 对数组第一个元素取地址 // &amp;arr[0]+1 跳过一个元素的大小，指向数组第二个元素， // 从数组第二个元素开始向后查找 '\\0'，结果为随机值 return 0; } ``` char arr[] = &quot;abcdef&quot;; #include &lt;string.h&gt; int main() { char arr[] = &quot;abcdef&quot;; // 等价于 //char arr[] = { 'a','b','c','d','e','f','\\0' }; printf(&quot;%d\\n&quot;, sizeof(arr)); // 7 // arr表示真个数组 数组大小为 6×1=7byte printf(&quot;%d\\n&quot;, sizeof(arr + 0)); // 4/8 // arr+0=arr 表示数组首元素地址 // 作为地址 大小为 4/8 byte printf(&quot;%d\\n&quot;, sizeof(*arr)); // 1 // arr表示数组首元素地址 // *arr 表示数组首元素'a' 大小为1byte printf(&quot;%d\\n&quot;, sizeof(arr[1])); // 1 // arr[1] 表示数组第二个元素'b' 大小为1byte printf(&quot;%d\\n&quot;, sizeof(&amp;arr)); // 4/8 // &amp;arr 获取真个数组arr的地址 // 作为地址 大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(&amp;arr + 1)); // 4/8 // &amp;arr 获取真个数组arr的地址 // &amp;arr+1 跳过一个 char [7] 数组 // 数组arr后面第一个位置的地址 printf(&quot;%d\\n&quot;, sizeof(&amp;arr[0] + 1)); // 4/8 // arr[0] 数组首元素 // &amp;arr[0] 数组首元素地址 // &amp;arr[0]+1 数组第二个元素地址 // 作为地址 大小为 4/8byte printf(&quot;%d\\n&quot;, strlen(arr)); // 6 // arr数组首元素'a'地址 // 从该地址开始向后找'\\0' // strlen 获取从'a'到'\\0'的字符串长度6 printf(&quot;%d\\n&quot;, strlen(arr + 1)); // 5 // arr数组首元素'a'地址 // arr+1 数组第二个元素'b'地址 // strlen 获取从'b'到'\\0'的字符串长度5 //printf(&quot;%d\\n&quot;, strlen(*arr)); // error // arr 数组首元素地址 // *arr 数组首元素 // strlen 参数为地址 //printf(&quot;%d\\n&quot;, strlen(arr[1])); // error // arr[1] 数组第二个元素 // strlen 参数为地址 printf(&quot;%d\\n&quot;, strlen(&amp;arr)); // 6 // &amp;arr 获取整个数组地址 等于数组首元素'a'地址 // 从该地址开始向后找'\\0' // strlen函数 从'a'到'\\0'的字符串长度6 printf(&quot;%d\\n&quot;, strlen(&amp;arr + 1)); // 随机值 // &amp;arr 获取整个数组地址 类型为数组指针 // &amp;arr+1 跳过一个 char [7] 数组 --&gt; 数组arr后第一个位置地址 // strlen函数 从该位置开始向后找'\\0' 而后面的区域未知 // 所以结果为随机值 printf(&quot;%d\\n&quot;, strlen(&amp;arr[0] + 1)); // 5 // &amp;arr[0] 等价于 &amp;*(arr+0) 等价于 arr // arr+1 表示数组第二个元素'b'地址 // strlen 从'b'到'\\0'的字符串长度5 return 0; } char* p = &quot;abcdef&quot;; #include &lt;string.h&gt; int main() { char* p = &quot;abcdef&quot;; printf(&quot;%d\\n&quot;, sizeof(p)); // 4/8 // p 字符指针 字符串首字符 'a' 的地址 // 大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(p + 1)); // 4/8 // p 字符指针 字符串首字符 'a' 的地址 // p+1 跳过一个字符 字符串第二个字符 'b' 的地址 // 大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(*p)); // 1 // p 字符指针 字符串首字符 'a' 的地址 // 解引用得到字符'a' 大小为 1byte printf(&quot;%d\\n&quot;, sizeof(p[0])); // 1 // p[0] 等价于 *(p+0) // p+0 字符串第1个字符'a'的地址 // *(p+0) 字符串第1个字符'a' 大小为1byte printf(&quot;%d\\n&quot;, sizeof(&amp;p)); // 4/8 // p 字符指针 字符串首字符 'a' 的地址 // &amp;p 获取字符指针的地址 二级指针 // 大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(&amp;p + 1)); // 4/8 // &amp;p 获取字符指针的地址 二级指针 // &amp;p+1 作为指针 大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(&amp;p[0] + 1)); // 4/8 // p[0] 字符串第1个字符'a' // &amp;p[0] 字符串第1个字符 'a' 的地址 // &amp;p[0]+1 跳过1个字符 --&gt; 字符串第2个字符'b'地址 printf(&quot;%d\\n&quot;, strlen(p)); // 6 // p 字符指针 字符串第1个字符'a'地址 // strlen 获取从'a'到'\\0'字符串长度 printf(&quot;%d\\n&quot;, strlen(p + 1)); // 5 // p+1 字符串第2个字符'b'地址 // strlen 获取从'b'到'\\0'字符串长度 //printf(&quot;%d\\n&quot;, strlen(*p)); // error // *p 字符'a' strlen函数的参数为指针 //printf(&quot;%d\\n&quot;, strlen(p[0])); // error // p[0] 字符'a' strlen函数的参数为指针 printf(&quot;%d\\n&quot;, strlen(&amp;p)); // 随机值 // &amp;p 字符指针p的地址 从p的地址开始向后查找'\\0' // '\\0' 可能再字符指针p中，也可能在其后面 // 所以 strlen(&amp;p) 为随机值 printf(&quot;%d\\n&quot;, strlen(&amp;p + 1)); // 随机值 // &amp;p+1 字符指针p后面一个位置的地址 // 从该位置向后查找 '\\0' 后面的区域是未知的 // 所以 strlen(&amp;p+1) 为随机值 printf(&quot;%d\\n&quot;, strlen(&amp;p[0] + 1)); // 5 // &amp;p[0] 相当于 &amp;*(p+0) = p // p+1 字符串第2个字符'b'地址 // 从该地址向后找 '\\0' // strlen 获取从'b'到'\\0'字符串长度 return 0; } ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_8.png) int a[3][4] = { 0 }; #include &lt;stdio.h&gt; int main() { int a[3][4] = { 0 }; printf(&quot;%d\\n&quot;, sizeof(a)); // 48 // a表示整个数组 大小为 3×4×4=48(byte) printf(&quot;%d\\n&quot;, sizeof(a[0][0])); // 4 // a[0][0] 表述数组第一行第一列的元素 int类型 大小为4byte printf(&quot;%d\\n&quot;, sizeof(a[0])); // 16 // a[0]表示二维数组a的第一行，大小为4×4=16(byte) printf(&quot;%d\\n&quot;, sizeof(a[0] + 1)); // 4/8 // a[0]表示二维数组a的第一行 // a[0]+1 a[0]为二维数组第一行数组首元素地址 // +1 跳过1字节 --&gt; 二维数组第一行数组第二个元素地址 // 地址大小为 4/8byte printf(&quot;%d\\n&quot;, sizeof(*(a[0] + 1))); // 4 // *(a[0] + 1) 等价于a[0][1] // 表示为二维数组a第一行第二列的元素 // int类型 大小为 4byte printf(&quot;%d\\n&quot;, sizeof(a + 1)); // 4/8 // a 表示数组首元素地址，二维数组的第一行数组的地址 // a+1 跳过 1个int [4] 类型一维数组 --&gt; 二维数组的第二行地址 // 大小为 4/8(byte) printf(&quot;%d\\n&quot;, sizeof(*(a + 1))); // 16 // a 表示二维数组第一行地址 // a+1 跳过 1个int [4] 类型一维数组 --&gt; 二维数组第二行地址 // *(a+1) 解引用得到二维数组第二行 // 大小为 4×4=16(byte) printf(&quot;%d\\n&quot;, sizeof(&amp;a[0] + 1)); // 4/8 // a[0] 二维数组第一行 // &amp;a[0] 二维数组第一行地址 // &amp;a[0]+1 跳过一个 int [4] 类型一维数组 --&gt; 二维数组第二行地址 // 大小为 4/8(byte) printf(&quot;%d\\n&quot;, sizeof(*(&amp;a[0] + 1))); // 16 // &amp;a[0]+1 二维数组第二行地址 // *(&amp;a[0]+1) 解引用得到二维数组第二行 // 大小为 4×4=16(byte) printf(&quot;%d\\n&quot;, sizeof(*a)); // 16 // a 二维数组第一行地址 // *a 二维数组第一行 // 大小为 4×4=16(byte) printf(&quot;%d\\n&quot;, sizeof(a[3])); // 16 // a[3] 类型为int [4] // 大小为 4×4=16(byte) // sizeof并不会计算括号内的表达式，而是通过类型来确定大小 // 所以a[3]并不会越界访问 return 0; } 2.9.2 练习1 struct Test { int Num; char* pcName; short sDate; char cha[2]; short sBa[4]; }*p; // 假设p的值位0x100000 // 已知结构体Test的大小位20字节 int main() { printf(&quot;%p\\n&quot;, p + 0x1); // 0x100014 结构体指针+1 printf(&quot;%p\\n&quot;, (unsigned long)p + 0x1); // 0x100001 整形+1 printf(&quot;%p\\n&quot;, (unsigned int*)p + 0x1); // 0x100004 整形指针+1 } 2.9.3 练习2 int main() { int a[5] = { 1,2,3,4,5 }; int* ptr = (int*)(&amp;a + 1); // &amp;a 获取真个数组的地址 // &amp;a+1 跳过 int [5] 数组 --&gt; 数组后第一个位置的地址 // (int*)(&amp;a + 1) 强制类型转换为整形指针 赋值给ptr printf(&quot;%d %d\\n&quot;, *(a + 1), *(ptr - 1)); // 2 5 // *(a+1) 等价于 a[1] 等于2 // ptr-1 向前跳过 int 整形 --&gt; 数组a最后一个元素地址 // *(ptr-1) 数组a最后一个元素 } 2.9.4 练习3 int main() { int a[4] = { 1,2,3,4 }; int* ptr1 = (int*)(&amp;a + 1); // ptr1 整形指针 // 其中 a 表示整个数组，&amp;a 获取整个数组的地址 // &amp;a+1 是数组a之后第一个位置的地址 // (int*)(&amp;a+1) 将数组指针强制类型转换为整形指针，并赋值给ptr1 // ptr1[-1] 等价于 *(ptr1-1)， // ptr1-1 将指针向前移动一个int类型的大小(4byte) // 即，*(ptr-1) 的值为a[3] = 4; int* ptr2 = (int*)((int)a + 1); // ptr2 整形指针 // 其中 a 表示数组首元素的地址，(int)a 将地址强制类型转换为int // (int)a+1 则地址数值加1，而内存中每个地址代表1byte // 比如：地址是0xFF9A8C11 地址数值 +1 后变为 0xFF9A8C12 // 即，指向原来指向的地址的后一个字节的地址 // 所以 (int)a+1 指向如图所示的位置 // (int*)((int)a+1) 将int型数值强制类型转换为整形指针，并赋值给ptr2 // 所以 对ptr2解引用 *ptr2 值为 (int*)((int)a+1) 开始向后四个字节的内容 printf(&quot;%x, %x\\n&quot;, ptr1[-1], *ptr2); // 输出结果(输出时将数字前无用的零去除)：4，2000000 return 0; } ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_9.png) 2.9.5 练习4 int main() { int a[3][2] = { (0,1), (2,3),(4,5) }; // 注意：{}中是()，所以是逗号表达式 // 赋值语句相当于 int a[3][2]={ 1,3,5 }; int* p; // 声明整形指针 p = a[0]; // 将数组a首元素赋值给p // 数组a为二维数组，其首元素为第一行的数组 // 并赋值给整形指针p，则p的值为第一行数组的首元素的地址 printf(&quot;%d\\n&quot;, p[0]); // 1 // p[0] 等价于 *(p+0) 对第一行数组首元素地址解引用 // 值为第一行数组的首元素 return 0; } 2.9.6 练习5 int main() { int a[5][5]; int(*p)[4]; // 定义数组指针 指向对象类型为 int [4] p = a; // 将数组 a 首元素地址赋值给 p printf(&quot;%p, %d\\n&quot;, &amp;p[4][2] - &amp;a[4][2], &amp;p[4][2] - &amp;a[4][2]); // &amp;p[4][2] 等价于 *(p+4)+2 // p+4 跳过 4×4=16 个元素 // *(p+4) 对数组指针解引用得到一维数组 p[4] // *(p+4)+2 跳过2个整形型元素，即第18个元素的地址 // // &amp;a[4][2] 等价于 *(a+4)+2 // a+4 跳过 4×5=20 个元素 // *(a+4) 解引用得到一维数组 a[4] // *(a+4)+2 跳过2个整形元素，即第22个元素的地址 // // &amp;p[4][2] - &amp;a[4][2] 地址相减是两个地址间元素的个数 // &amp;p[4][2] 第18个元素的地址 // &amp;a[4][2] 第22个元素的地址 // 相减结果为 -4 // 在内存中十六进制表示为 FFFFFFFC // %p 指针形式打印为 FFFFFFFC // %d 将内存中二进制再转换为整形 打印为 -4 // FFFFFFFC, -4 return 0; } // 另外：运行时警告 “int (*)[4]”和“int (*)[5]”数组的下标不同 ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_10.png) 2.9.7 练习6 int main() { int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 }; int* ptr1 = (int*)(&amp;aa + 1); // &amp;aa 其中 aa 表示二维数组 获取二维数组的地址 // &amp;aa+1 跳过整个二维数组 指向二维数组之后第一个位置 // (int*)(&amp;aa+1)强制类型转换为整形指针 并赋值给 ptr1 int* ptr2 = (int*)(*(aa + 1)); // aa 表示二维数组首元素地址--第一行地址 // aa+1 跳过 int [5] 大小，--第二行地址 // *(aa+1) 得到第二行数组--第二行数组首元素地址 // (int*)(*(aa+1)) 强制类型转换为整形指针 并赋值给 ptr2 // (不过，本来已经是整形指针，此转换没有必要) printf(&quot;%d, %d\\n&quot;, *(ptr1 - 1), *(ptr2 - 1)); // *(ptr1-1) 向前跳 一个整形大小 并解引用 得到二维数组的最后一个元素 // *(ptr2-1) 向前跳 一个整形大小 并解引用 得到二维数组第一行最后一个元素 // 输出结果为：10, 5 return 0; } 2.9.8 练习7 int main() { char* a[] = { &quot;work&quot;, &quot;at&quot;, &quot;home&quot; }; char** pa = a; // 数组 a 中元素的类型时 char* // a 表示数组首元素的地址 所以a是二级指针 并赋值给pa pa++; // pa指向的类型为 char* 自增之后 跳过 1个地址的大小 // 指向数组a第二个元素的地址 printf(&quot;%s\\n&quot;, *pa); // 对 pa 解引用，得到数组 a 第二个元素(是一个地址) // %s 打印 从该地址*pa开始向后查找'/0' 并打印字符串 // 输出结果为 &quot;at&quot; return 0; } // 初始化数组a和二级指针pa之后的内存如下： ![](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_11.png) 2.9.9 练习8 int main() { char* c[] = { &quot;ENTER&quot;, &quot;NEW&quot;, &quot;POINT&quot;, &quot;FIRST&quot; }; char** cp[] = { c + 3, c + 2, c + 1, c }; char*** cpp = cp; // 初始化之后的内存情况如果0所示 printf(&quot;%s\\n&quot;, **++cpp); // POINT printf(&quot;%s\\n&quot;, *-- * ++cpp + 3); // ER printf(&quot;%s\\n&quot;, *cpp[-2] + 3); // ST printf(&quot;%s\\n&quot;, cpp[-1][-1] + 1); // EW return 0; } ![图0](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_12.png) 第一个printf printf(&quot;%s\\n&quot;, **++cpp); // POINT // ++cpp cpp下移动如图1所示 // 第一次解引用 得到c+2 // 第二次解引用得到指向字符串&quot;POINT&quot;的字符指针 // 则打印字符串 &quot;POINT&quot; ![图1](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_13.png) 第二个printf printf(&quot;%s\\n&quot;, *-- * ++cpp + 3); // ER // ++cpp cpp下移如图2所示 // 第一次解引用得到 c+1 // *-- 得到指向&quot;ENTER&quot;的字符指针 // +3 跳过3个字符，--&gt; 字符'E'的地址 // 则打印字符串&quot;ER&quot; ![图2](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_14.png) 第三个printf printf(&quot;%s\\n&quot;, *cpp[-2] + 3); // ST // *cpp[-2] 相当于 **(cpp-2)，cpp-2 指向如图3所示 // *(cpp-2) 得到 c+3 // **(cpp-2) 得到 指向&quot;FIRST&quot;的字符指针 // *cpp[-2] + 3 跳过3个字符，--&gt; 字符'S'的地址 ![图3](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_15.png) 第四个printf printf(&quot;%s\\n&quot;, cpp[-1][-1] + 1); // EW // cpp[-1][-1] 相当于 *(*(cpp-1)-1) // cpp-1 指向如图4所示 *(cpp-1) 得到c+2 // *(*(cpp-1)-1) 向后跳一个指针大小 得到指向&quot;NEW&quot;的字符指针 // cpp[-1][-1] + 1 向后跳过1个字符，--&gt; 字符'E'的地址 // 则打印字符串 &quot;EW&quot; ![图4](file://C:\\Users\\Turbo\\Desktop\\2. 指针进阶\\image\\image_16.png) ","link":"https://listen2022.github.io/fR1IhsCmE/"},{"title":"9. C语言进阶--数据存储","content":"1. 数据存储 1.1 数据类型 1.1.1 整形 char unsigned char signed char short unsigned short [int] signed short [int] int unsigned int signed int long unsigned long [int] signed long [int] 1.1.2 浮点型 float double 1.1.3 构造类型 // 数组 // 结构体 struct // 枚举类型 enum // 联合类型 union 1.1.4 指针类型 int* pi; char* pc; float* pf; void* pv; 1.1.5 空类型 void // 空类型（无类型） // 通常应用于函数的返回类型、函数的参数、指针类型 1.2 整形在内存中的存储 变量的创建需要在内存中开辟空间，空间的大小根据不同的类型而定。 int a = 100; int b = -200; // a分配四个字节的内存空间 // 无论是在32位还是64位环境下，int类型都是4byte // 表示范围在limits.h中定义 1.2.1 原码、反码、补码 计算机中有符号数的三种表示方法。整数在计算机中以补码的形式存储。 原码 反码：原码符号位不变，其他位按位取反 补码：反码加一 正数的原码、反码、补码相同。 1.2.2 为什么数据在计算机中以补码形式存储？ 在计算机系统中，数值一律用补码来表示和储存。因为使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理**（CPU只有加法器）**此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。 1.3 大小端字节序 1.3.1 大小端介绍 大端（存储）模式：是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中； 小端（存储）模式：是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。 ![](file://C:\\Users\\Turbo\\Desktop\\1. 数据存储\\image\\image.png) 1.3.2 为什么又大端和小端？ 在计算机系统中，以字节为单位，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short类型，32bit的int类型，以及long类型。另外，对于位数大于8位的处理器，例如16位或32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着如何将多个字节安排的问题。因此就导致了大端和小端两种存储模式。 1.3.3 相关习题 简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。 int main() { int a = 1; char* p = (char*) &amp;a; if (*p==1) { printf(&quot;小端\\n&quot;); } else { printf(&quot;大端\\n&quot;); } return 0; } 1.4 浮点型在内存中的存储 1.4.1 浮点类型 float // 4byte double // 8byte long double // 8byte // 表示范围再float.h中定义 1.4.2 IEEE754 C/C++中的浮点数采用IEEE754。根据过国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的格式： (-1)S*M*2E （E为指数，2为基数，M为尾数） (-1)^S 符号位 当S=0，V为正数；当S=1，V为负数。 M 有效数字，2&gt;M≥1。 2^E 指数位。 // 浮点数举例 // 十进制：5.5 // 二进制：101.1 -&gt; 1.011 * 2 ^ 2 1.011为尾数，2(第一个)为基数，2(第二个)为指数 // -&gt; (-1) ^ 0 * 1.011 * 2 ^ 2 // -&gt; S=0; E=2; M=1.011 其他规定 对于E，E是一个无符号整数。而科学计数法中E可能出现负值。为避免这种情况，在存储E时，对于float类型，再加上127；对于double类型，再加上1023。 // 例： // 十进制：0.5 // 二进制：0.1 (float) // 科学计数法：(-1)^0 * 1.0 * 2^(-1) // S=0; E=-1+127=126 对于M，M表示为1.xxxxxx，可见其中的1时固定不变的。所以在存储中可将其省略，将E变成xxxxxx，只将小数部分存储在内存中，节省1bit空间。 // 例： // 同上，十进制0.5的二进制表示为0.1(float) // 科学计数法：(-1)^0 * 1.0 * 2^(-1) // E=&gt;1.000000=&gt;00000 ![](file://C:\\Users\\Turbo\\Desktop\\1. 数据存储\\image\\image_1.png) 1.4.3 读取 E不全为1，也不全为0 指数E的计算值减去127（或1023），得真实值，再将M加上第一位的1。 E全为0 浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。为了表示+/-0，以及接近于0的很小的数字。 E全为1 如果有效数字M全为0，表示+/-无穷大（正负取决于符号位S）。 其他：浮点数在内存中也存在大小端问题。 1.4.4 实例1 int main() { int n = 9; float* pf = (float*)&amp;n; // 00000000000000000000000000001001 printf(&quot;n的值为：%d\\n&quot;, n); // 9 printf(&quot;*pf的值为：%f\\n&quot;, *pf); // 0.0 // 0 00000000 00000000000000000001001 // S=0; E=1-127=-126; M=0.00000000000000000001001 // 0.00000000000000000001001 * 2 ^ (-126) // float的精度为6 则打印0.000000 *pf = 9.0; // 0 01111100 00100000000000000000000 printf(&quot;n的值为：%d\\n&quot;, n); // 1091567616 printf(&quot;*pf的值为：%f\\n&quot;, *pf); // 9.0 return 0; } ![](file://C:\\Users\\Turbo\\Desktop\\1. 数据存储\\image\\image_2.png) 1.4.5 实例2 int main() { float f = 9.0; // 0 01111100 00100000000000000000000 printf(&quot;%d\\n&quot;, f); // 以浮点型存储，浮点型读取，整形打印 int* p = (int*)&amp;f; printf(&quot;%d\\n&quot;, *p); // 以浮点型存储，整形读取，整形打印 return 0; } ![](file://C:\\Users\\Turbo\\Desktop\\1. 数据存储\\image\\image_3.png) 1.5 习题 1.5.1 一 int main() { char a = -1; signed char b = -1; unsigned char c = -1; // -1的二进制 // 10000000000000000000000000000001 -&gt; 原码 // 11111111111111111111111111111110 -&gt; 反码 // 11111111111111111111111111111111 -&gt; 补码 // 存放到char类型变量中，高位截断 // 在a b c中存放的都是11111111 printf(&quot;%d %d %d\\n&quot;, a, b, c); // %d打印整形，补码整形提升，打印原码 // a b 整型提升 高位补1 // c 无符号整型提升 高位补0 // a b 中的值为 11111111111111111111111111111111 // c 中的值为 00000000000000000000000011111111 // 以原码打印 a, b = -1; c = 255; return 0; } // 补充 // 1. char到底是signed char 还是 unsigned char? // C语言标准并没有规定，取决于编译器（但大多数编译器都是signed char） // 2. int是signed int 还是 unsigned int? // C语言规定int没有unsigned作为前缀时为signed int 2.5.2 二 int main() { char a = -128; // 10000000000000000000000010000000 // a = 10000000 printf(&quot;%u\\n&quot;, a); // %u打印无符号整数 // a是有符号char 整型提升 高位补1 // 11111111111111111111111110000000 return 0; } 2.5.3 三 int main() { char a = 128; // 00000000000000000000000010000000 // a 10000000 printf(&quot;%u\\n&quot;, a); // a是有符号char 整型提升 高位补1 // 11111111111111111111111110000000 } // 10000000 在内存中直接被解析为-128 // 有符号char的取值范围为-128~127，如果存放的值大于127，则被解析为负数 // 例如128会被解析为-128 2.5.4 四 int main() { int i = -20; // 10000000000000000000000000010100 -20 原码 // 11111111111111111111111111101100 -20 补码 unsigned int j = 10; // 00000000000000000000000000001010 10 printf(&quot;%d\\n&quot;, i + j); // 相加 // 11111111111111111111111111110110 补码 // 10000000000000000000000000001010 原码 -10 // %d，认为内存中放的是有符号int类型 return 0; } // 站在内存的视角 2.5.5 五 int main() { int a = -20; unsigned int b = 10; if (a + b &gt; 0) { printf(&quot;a+b&gt;0&quot;); }else{ printf(&quot;a+b&lt;=0&quot;); } return 0; } // int类型和无符号int类型相加，int类型转换为unsigned int类型 ![](file://C:\\Users\\Turbo\\Desktop\\1. 数据存储\\image\\image_4.png) 2.5.6 六 int main() { unsigned int i; // 无符号整数，i&gt;=0恒成立 for ( i = 9; i &gt;= 0; i--) { printf(&quot;%u\\n&quot;, i); } return 0; } // 无限循环 ![](file://C:\\Users\\Turbo\\Desktop\\1. 数据存储\\image\\image_5.png) 2.5.7 七 #include &lt;string.h&gt; int main() { char a[1000]; int i; for ( i = 0; i &lt; 1000; i++) { a[i] = -1 - i; } printf(&quot;%d\\n&quot;, strlen(a)); return 0; } // -1 - i // -1 -2 -3 ... -128 127 126 ... 3 2 1 0('\\0') // 128 + 127 = 255 ![](file://C:\\Users\\Turbo\\Desktop\\1. 数据存储\\image\\image_6.png) 2.5.8 八 unsigned char i = 0; int main() { for ( i = 0; i &lt;= 255 ; i++) { printf(&quot;Hello World!\\n&quot;); } return 0; } ","link":"https://listen2022.github.io/KqgOIuMEN/"},{"title":"8. C语言--调试","content":"8.调试 8.1 什么是bug？ 程序错误，即英文的Bug，也称为缺陷、臭虫，是指在软件运行中因为程序本身有错误而造成的功能不正常、死机、数据丢失、非正常中断等现象。 史上的第一只 &quot;Bug&quot; ，真的是因为一只飞蛾意外走入一电脑而引致故障，因此Bug从原意为臭虫引申为程序错误。 程序错误参考资料 (baidu.com) 8.2 调试是什么？有多重要？ 8.2.1 调试概念 调试（英语：Debugging/Debug）：又称排错，将编制的程序投入实际运行前，用手工或编译程序等方法进行测试，修正语法错误和逻辑错误的过程。是发现和减少计算机程序或电子仪器设备中程序错误的一个过程。 8.2.2 基本步骤 发现错误程序的存在 以隔离、消除等方式对错误进行定位 确定错误产生的原因 提出纠正错误的解决办法 对程序错误予以改正，重新测试 8.3 debug和release的介绍 8.3.1 Debug 调试版本，它包含调试信息，并且不做任何优化，便于程序员调试程序。并且程序中只有包含了额外的辅助信息才可以进行调试。 8.3.2 Release 发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好的使用。 8.3.3 总结 Release版本相较于Debug版本的可执行文件，空间更小，运行更快。 8.4 windows环境调试介绍 Linux系统中使用gdb(GNU symbolic debugger) 8.4.1 快捷键 快捷键 操作 Ctrl + Alt + P 附加到进程 F10 调试单步执行 F5 开始调试 Shift + F5 停止调试 Ctrl + Alt + Q 添加快捷匹配 F9 设置或删除断点 VisualStudio2019快捷键汇总_Dahlin哥's 博客-CSDN博客_vs快捷键 8.4.2 窗口 重点：某些窗口只有当调试起来（快捷键 F10和 F11）之后才会显示。 8.4.3 断点 设置断点，如果开始执行（不调试），程序直接执行结束，并不会在断点处暂停。所以使用断点必须调试执行才能生效。断点之前的程序正常执行，到断点处暂停。使用断点窗口，可以方便的查看多个源文件中的断点位置。 添加条件 在循环中设置断点的条件，可以循环到一定的次数之后进行暂停。 其他 使用F5移动到下一个断点。 8.4.4 监视 监视各个变量值的变化。可以自己添加需要监视的标识符和不需要监视的标识符。 此外还有自动监视和局部变量窗口。自动监视窗口可以自动检测需要监视的变量。局部变量窗口显示局部变量的变化。 8.4.5 调用堆栈 函数的调用逻辑。 8.4.6 其他 内存窗口，可以设置每行显示的列数。 8.5 调试实例 8.5.1 阶乘之和 找出代码中的bug int main() { int n = 3; int sum = 0; int mul = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { mul *= j; } sum += mul; } printf(&quot;%d\\n&quot;, sum); return 0; } // bug原因，mul变量在每次循环之后并没有重置为1 8.5.2 数组越界死循环 寻找原因 int main() { int i = 0; int arr[10] = { 0 }; for ( i = 0; i &lt;= 12; i++) { arr[i] = 0; printf(&quot;Hello\\n&quot;); } return 0; } // vs2013~2019出现死循环 // vs2022中正常循环12次，并没有出现数组访问越界错误 // 下图为vs2022运行结果图 8.6 如何写出好（易于调试）的代码 8.6.1 优秀的代码 代码正常运行 bug很少 效率高 可读性高 可维护性高 注释清晰 文档齐全 8.6.2 常见的coding技巧 使用assert 尽量使用const 养成良好的编码风格 添加必要的注释 避免编码的陷阱 8.6.3 实例 模拟实现库函数strcpy 介绍 声明 char *strcpy(char *dest, const char *src) 参数 dest: 用于存储复制内容的目标数组 src: 要复制的字符串 返回值：返回指向目标字符串的指针 代码 库函数 #include &lt;string.h&gt; int main() { char arr1[20] = { 0 }; char arr2[] = &quot;Hello World!&quot;; strcpy(arr1, arr2); printf(arr1); return 0; } // 需要在源文件最开始加入#define _CRT_SECURE_NO_WARNINGS 自实现 void my_strcpy(char* dest, char* sour) { while (*sour != '\\0') { *dest = *sour; dest++; sour++; } *dest = *sour; } int main() { char arr1[20] = { '\\0'}; char arr2[] = &quot;Hello&quot;; my_strcpy(arr1, arr2); printf(arr1); return 0; } 优化1 void my_strcpy(char* dest, char* sour) { while (*sour != '\\0') { *dest++ = *sour++; } *dest = *sour; } 优化2 void my_strcpy(char* dest, char* sour) { while (*sour) { *dest++ = *sour++; } *dest = *sour; } 优化3 void my_strcpy(char* dest, char* sour) { while (*dest++ = *sour++); // 先将*sour赋值给*dest // 获得整个表达式的结果 // 并判断整个表达式的结果是否为假 // 如果为真 再对dest和sour进行自增 } 优化4 void my_strcpy(char* dest, char* sour) { assert(src != NULL); // 断言 assert(dest != NULL); // 断言 while (*dest++ = *sour++); } // assert的使用需要引用头文件&lt;assert.h&gt; // assert中的表达式类似于if中的表达式 优化5 void my_strcpy(char* dest, const char* sour) { assert(src != NULL); assert(dest != NULL); while (*dest++ = *sour++); } // const char* sour // sour指向的对象的内容不能被修改 // 防止将dest中的内容复制到sour中 // 即使发生了问题，发生的也只是语法错误，也容易找出并解决问题 // 另外const char* sour中的const只需要在*前面，并不一定要在char前面 // 即：char const * sour 但一般char*是一种类型，不拆开 常量指针和指针常量 int main() { int m = 100; int n = 10; //const int* p = &amp;n; // 指针变量指向的对象不能改变 //*p = 100; // × //p = &amp;m; // √ //int* const p = &amp;n; // 指针变量的值不能改变 //p = &amp;m; // × //*p = m; // √ //const int* const p = &amp;n; // 指针变量和指针变量的值都不能改变 //p = &amp;m; // × //*p = m; // × //const int* p; // 称为常量指针 //int* const p; // 称为指针常量 return 0; } 优化6 char* my_strcpy(char* dest, const char* sour) { assert(src != NULL); assert(dest != NULL); char* ret = dest; while (*dest++ = *sour++); return ret; // 返回目标空间的其实地址（为了更好的看到目标地址发生的变化） } // 链式访问功能 模拟实现库函数strlen 自实现 size_t my_strlen(const char *s) { assert(s); size_t len = 0; while (*s++)len++; return len; } // size_t 相当于 unsigned int int main() { char s[] = &quot;hello&quot;; int len = my_strlen(s); printf(&quot;%d\\n&quot;, len); return 0; } 参考代码 size_t __cdecl strlen ( const char * str ) { const char *eos = str; while( *eos++ ) ; return( eos - str - 1 ); } // 参考代码并不代表真实实现 // __cdecl表示函数调用约定，不影响函数使用 8.7 编程常见的错误 错误类型 编译型错误 直接看错误提示信息（双击定位出错位置），解决问题。或者凭借经验就可以搞定。相对来说简单。 链接型错误 看错误提示信息，主要在代码中找到错误信息的标识符，然后定位问题所在。一般是标识符名不存在或者拼写错误。 运行时错误 借助调试信息，逐步定位问题。难度最大。 ","link":"https://listen2022.github.io/ZD0FIx_5C/"},{"title":"7. C语言--结构体","content":"7.结构体 7.1 结构体 类型的声明 7.1.1 介绍 结构体是由一批数据组合而成的结构型数据。组成结构型数据的每个数据称为结构型数据的“成员”，其描述了一块内存区间的大小及解释意义。 结构体是一种数据类型，地位同等于int、float等 结构体类型不是系统定义好的，由程序员自己定义 使用struct关键字来标识定义的结构体类型 结构体通常用来表示类型不同但又相关的若干数据 关键字struct和结构体名组成类型标识符 成员又称为成员变量，是结构体所包含的若干个基本的结构类型 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针 7.1.2 声明 // 格式： struct tag { member-list member-list member-list ... } variable-list; // tag: 结构体标签 // member-list: 变量定义 // variable-list: 结构体变量 // 一般情况下：tag、member-list、variable-list 3部分至少出现两个 // 使用typedef创建新类型 typedef struct { int a; char b; double c; } Simple; // 可以用Simple作为类型声明新的结构体变量 // eg: Simple s; 7.1.3 例 int main() { struct Person { char name[10]; short age; }; struct Student { char id[20]; struct Person p; }; return 0; } 7.2 结构体初始化 7.2.1 定义时初始化 int main() { struct Person { char name[10]; short age; }; struct Student { char id[20]; struct Person p; } s = {&quot;1914121006&quot;, {&quot;listen&quot;, 25}}; return 0; } 7.2.2 定义后初始化 struct Person { char name[10]; short age; }; struct Student { char id[20]; struct Person p; }; int main() { struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} }; return 0; } 7.3 结构体成员访问 7.3.1 . struct Person { char name[10]; short age; }; struct Student { char id[20]; struct Person p; }; int main() { struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} }; printf(&quot;id: %s\\nname: %s\\nage: %d\\n&quot;, s.id, s.p.name, s.p.age); return 0; } 7.3.2 → struct Person { char name[10]; short age; }; struct Student { char id[20]; struct Person p; }; int main() { struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} }; struct Student* ps = &amp;s; printf(&quot;id: %s\\nname: %s\\nage: %d\\n&quot;, (*ps).id, (*ps).p.name, (*ps).p.age); printf(&quot;id: %s\\nname: %s\\nage: %d\\n&quot;, ps-&gt;id, ps-&gt;p.name, ps-&gt;p.age); return 0; } 7.4 结构体传参 struct Person { char name[10]; short age; }; struct Student { char id[20]; struct Person p; }; void print1(struct Student s) { printf(&quot;id: %s\\nname: %s\\nage: %d\\n&quot;, s.id, s.p.name, s.p.age); } void print2(struct Student* ps) { printf(&quot;id: %s\\nname: %s\\nage: %d\\n&quot;, ps-&gt;id, ps-&gt;p.name, ps-&gt;p.age); } int main() { struct Student s = { &quot;1914121006&quot;, {&quot;listen&quot;, 25} }; print1(s); // 值传递 print2(&amp;s); // 址传递 return 0; } print1和pirnt2对比： print1: 值传递，更安全。传参时，需要开辟一块与结构体变量s同等大小的区域用于将s复制一份到print1函数中，相比于print2消耗更多的内存资源。此外，print1函数中不可以修改结构体变量s中的值。 print2: 址传递。传参时，在32位平台使用4字节内存资源，在64位平台使用8字节。相比于print1，消耗更少的内存资源。此外，print2可以修改结构体变量s中成员变量的值。但print2相对于print1不安全。 函数传参的时候，参数是需要压栈的，并且按照参数列表的顺序，从右向左压栈。如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降。 结论：结构体传参时，要传结构体的指针。 ","link":"https://listen2022.github.io/bDOIBKF8Z/"},{"title":"6. C语言--指针","content":"6.指针 6.1 指针是什么？ 在计算机中，所有的数据都是存放在存储器中的，不同的数据类型占有的内存空间的大小各不相同。内存是以字节为单位的连续编址空间，每一个字节单元对应着一个独一的编号，这个编号被称为内存单元的地址。比如：int 类型占 4 个字节，char 类型占 1 个字节等。系统在内存中，为变量分配存储空间的首个字节单元的地址，称之为该变量的地址。地址用来标识每一个存储单元，方便用户对存储单元中的数据进行正确的访问。在高级语言中地址形象地称为指针。 6.1.1 内存与地址 指针相对于一个内存单元来说，指的是单元的地址，该单元的内容里面存放的是数据。在 C 语言中，允许用指针变量来存放指针，因此，一个指针变量的值就是某个内存单元的地址或称为某内存单元的指针。 6.1.2 内存空间的访问 直接访问：变量代表有名字的内存单元，通过变量名直接访问内存空间。 间接访问：指针是内存空间的地址，通过指针解引用间接访问内存空间。 6.1.3 指针声明 type* pointer_name; // type指明该指针变量的类型 // *说明该变量是一个指针变量 6.1.4 指针大小 int main() { printf(&quot;%u\\n&quot;, sizeof(int*)); printf(&quot;%u\\n&quot;, sizeof(char*)); printf(&quot;%u\\n&quot;, sizeof(float*)); return 0; } 32位平台，占据4byte 64位平台，占据8byte 6.2 指针和指针类型 6.2.1 指针的类型 指针的类型和指针所指向的对象的类型是两个不同的概。 int main() { int a = 100; int* pa = &amp;a; // 其中`*`表示pa是一个指针变量，`int`表示pa是一个int类型指针 return 0; } 指针的大小都是一样的，为什么不创建一个通用类型指针？ 6.2.2 指针类型的意义 指针类型决定了指针解引用的权限（能访问字节的数目） int main() { int a = 0xffffffff; int* pi = &amp;a; // int类型指针 *pi = 1; // 解引用操作四个字节 printf(&quot;%x\\n&quot;, a); // char* pc = &amp;a; // *pc = 1; // printf(&quot;%x\\n&quot;, a); return 0; } int main() { int a = 0xffffffff; // int* pi = &amp;a; // *pi = 1; // printf(&quot;%x\\n&quot;, a); char* pc = &amp;a; // char类型指针 *pc = 1; // 解引用只操作一个字节 printf(&quot;%x\\n&quot;, a); return 0; } 指针类型决定了指针的步长 int main() { int arr[10] = { 0 }; int* pi = arr; char* pc = arr; printf(&quot;%x&quot;, pi); printf(&quot;%x&quot;, pi+1); // int类型指针+1，改变4个字节，步长为4byte printf(&quot;%x&quot;, pc); printf(&quot;%x&quot;, pc+1); // char类型指针+1，改变1个字节，步长为1byte return 0; } 6.2.3 使用 int main() { int arr[10] = { 0 }; int* pa = arr; // 数组名是数组第一个元素的指针 for (int i = 0; i &lt; 10; i++) { *pa = 100; pa++; } for (int i = 0; i &lt; 10; i++) { printf(&quot;%d\\n&quot;, arr[i]); } return 0; } 如果将int类型指针换为char类型指针，如下 6.3 野指针 定义：指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）。 6.3.1 野指针的成因 指针变量未初始化 类似于：去酒店，没有办理入住手续，直接随便找个房间就住。 int main() { int* p; // 局部变量指针未初始化，默认为随机值 *p = 100; return 0; } 指针越界访问 类似于：酒店房间号只有000~100，而你非要去找房间号为111的房间。 int main() { int arr[10] = { 0 }; int* p = arr; for (int i = 0; i &lt;= 10; i++) { *p = i; p++; } } 指针指向的空间释放 类似于：都已经办理退房手续，你仍然要在房间里住。 // 非法访问内存，指针指向的空间不属于该程序 int* func() { int a = 10; return &amp;a; // 函数返回之后，将a的内存空间释放，还给操作系统 } int main() { int* p = func(); *p = 20; return 0; } 6.3.2 如何避免野指针 指针初始化 // 方式一 int* p = NULL // NULL在stdio.h头文件中 // 方式二 int a = 100; int* p = &amp;a; 小心指针越界 // 数组越界 // C语言本身是不会检查数组是否越界 指针指向空间及时置NULL *p = NULL; // 此时p依然不能使用 // 例如： int main() { int* p = NULL; *p = 100; // NULL属于操作系统，空间地址并没有分配给用户，所以用户不能访问 return 0; } 指针使用前检查有效性 int *p = NULL; if(p != NULL){ code... } 6.3.3 实例 #include &lt;stdio.h&gt; main() { int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p = a + 5, *q = NULL; *q = *(p+5); printf(&quot;%d %d\\n&quot;, *p, *q); } // 结果：运行后报错 6.4 指针运算 6.4.1 + - int main() { int arr[5]; int* p; for (p = &amp;arr[0]; p &lt; &amp;arr[5]; ) { *p++ = 0; // 相当于： // *p = 0; // p++; } return 0; } // 随着数组索引增大，地址由低到高变化 6.4.2 &gt; ≥ &lt; ≤ == 指针的关系运算。 // 打印数组中的元素 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int* p = arr; // arr第一个元素的地址 int* pend = p + 4; // arr最后一个元素的地址 while (p&lt;=pend) { printf(&quot;%d\\n&quot;, *p); p++; } return 0; } 6.4.3 指针-指针 两个指针相减的结果是数组中两个元素之间的个数。指针相加是没有意义的（类似日期与日期相加）。 int main() { int arr[10] = { 0 }; printf(&quot;%d\\n&quot;, &amp;arr[9]-&amp;arr[0]); return 0; } 指针相减的前提：两个指针指向同一块区域。 6.4.4 应用（求字符串长度len） 方法一：库函数 #include &lt;string.h&gt; int main() { char s[] = &quot;Hello&quot;; int len = strlen(s); printf(&quot;%d\\n&quot;, len); } 方法二：计数器 int my_strlen(char* p) { int count = 0; while (*p != '\\0') { count++; p++; } return count; } int main() { char s[] = &quot;Hello&quot;; int len = my_strlen(s); // 传参时，传递的是字符串的第一个字符的地址 printf(&quot;%d\\n&quot;, len); } 方法三：指针相减 int my_strlen(char* p) { char* p0 = p; while (*p != '\\0') { p++; } return p - p0; } int main() { char s[] = &quot;Hello&quot;; int len = my_strlen(s); // 传参时，传递的是字符串的第一个字符的地址 printf(&quot;%d\\n&quot;, len); } 6.4.4 其他 for(vp = &amp;values[N_VALUES-1]; vp &gt;= &amp;values[0]; vp--) { *vp = 0; } // 在大部分的编译器上可以正常运行，然而应避免这样编码，因为标准并不保证它可行。 标准规定 允许指向数组元素的指针与指向数组最后一个元素后面的哪个内存位置的指针比较，但不允许与指向第一个元素之前的那个内存位置的指针进行比较。 6.5 指针和数组 6.5.1 数组名是数组首元素的地址 int main() { int arr[5] = { 0 }; printf(&quot;%p\\n&quot;, arr); printf(&quot;%p\\n&quot;, &amp;arr[0]); return 0; } 6.5.2 通过指针操作数组元素 int main() { int arr[5] = { 0 }; int* p = arr; for (int i = 0; i &lt; 5; i++) { *(p + i) = i; } for (int i = 0; i &lt; 5; i++) { printf(&quot;%d\\n&quot;, *(p+i)); } } 6.5.3 下标引用操作符的交换律 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int* p = arr; // 访问下标为3的元素的底层原理： // arr[3] =&gt; *(p+3) // 根据加法的交换律，可得 // *(p+3) = *(3+p) // 则 // arr[3] = 3[arr]; // []下标引用操作符也具有交换律 printf(&quot;%d\\n&quot;, arr[3]); printf(&quot;%d\\n&quot;, 3[arr]); printf(&quot;%d\\n&quot;, p[3]); printf(&quot;%d\\n&quot;, 3[p]); } 6.6 二级指针 6.6.1 创建 int main() { int n = 100; int* pn = &amp;n; // 一级指针 int** ppn = &amp;pn; // 二级指针 } // 依次类推，还有三级、四级... // 指针变量中存储了地址，跟普通变量一样，需要开辟一块内存空间用来存放数据 // 而指针变量所在的地址，用二级指针来表示 // pnn中存放的是pn的地址 // pn中存放的是n的地址 // n中存放的是数据 6.6.2 访问 int main() { int n = 100; int* pn = &amp;n; // 一级指针 int** ppn = &amp;pn; // 二级指针 // *pnn = pn; // *pn = n; // 所以：**pnn = n; 即通过**pnn即可访问变量n } 6.7 指针数组 int arr1[10]; // 整形数组 float arr2[10]; // 浮点型数组 char arr3[10]; // 字符型数组 int* parr1[10]; // 整形指针数组 float* parr2[10]; // 浮点型指针数组 char* parr3[10]; // 字符型指针数组 ","link":"https://listen2022.github.io/6-c-yu-yan-zhi-zhen/"},{"title":"5. C语言--操作符","content":"5.操作符 5.1 算术操作符 + - * / % 除%操作符之外，其他几个操作符可以作用于整数和浮点数。 对于/操作符如果两个操作符都为整数，执行整数除法。只要有一个浮点数，则执行浮点数除法。 float num = 1 / 2; // num=0.000000; float num = 1 / 2.0; // num=0.500000; // 这里的2.0 是double类型 而num为float类型 // 可以做如下调整 float num = 1f / 2.0f; double num = 1 / 2.0; %操作符两端必须都是整数，可以是负数，但不能为0。 5.2 移位操作符 &gt;&gt; &lt;&lt; 5.2.1 非负整数的二进制表示形式 原码：直接根据数值写出二进制 反码：原码符号位不变，其他位按位取反 补码：反码加1 // 非负整数在内存中存放的是原码（非负整数的原码、反码、补码相同） // 负整数在内存中存放的是补码 5.2.2 左移 算数左移和逻辑左移相同，都是左边抛弃，右边补0。 5.2.3 右移 算术右移（通常采用） 向右移动，首位补原二进制位的第一位 逻辑右移 向右移动，首位补0 // 只能移动非负整数位 int main() { int ret = -1 &gt;&gt; 1; printf(&quot;%d\\n&quot;, ret); return 0; } 5.3 位操作符 &amp; | ^ // 操作数必须为整数 5.3.1 按位与 int main() { int ret = 3 &amp; 4; // 00000000000000000000000000000011 // &amp; // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } 5.3.2 按位或 // 按位或 int main() { int ret = 3 | 4; // 00000000000000000000000000000011 // | // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } 5.3.3 按位异或 相同为0，相异为1 int main() { int ret = 3 ^ 4; // 00000000000000000000000000000011 // ^ // 00000000000000000000000000000100 printf(&quot;%d\\n&quot;, ret); return 0; } // 奇数^奇数=偶数 // 奇数^偶数=奇数 // 偶数^偶数=偶数 5.3.4 题目 交换两个int变量的值，不使用第三个变量 方法一 int main() { int a = 3; int b = 4; a = a + b; b = a - b; a = a - b; printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } // 问题：数字过大，内存溢出 方法二 int main() { int a = 3; int b = 4; a = a ^ b; b = a ^ b; a = a ^ b; printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } // 没有进位，不可能发生溢出 // 异或特点： // 1.任何数和他本身异或，结果为0 // 2.任何数和0异或，结果为他本身 // 底层逻辑： // b = a ^ b ^ b = a (前两行代码) // a = a ^ b ^ b ^ a ^ b = b (第三行代码) 5.3.5 练习 编写代码实现：求一个整数存储在内存中的二进制中1的个数 方法一 int main() { int num = 5; int count = 0; for (int i = 0; i &lt; 32; i++) { if (num % 2 == 1) { count++; } num = num &gt;&gt; 1; } printf(&quot;count=%d\\n&quot;, count); return 0; } 缺点：不能统计负数的二进制中1的个数。 方法二 int main() { int num = -5; int count = 0; for (int i = 0; i &lt; 32; i++) { if ((num &gt;&gt; i) &amp; 1) { count++; } } printf(&quot;count=%d\\n&quot;, count); return 0; } // -5 // 原码 10000000000000000000000000000101 // 补码 11111111111111111111111111111011 // 右移0位 // 11111111111111111111111111111011 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 // 右移一位 // 01111111111111111111111111111101 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 // 右移二位 // 00111111111111111111111111111110 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000000 -&gt; 0 // ... // 右移31位 // 00000000000000000000000000000001 &amp; 00000000000000000000000000000001 // 00000000000000000000000000000001 -&gt; 1 方法三 int main() { int num = -5; int count = 0; while (num) { num = num &amp; (num - 1); count++; } printf(&quot;count=%d\\n&quot;, count); return 0; } // num &amp; (num - 1) // 11111111111111111111111111111011 =&gt; num // 11111111111111111111111111111011 &amp; (11111111111111111111111111111011 - 1) // 11111111111111111111111111111011 &amp; 11111111111111111111111111111010 // 11111111111111111111111111111010 =&gt; num // 11111111111111111111111111111010 &amp; (11111111111111111111111111111010 - 1) // 11111111111111111111111111111010 &amp; 11111111111111111111111111111001 // 11111111111111111111111111111000 =&gt; num // ... // 每次把num&amp;(num-1)的结果再赋值给num // 每num&amp;(num-1)运算一次，就会将num中的1变成0 // 通过n次num&amp;(num-1)运算使得num=0 // 此时n为num的二进制中1的个数 5.4 赋值操作符 = += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= |= ^= // 连续赋值： int a = 0; int b = 0; int c = 1; a = b = c + 1; // 从由向左赋值（不推荐） 5.5 单目操作符 只有一个操作数 ! // 逻辑反操作 - // 负 + // 正 sizeof // 操作数类型长度 ~ // 按位取反 -- // 前置 后置 ++ // 前置 后置 * // 解引用(间接访问)操作符 &amp; // 取址 (type) // 强制类型转换 5.5.1 sizeof sizeof是一个操作符，不是函数。单位：字节 例1 int main() { short s = 5; int a = 10; printf(&quot;%d\\n&quot;, sizeof(s = a + 2)); // sizeof括号中放的表达式，不参与运算 // 在编译期间处理sizeof(s = a + 2); 而s = a + 2在程序运行时计算 // 大数据放在小空间里被截断 printf(&quot;%d\\n&quot;, s); // 5 return 0; } 例2 int main() { int a = 10; printf(&quot;%d\\n&quot;, sizeof(a)); printf(&quot;%d\\n&quot;, sizeof a); printf(&quot;%d\\n&quot;, sizeof(int)); //printf(&quot;%d\\n&quot;, sizeof int); char arr[10] = { 0 }; printf(&quot;%d\\n&quot;, sizeof(arr)); printf(&quot;%d\\n&quot;, sizeof arr); printf(&quot;%d\\n&quot;, sizeof(char [10])); } 例3 void foo1(int arr[10]) { printf(&quot;%d\\n&quot;, sizeof(arr)); } void foo2(char arr[10]) { printf(&quot;%d\\n&quot;, sizeof(arr)); } int main() { int arr1[10] = { 0 }; char arr2[10] = { 0 }; printf(&quot;%d\\n&quot;, sizeof(arr1)); // 40 printf(&quot;%d\\n&quot;, sizeof(arr2)); // 10 foo1(arr1); // 4或8 foo2(arr2); // 4或8 return 0; } // 数组作为函数参数传递时，实际传递的是数组的指针 5.5.2 ~ 按位取反 int main() { int a = 13; // 00000000000000000000000000001101 // 将a的二进制位第五位置零 // 00000000000000000000000000001101 -&gt; 13的二进制 // 00000000000000000000000000010000 -&gt; 1&lt;&lt;4 // | -&gt; 按位或 // 00000000000000000000000000011101 -&gt; 结果29 a = a | (1 &lt;&lt; 4); printf(&quot;%d\\n&quot;, a); // 将a的二进制位第五位置一 // 00000000000000000000000000011101 -&gt; 29的二进制 // 11111111111111111111111111101111 -&gt; ~(1&lt;&lt;4) // &amp; -&gt; 按位与 // 00000000000000000000000000001101 -&gt; 结果13 a = a &amp; (~(1 &lt;&lt; 4)); printf(&quot;%d\\n&quot;, a); return 0; } 5.5.3 ++/— // 前置：先++，再使用 // 后置：先使用，再++ // (使用包括赋值和函数传参) 后++ 先++ 垃圾代码 int main() { int a = 1; int b = (++a) + (++a) + (++a); printf(&quot;%d\\n&quot;, b); return 0; } // 运行结果：vs2019中结果是12 // linux中结果是10 // 垃圾代码，不做过多研究 5.5.4 &amp; * &amp; // 取址 * // 解引用 例 int main() { int num = 100; // &amp;获取对象所处的内存地址，取址操作符 int* pn = &amp;num; // 此处*不是操作符，仅说明pn是一个指针变量 *pn = 200; // 此处*才是解引用操作符，将200赋值给pn所指的对象 printf(&quot;pn=%p, num=%d\\n&quot;, pn, num); return 0; } 5.5.5 (type) int main() { int num = (int)3.1315; // 强制类型转换 printf(&quot;%d\\n&quot;, num); return 0; } 5.6 关系操作符 &gt; &gt;= &lt; &lt;= != == // = 赋值 // == 判断是否相等 // 比较两个字符串是否相等不能使用== 5.7 逻辑操作符 &amp;&amp; 逻辑与：从前往后找到第一个为假的值返回0，否则返回1 || 逻辑或：从前往后找到第一个为真的值返回1，否则返回0 5.7.1 习题 如下代码运行结果： int main() { int i = 0, a = 0, b = 2, c = 3, d = 4; i = a++ &amp;&amp; ++b &amp;&amp; d++; //i = a++ || ++b || d++; printf(&quot;a=%d, b=%d, c=%d, d=%d\\n&quot;, a, b, c, d); } // &amp;&amp;: 左边确定为假，后边不用再进行计算 // ||: 左边确定为真，后边不用再进行计算 5.8 三目操作符 exp1 ? exp2 : exp3; // 如果exp1为真，则计算exp2，整个表达式的结果为exp2的结果，exp3不计算 // 如果exp2为假，则计算exp3，整个表达式的结果为exp3的结果，exp2不计算 例 int main() { int a = 3; int b = 4; int ret = 0; ret = a &gt; b ? a++ : b++; printf(&quot;%d\\n&quot;, ret); printf(&quot;a=%d, b=%d\\n&quot;, a, b); return 0; } 5.8 逗号表达式 exp1, exp2, exp3; // 从前往后依次执行，整个表达式的结果为最后一个表达式exp3的计算结果 5.9 下标引用 下标引用操作符有两个操作数，数组名和下标。 int main() { int arr[10] = { 0 }; // 此处[]不是操作符，仅用来指定数组的大小 arr[4] = 100; // 此处[]为操作符，指定数组中索引(或下标)为4的值为100 printf(&quot;arr[4]=%d\\n&quot;, arr[4]); return 0; } 5.10 函数调用 有一个或多个操作数，当没有参数时，只有函数名一个操作数；当有参数时，操作时个数为参数个数+1。 // 函数调用 int Add(int x, int y) // 此处()不是操作符，仅用来说明形参及其类型 { return x + y; } int main() { int ret = Add(3, 4); // 此处()为函数调用操作符，即使没有参数，也要有() 操作数：Add 3 4共3个 printf(&quot;%d\\n&quot;, ret); return 0; } 5.11 结构成员访问操作符 . -&gt; // 使用格式： 结构体变量.结构体成员变量名 结构体指针变量-&gt;结构体成员变量名 例 int main() { struct Person { char name[10]; int age; float height; }; printf(&quot;.操作符\\n&quot;); struct Person p = { &quot;listen&quot;, 22, 185.0 }; printf(&quot;name: %s\\n&quot;, p.name); printf(&quot;age: %d\\n&quot;, p.age); printf(&quot;height: %f\\n&quot;, p.height); struct Person* pp = &amp;p; printf(&quot;name: %s\\n&quot;, (*pp).name); printf(&quot;age: %d\\n&quot;, (*pp).age); printf(&quot;height: %f\\n&quot;, (*pp).height); printf(&quot;-&gt;操作符\\n&quot;); printf(&quot;name: %s\\n&quot;, pp-&gt;name); printf(&quot;age: %d\\n&quot;, pp-&gt;age); printf(&quot;height: %f\\n&quot;, pp-&gt;height); return 0; } 5.12 表达式求值 表达式求值的顺序一般是由操作符的优先级和结合性决定。同样，有些表达式的操作数再求值的过程中可能需要转换为其他类型。 5.12.1 隐式类型转换 C的整形算数运算总是至少以缺省整形类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换称为整形提升。 包括： 整形提升 算数转换 5.12.2 整型提升 概念 在表达式计算时，各种整形（只有比int小的类型才会发生整型提升）首先要提升为int类型，如果int类型不足以表示的话，就需要提升为unsigned int类型，然后再执行表达式的运算。 意义 虽然机器指令中可能有现两个8比特字节这种字节相加指令，但是一般用途的CPU是难以直接实现这样的字节相加运算的。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。而表达式的整型运算要在CPU的相应运算器件内执行。因此，两个char类型的数进行相加运算时，是在CPU中执行，自然而然的需要先转换为CPU内整型操作数的标准长度。 如何提升 按照最高位进行整型提升 正数整型提升：高位补0 负数整形提升：高位补1 无符号整数整形提升：高位补0 例1 int main() { char a = 3; char b = 127; char c = a + b; printf(&quot;%d\\n&quot;, c) return 0; } // 原理 char a = 3; //二进制： 00000011 char b = 127; //二进制：01111111 char c = a + b; // + 操作符 整型提升 //a 提升： 00000000000000000000000000000011 //b 提升： 00000000000000000000000001111111 // 相加： 00000000000000000000000010000010 //c 截断： 10000010 printf(&quot;c=%d\\n&quot;, c); // c是char类型，而使用%d打印，c 整形提升(高位补1) // 11111111111111111111111110000010 补码 // 11111111111111111111111110000001 反码（补码-1） // 10000000000000000000000001111110 原码（反码符号位不变，其余位取反） 例2 int main() { char a = 0xFF; // a整形提升之后为11111111111111111111111111111111 short b = 0xFFFF; // b整形提升之后为11111111111111111111111111111111 int c = 0xFFFFFFFF; if (a == 0xFF) { printf(&quot;a\\n&quot;); } if (b == 0xFFFF) { printf(&quot;b\\n&quot;); } if (c == 0xFFFFFFFF) { printf(&quot;c\\n&quot;); } printf(&quot;%d\\n&quot;, a == b); return 0; } // 其中a, b需要进行整形提升，而c不需要整形提升 // a, b整形提升之后变成了负数，所以a==0xFF和b == 0xFFFF为假 例3 int main() { char a = 1; printf(&quot;%u\\n&quot;, sizeof a); printf(&quot;%u\\n&quot;, sizeof -a); // 类型提升为int类型 printf(&quot;%u\\n&quot;, sizeof +a); printf(&quot;%u\\n&quot;, sizeof !a); // vs2022中为1 gcc中为4 return 0; } 5.12.3 算数转换 如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转化为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换。 long double double float unsigned long int long int unsigned int int 如果某个操作数的类型在上面这个列表中排名较低，那么首先要转化为另一个操作数的类型后执行运算。 例 int main() { float a = 1.23; int b = 5; float c = 0; c = a + b; // a为float类型，b为int类型， // float类型值和int类型值相加时， // int类型值被转换为float类型 printf(&quot;%f\\n&quot;, c); return 0; } 5.13 表达式的属性 值属性(运行后才能确定) 类型属性(可推断，编译时确定) 5.14 操作符的属性 复杂表达式的求值有三个影响的因素： 操作符的优先级 操作符的结合性 是否控制求值顺序（例如&amp;&amp; || ,） 5.14.1 优先级 运算符的优先级确定表达式中项的组合。如果优先级相同，则根据结合性确定计算顺序。 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= = 逗号 , 从左到右 5.14.2 一些问题表达式 表达式1 a * b + c * d + e * f; // 计算原理： // 方法1： a * b; c * d; e * f; a * b + c * d + e * f // 方法2： a * b; c * d; a * b + c * d; e * f; a * b + c * d + e * f; 表达式2 c + --c; // 无法确定左操作数是在--c之前还是--c之后确定 // 计算原理： // 方法1： --c; c; c + --c; // 方法2： c; --c; c + --c; 代码3-错误代码 int main() { int i = 10; i = i-- - --i * (i = -3) * i++ + ++i; printf(&quot;i = %d\\n&quot;, i); return 0; } // 输出结果在不同的编译器中结果不同 代码4- 错误代码 int fun() { static int count = 1; return ++count; } int main() { int answer; answer = fun() - fun() * fun(); // 2 - 3 * 4 (vs2022中) printf(&quot;%d\\n&quot;, answer); // -10(vs2022中) return 0; } // 结果不可控，fun()函数的调用顺序不同，结果不同 代码5-错误代码 int main() { int i = 1; int ret = (++i) + (++i) + (++i); printf(&quot;%d\\n&quot;, ret); } // VS -&gt; 12 // 执行原理 ++i; ++i; ++i; i = 4 4 + 4 + 4; // gcc -&gt; 10 ++i; ++i; i = 3; 3 + 3; ++i; i = 4; 3 + 3 + 4; 5.14.3 总结 对于同一个表达式或一段代码，即使有确定的优先级和结合性，仍然有不确定的计算或运行方式，且不同方式计算出来的结果不同，则该表达式或代码是存在问题的，不应该使用这样的表达式和代码。 ","link":"https://listen2022.github.io/5-c-yu-yan-cao-zuo-fu/"},{"title":"4. C语言--数组","content":"4.数组 数组是一组相同类型元素的集合。 4.1 一维数组的创建和初始化 4.1.1 创建 // 格式： type_t arr_name [const_n] // type_t 数组元素类型 // arr_name 数组名称 // const_n 常量表达式，指定数组大小 // 在VS2019、VS2022中不支持变长数组 // 在gcc编译器中支持 // 创建 int arr[10]; 4.1.2 初始化 int main() { int arr1[3] = {0, 1, 2}; // 完全初始化 int arr2[3] = {1, 2}; // 不完全初始化 int arr3[] = { 2, 4, 6, 8 }; // 自动确定数组长度 int arr4[5] = { 2, 4, 6, 8 }; // 与上一条语句等价 int arr5[10] = { 0 } // 不完全初始化，不是把10个元素全初始化为0 int arr6[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } char ch1[5] = &quot;ccc&quot;; // 'c' 'c' 'c' '\\0' 0 char ch2[] = &quot;ccc&quot;; // 'c' 'c' 'c' '\\0' char ch3[] = { 'c', 'c', 'c' }; // 'c' 'c' 'c' printf(&quot;%s\\n&quot;, ch1); printf(&quot;%s\\n&quot;, ch2); printf(&quot;%s\\n&quot;, ch3); return 0; } 4.2 一维数组的使用 4.2.1 获取 [] // 下标引用操作符 int arr[5] = { 1, 2, 3, 4, 5 }; arr[3]; // 获取数组arr中下标为3的元素的值 4.2.2 赋值 arr[3] = 444; 4.2.3 数组中元素的个数 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; int size = sizeof(arr) / sizeof(arr[0]); // 获取数组中元素的个数 // sizeof(arr)获取的是整个数组的大小，单位是字节 printf(&quot;%d\\n&quot;, size); } 4.3 一维数组在内存中的存储 4.3.1 %x和%p的区别 int main() { printf(&quot;%x\\n&quot;, 0x5f); printf(&quot;%p\\n&quot;, 0x5f); return 0; } // 指针是有长度的 4.3.2 存储方式 int main() { int arr[5] = { 1, 2, 3, 4, 5 }; for (int i = 0; i &lt; 5; i++) { printf(&quot;&amp;arr[%d] =&gt; %p\\n&quot;, i, &amp;arr[i]); } } // 现象：下标每增加1，地址变化4字节，刚好是int类型的大小 // 结论： // 一维数组在内存中是连续存放的 // 随着数组下标的增长，地址是由低到高变化 4.3.3 应用 // 对于int指针，p++，每次增加int类型的字节数(4byte) // 对于char指针，p++，每次增加char类型的字节数(1byte) 4.4 二维数组的创建和初始化 int main() { // 创建 int arr[3][4]; // 三行四列 char ch[3][4]; double dou[3][4]; // 初始化 int arr1[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; // 完全初始化 int arr2[3][4] = { {1, 2},{3, 4},{5, 6} }; // 每行初始化 int arr3[][4] = { {1, 2},{3, 4},{5, 6} }; // 省略行(但不能省略列) int ch[3][4] = {'h','e','l','l','o'}; // 不完全初始化 return 0; } 4.5 二维数组的使用 int main() { int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; for (int i = 0; i &lt; 3; i++) { for ( int j=0; j&lt;4; j++) { printf(&quot;%d &quot;, arr[i][j]); } printf(&quot;\\n&quot;); } return 0; } 4.6 二维数组在内存中的存储 int main() { int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 4; j++) { printf(&quot;arr[%d][%d]=%p\\n&quot;, i, j, &amp;arr[i][j]); } } return 0; } // 现象：每个元素相差4byte，恰好是int类型的大小 // 二维数组在内存中连续存放 4.7 数组作为函数参数 4.7.1 数组名 数组名是数组首元素的地址。 例外 sizeof(arr)获取的是整个数组的长度，单位：byte。 &amp;arr获取的是整个数组的地址。 int main() { int arr[5] = { 0 }; printf(&quot;arr =&gt; %p\\n&quot;, arr); printf(&quot;arr =&gt; %p\\n&quot;, arr+1); printf(&quot;&amp;arr =&gt; %p\\n&quot;, &amp;arr); printf(&quot;&amp;arr =&gt; %p\\n&quot;, &amp;arr+1); printf(&quot;&amp;arr[0] =&gt; %p\\n&quot;, &amp;arr[0]); printf(&quot;&amp;arr[0] =&gt; %p\\n&quot;, &amp;arr[0]+1); return 0; } 4.7.2 冒泡排序 // 两两相邻元素进行比较 void bubble_sort(int arr[], int count) // 形参arr本质是指针 { int i = 0; // 确定趟数 for ( i = 0; i &lt; count; i++) { int j = 0; // 每趟比较元素的次数 for ( j = 0; j &lt; count-1-i; j++) { if (arr[j] &gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } } int main() { int arr[] = { 1, 6, 3, 9, 4 }; int count = sizeof(arr) / sizeof(arr[0]); // 确定数组元素个数 bubble_sort(arr, count); // 数组在传参时，传递的时arr首元素的地址 for (int i = 0; i &lt; count; i++) // 打印排序结果 { printf(&quot;arr[%d]=%d\\n&quot;, i, arr[i]); } return 0; } 4.8 练习 4.8.1 逆序数组中元素个数 void reverse(int arr[], int size) { int left = 0; int right = size-1; while (left&lt;right) { int tmp = 0; tmp = arr[right]; arr[right] = arr[left]; arr[left] = tmp; left++; right--; } } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int size = sizeof(arr) / sizeof(arr[0]); reverse(arr, size); return 0; } 4.8.2 交换数组 将数组A中的内容和数组B中的内容进行交换（数组一样大） int main() { int arr1[3] = { 1, 2, 3 }; int arr2[3] = { 4, 5, 6 }; // 错误操作： //int arr3[3] = { 0 }; //arr3 = arr2; //arr2 = arr1; //arr1 = arr2; // 元素可以相互赋值，但数组名不可以相互赋值，因为数组名是数组首元素的地址 // // 正确操作： int size = sizeof(arr1) / sizeof(arr1[0]); for (int i = 0; i &lt; size; i++) { int tmp = 0; tmp = arr1[i]; arr1[i] = arr2[i]; arr2[i] = tmp; } return 0; } 4.9 实例 4.9.1 三子棋 4.9.2 扫雷 ","link":"https://listen2022.github.io/4-shu-zu/"},{"title":"3. C语言--函数","content":"3.函数 3.1 函数是什么 函数是指一段可以直接被另一段程序或代码引用的程序或代码。也叫做子程序、（OOP中）方法。一个较大的程序一般应分为若干个程序块，每一个模块用来实现一个特定的功能。所有的高级语言中都有子程序这个概念，用子程序实现模块的功能。在C语言中，子程序是由一个主函数和若干个函数构成的。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。 3.1.1 函数分类 自定义函数 库函数 3.2 库函数 一般是指编译器提供的可在C源程序中调用的函数。分为两类，C语言标准规定的库函数和编译器特定的库函数。 3.2.1 网站 Learn C and C++ Programming - Cprogramming.com C 标准库头文件 - cppreference.com https://docs.microsoft.com/en-us/cpp/c-runtime-library/c-run-time-library-reference?view=msvc-170 3.2.2 strcp 3.2.3 memset 3.3 自定义函数 // 格式： ret_type func_name( parameter list ) { body of the function } // return_type 函数的返回类型 // function_name 函数名称 // parameter list 参数列表 // body of the function 函数体 // 当函数不返回任何类型，ret_type为关键字void 实例 void Swap(int* pa, int* pb) { int z = 0; z = *pa; *pa = *pb; *pb = z; } int main() { int a = 10; int b = 20; printf(&quot;交换前 a=%d, b=%d\\n&quot;, a, b); Swap(&amp;a, &amp;b); printf(&quot;交换后 a=%d, b=%d\\n&quot;, a, b); } 重点 void Swap(int* pa, int* pb) { int* z = NULL; printf(&quot;%p %p %p\\n&quot;, pa, pb, z); z = pa; pa = pb; pb = z; printf(&quot;%p %p %p\\n&quot;, pa, pb, z); } // 不能通过交换a、b的地址交换a、b的数据 int main() { int a = 10; int b = 20; printf(&quot;交换前 a=%d, b=%d\\n&quot;, a, b); Swap(&amp;a, &amp;b); printf(&quot;交换后 a=%d, b=%d\\n&quot;, a, b); } 3.4 函数参数 3.4.1 实际参数(argument) 真实传递给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在进行调用时，它们都必须有确定的值，以便把这些值传送给形参。 3.4.2 形式参数(parameter) 形式参数是指函数名后括号中的变量，因为形参只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成后就自动销毁。因此形式参数只在函数中有效。 3.4.3 形参实例化之后其实相当于实参的一份临时拷贝。 3.5 函数调用 3.5.1 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 3.5.2 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 3.6 函数的嵌套调用和链式访问 3.6.1 嵌套调用 在函数A()中调用函数B() #include &lt;stdio.h&gt; int main() { printf(&quot;Hello World!\\n&quot;); return 0; } // 最简单的嵌套调用，在main函数中调用prinf函数 3.6.2 链式访问 把一个函数的返回值作为另一个函数的参数。 #include &lt;stdio.h&gt; int add(int x, int y) { return x + y; } int main() { printf(&quot;输出：%d\\n&quot;, add(3, 4)); } // 将add(3, 4)的返回值作为参数，传递给printf函数 3.7 函数的声明和定义 3.7.1 声明 告诉编译器函数名称及如何调用函数。 return_type function_name( parameter list ); // 在函数声明中 // 参数的名称并不重要 // 只有参数的类型是必需的 // 因此可省略声明中形参的名称 3.7.2 定义 return_type function_name( parameter list ) { body of the function } 3.8 函数递归 函数对自身的调用。 递归的必要条件 递归调用的过程 递归终止的条件 3.9 小知识 #include &quot; &quot; 与 &lt;&gt;有什么区别？ // 若 #include &quot;&quot; 查找成功，则遮蔽 #include &lt;&gt; 所能找到的同名文件 // 否则再按照 #include &lt;&gt; 的方式查找文件 // #include &lt;&gt; 的查找位置是标准库头文件所在目录 // #include &quot;&quot; 的查找位置是当前源文件所在目录 // &lt;&gt;先去系统目录中找头文件，如果没有在到当前目录下找 // &quot;&quot;首先在当前目录下寻找，如果找不到，再到系统目录中寻找 C语言函数默认返回类型 // C语言中函数如果没有定义返回值类型，则默认返回类型是int ","link":"https://listen2022.github.io/3-han-shu/"},{"title":"2. C语言--分支和循环语句","content":"2.分支和循环语句 2.1 分支语句 C语言把任何非零和非空的值假定为 true，把零或 null 假定为 false 2.1.1 if else if语句 if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } if...else... if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } else { /* 如果布尔表达式为假将执行的语句 */ } if...else if...else... 一个if后可跟一个或零个else语句，else必须在所有else if之后 一个if后可跟多个或零个else if语句，else if必须在else之前 一旦某个else if匹配成功，其他的else if或else将不会被测试 if(boolean_expression1) { /* 当布尔表达式1为真时执行 */ } else if(boolean_expression2) { /* 当布尔表达式2为真时执行 */ } else if(boolean_expression3) { /*当布尔表达式3为真时执行*/ } else { /* 当上面条件都不为真时执行 */ } 嵌套if语句 if( boolean_expression1) { /* 当布尔表达式1为真时执行 */ if(boolean_expression2) { /* 当布尔表达式2为真时执行 */ } } // 可以在一个if...else...或if...else if...else..语句中 // 嵌套一个if...else...或if...else if...else..语句 2.1.2 switch switch switch(expression){ case constant-expression : statement(s); break; /* 可选 */ case constant-expression : statement(s); break; /* 可选 */ default : /* 可选 */ statement(s); } expression为常量表达式，必须是一个整形或枚举类型 constant-expression必须和expression的数据类型相同，且为一个常量或字面量 当被测试的变量等于case中的常量时，case后面的语句执行，直到遇到break语句 default case中的break语句不是必须的 default语句可以放在任意位置 嵌套switch 一个switch语句种包含另一个switch语句 switch(expression1) { case constant-expression: switch(expression2) { case constant-expression: ... break; case constant-expression: ... } break; case constant-expression: ... } 2.1.3 :?运算符(三目运算符) Exp1 ? Exp2 : Exp3; // ? 表达式的值是由 Exp1 决定的。 // 如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值 // 如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值 2.2 循环语句 2.2.1 for for ( init; condition; increment ) { statement(s); } // init: 首先执行，声明并初始化循环控制变量，可留空 // condition: 判断，如果为真，执行statement(s)，否则结束循环 // increment: 执行完for循环主体statement(s);之后，执行increment语句。该语句一般是更新循环控制变量，可留空 2.2.2 while while(condition) { statement(s); // 一条语句或语句块 } 2.2.3 do while for和while循环在循环开始时测试循环条件，而do...while...在每次循环中执行statement(s)语句之后，测试循环条件。 do { statement(s); }while( condition ) // statement(s);至少被执行一次 2.2.4 嵌套循环 嵌套for循环 for (initialization; condition; increment/decrement) { statement(s); for (initialization; condition; increment/decrement) { statement(s); } } 嵌套while循环 while (condition1) { statement(s); while (condition2) { statement(s); } } 嵌套 do while 循环 do { statement(s); do { statement(s); }while (condition2); }while (condition1) 混合嵌套 2.3 循环控制语句 2.3.1 break 终止循环或switch语句。在嵌套语句中，终止break所在的最内层的循环或switch语句。 2.3.2 continue 结束本次循环，进行下一次迭代。 2.3.3 goto 控制转移到被标记的语句。但是不建议在程序中使用goto语句（使得程序的控制流难以跟踪，使程序难以理解和难以修改）。 goto label; ... ... label: statement; // goto语句只能在一个函数范围内跳转，不能跨函数 // 一般不使用，跳出多层嵌套时使用 2.4 无限循环 for( ; ; ) { ... } // 倾向于使用该语句实现无限循环 2.3 习题 2.3.1 最大公约数 最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。 一般方法 int main() { int a = 12; int b = 16; int max = a; // 为a、b中较小的一个赋值给最大公约数 if (max &gt; b) { max = b; } for (; max &gt;= 1 ; max--) { if (a % max == 0 &amp;&amp; b % max == 0) { printf(&quot;%d\\n&quot;, max); break; } } return 0; } 辗转相除法 欧几里得算法：gcd(a, b) = gcd(b, a mod b) int main() { int a = 12; int b = 16; int t = 0; while (t = a % b) { a = b; b = t; } printf(&quot;%d&quot;, b); return 0; } 2.3.2 最小公倍数 两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。 一般方法 int main() { int a = 12; int b = 16; int min = a; // 存放a、b中较大值 if (min&lt;b) { min = b; } for ( ; ; min++) { if (min % a == 0 &amp;&amp; min % b == 0) { printf(&quot;%d&quot;, min); break; } } return 0; } 公式法 最小公倍数 × 最大公约数 = a × b int main() { int a = 12; int b = 16; int mul = a * b; // a和b的乘积 int t = 0; while (t = a % b) { a = b; b = t; } printf(&quot;%d&quot;, mul / b); return 0; } 2.3.3 排序 问题描述：给定三个数，从大到小输出 int main() { int a = 3; int b = 8; int c = 5; if (a &lt; b) { int t = a; a = b; b = t; } if (a &lt; c) { int t = a; a = c; c = t; } if (b &lt; c) { int t = b; b = c; c = t; } printf(&quot;%d %d %d&quot;, a, b, c); return 0; } 2.3.4 闰年 闰年（Leap Year）是为了弥补因人为历法规定造成的年度天数与地球实际公转周期的时间差而设立的。补上时间差的年份为闰年。闰年共有366天（1月~12月分别为31天、29天、31天、30天、31天、30天、31天、31天、30天、31天、30天、31天）。 规则：四年一闰，百年不闰，四百年再闰。 方法一： int main() { int sum = 0; for (int i = 0; i &lt;= 2050; i++) { if ( 0 == i % 4) { if (0 == i % 100) { if (0 == i % 400) { printf(&quot;%d\\n&quot;, i); } } else { printf(&quot;%d\\n&quot;, i); } } } return 0; } 方法二： int main() { int sum = 0; for (int i = 0; i &lt;= 2050; i++) { if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || (i % 400 == 0 )) { printf(&quot;%d是闰年\\n&quot;, i); sum++; } } printf(&quot;sum = %d\\n&quot;, sum); } 2.3.5 素数(质数) 在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 int main() { for (int i = 2; i &lt;= 100; i++) { int j = i - 1; for ( ; j&gt;=1; j-- ) { if (0 == i % j) { break; } } if (j == 1) { printf(&quot;%d\\n&quot;, i); } } } 优化： int main() { for (int i = 2; i &lt;= 100; i++) { int flag = 1; // flag=1时为素数 int j = 2; for ( ; j*j &lt;= i ; j++) { if (0 == i % j) { flag = 0; // flag为0时不为素数 break; } } if (flag) { printf(&quot;%d\\n&quot;, i); } } } 2.3.6 goto使用 # Windows关机命令 shutdown -s -t 60 # 设置关机 shutdown -a # 取消关机 // C语言中使用system(&quot;&quot;)执行系统命令 // system()函数在&lt;stdlib.h&gt;头文件中 // C语言中两个字符串不能使用`==`比较大小 // 可使用strcmp(str1, str2)函数 // 字符串相等函数返回0，该函数在&lt;string.h&gt;头文件中 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char input[20] = { 0 }; Lable: system(&quot;shutdown -s -t 60&quot;); printf(&quot;电脑将在1min之后关机，请输入密码进行取消：&quot;); scanf(&quot;%s&quot;, input); if (0 == strcmp(input, &quot;123&quot;)) { system(&quot;shutdown -a&quot;); } else { goto Lable; } return 0; } 小问题 #define _CRT_SECURE_NO_WARNINGS // 源文件第一行（忽略VS的安全检测） ","link":"https://listen2022.github.io/2fen-zhi-he-xun-huan-yu-ju/"},{"title":"1. C语言--初始C语言","content":"1. 初始C语言 1.1 介绍 广泛应用于底层开发（如：驱动）。有完整的美国国家标准语法，称为ANDI C。C语言是一门面向过程的的计算机语言。主要的编译器有Clang、GCC、WIN-TC、Turbo C等。 国际标准：C89、C90、C99、C11（C90之后的标准没有火起来） 1.2 第一个C程序 1.2.1 编译器 Visual Studio、Dev C++、Visual C++ 6.0、GCC、Clang、Pelles C、Watcom C/C++、Tiny C Compiler、Code::Blocks、Turbo C、C-Free等 1.2.2 继承开发环境（IDE） VS2013/VS2019：集成开发环境，集成了windows下的C语言编译器 1.2.3 文件 xxx.c 源文件 xxx.h 头文件 1.2.4 步骤 创建项目 创建源文件 编写代码 主函数（main函数） #include &lt;stdio.h&gt; int main() { printf(&quot;Hello World!&quot;); return 0; } 编译、链接、运行代码 1.2.5 补充 一个项目中可以有多个.c文件 多个.c文件中有且仅有一个main函数 1.3 基本数据类型 在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。 1.3.1 整数类型 short (int) int long (int) long long (int) // 不同数据类型的大小因不同的计算机系统而异 // 编译器可以决定数据类型的大小但必须保证：short &lt;= int &lt;= long &lt;= long long 1.3.2 浮点类型 float // 单精度浮点型 double // 双精度浮点型 1.3.3 字符型 char // 可以当作整数类型处理 1.3.4 sizeof运算符 // sizeof(type) 得到对象或类型的存储字节大小 // 使用sizeof查看数据类型大小 int main() { printf(&quot;size of short %d\\n&quot;, sizeof(short)); printf(&quot;size of short %d\\n&quot;, sizeof(int)); printf(&quot;size of short %d\\n&quot;, sizeof(long)); printf(&quot;size of short %d\\n&quot;, sizeof(long long)); printf(&quot;size of short %d\\n&quot;, sizeof(float)); printf(&quot;size of short %d\\n&quot;, sizeof(double)); return 0; } 1.4 常量变量 1.4.1 变量 程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量定义 告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表。 type var_list; // type为C数据类型或自定义的对象 // var_list由一个或多个标识符组成，多个标识符之间使用逗号隔开 // eg: int a, b; char c; // 初始化：变量可以在声明时初始化（指定一个初始值） // eg: int a = 666; int x = 3, y = 4; 变量声明 向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 变量声明的两种情况： 1.需要建立存储空间。int a; 在声明时建立了存储空间 2.不需要建立存储空间。extern关键字声明变量而不定义 extern int a 其中变量a可以在其他c文件中定义 除非有extern关键字，其余都是变量的定义 左值和右值 左值（lvalue）：指向内存位置的表达式。左值可以出现在赋值号的左边或右边。变量时左值。 右值（rvalue）：存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。数值型字面量是右值。 1.4.2 常量 固定值。程序执行期间不会改变。又称为字面量。 可以是任何数据类型。比如：整数常量、浮点常量、字符常量、字符串字面值、枚举常量。 可认为是常规的变量，只不过在定义后不能修改。 转义字符：特定字符前有反斜杠，具有特殊含义。 /* 常量定义的方式： 1. #define预处理器 格式：#define identifier value 2. const关键字（const声明常量要在一条语句内完成） 格式：const type variable = value; 3. 枚举常量（本质：数字由字符来表达） 格式：enum 枚举类型名称 {符号变量a, 符号变量b, 符号变量c}; a、b、c的值从零开始递增 指定值：enum COLOR {red=1,yellow,green=5}; 则red=1,yellow=2,green=5(默认递增) 重点：枚举类型只能是int */ 1.5 字符串 本质：使用null字符\\0终止的一维字符数组 1.6 注释 解释代码 // C++注释风格，最后引入C语言中/*C语言注释风格不支持嵌套注释*/ 1.7 选择语句 /*分支语句*/ int main() { int a = 1; if (a==1) { printf(&quot;a = 1&quot;); } else { printf(&quot;a != 1&quot;); } return 0; } 当if或else内只有一条语句时可省略大括号 1.8 循环语句 /* 循环语句 */int main() { int line = 0; while (line &lt; 30000) { printf(&quot;coding: %d\\n&quot;, line); line++; } if (line==30000) { printf(&quot;进大厂 拿高薪\\n&quot;); } return 0;} while循环内只有一条语句时可省略大括号 1.9 函数 /* 函数 */int main(){ int a = 3; int b = 4; int result = 0; result = Add(a, b); printf(&quot;result =&gt; %d\\n&quot;, result); return 0;}int Add(int x, int y){ int result = 0; result = x + y; return result;} 1.10 数组 一组相同类型的元素的集合 // 数组int main(){ // 创建 int arr[10] = { 0,1,2,3,4,5,6,7,8,9 }; // 其中arr为数组名 int为数组中每个元素的类型 10为数组中元素的个数 char ch[10] = { 'a', 'b', 'c', 'd', 'e' }; // 不完全初始化，其余值默认为0 // 访问(利用每个元素的下标 索引从零开始依次往后) int i = 0; while (i&lt;10) { printf(&quot;arr[%d] =&gt; %d\\n&quot;, i, arr[i]); i++; } return 0;} 1.11 操作符 1.11.1 算数操作符 + - * / % 1.11.2 移位操作符 &gt;&gt; &lt;&lt; 1.11.3 位操作符 &amp; 按位与| 按位或^ 按位异或 1.11.4 赋值操作符 = += -= *= /= &gt;&gt;= &lt;&lt;= 1.11.5 单目操作符 ！ // 逻辑非运算符~ // 按位取反运算符++ -- // 自增自减运算符- // 负号运算符(type) // 类型转换运算符*和&amp; // 指针运算符和取地址运算符sizeof // 长度运算符 sizeof求变量时后面的括号可以省略 求类型时不可以省略 // sizeof(int) sizeof(a) // 可以计算数组，单位是字节 1.11.6 关系操作符 == != &gt; &gt;= &lt; &lt;= 1.11.7 逻辑运算符 &amp;&amp; // 逻辑与 || // 逻辑或 ! // 逻辑非 1.11.8 条件操作符 // 三目操作符 exp1 ? exp2 : exp3; // exp1成立，exp2执行，整个表达式的结果为exp2的结果 // exp1不成立，exp3执行，整个表达式结果为exp3的结果 1.11.9 逗号表达式 // 逗号隔开的一串表达式 exp1, exp2, exp3; eg: (2, 2+1, 2+2, 2+3); // 从前往后计算，整个表达式的结果是最后一个表达式的结果 1.11.10 其他 [] // 下标引用操作符() // 函数调用操作符.-&gt; 自增/自减 // 前置++： 先++后使用int main(){ int a = 6; int b = ++a; printf(&quot;%d\\n&quot;, a); // 7 printf(&quot;%d\\n&quot;, b); // 7 return 0;} // 后置++： 先使用后++int main(){ int a = 6; int b = a++; printf(&quot;%d\\n&quot;, a); // 7 printf(&quot;%d\\n&quot;, b); // 7 return 0;} 强制类型转换 int main() { int pi = (int)3.1415926; return 0; } 1.12 关键字(32个) C语言保留的一些有特殊作用词语。变量名不能是关键字。 auto 声明自动变量。自动创建、自动销毁。修饰局部变量，可省略。 double 声明双精度变量或函数 typedef 用以给数据类型取别名 register 声明寄存器变量 short 声明短整型变量或函数 char 声明字符型变量或函数 const 声明只读变量 static 声明静态变量 int 声明整型变量或函数 struct 声明结构体变量或函数 unsigned 声明无符号类型变量或函数 volatile 说明变量在程序执行中可被隐含地改变 long 声明长整型变量或函数 union 声明共用数据类型，共用体 signed 声明有符号类型变量或函数 void 声明函数无返回值或无参数，声明无类型指针 float 声明浮点型变量或函数 enum 声明枚举类型 extern 声明变量是在其他文件正声明 if 条件语句 else 条件语句否定分支（与 if 连用） switch 用于开关语句 case 开关语句分支 for 一种循环语句 do 循环语句的循环体 while 循环语句的循环条件 goto 无条件跳转语句 continue 结束当前循环，开始下一轮循环 break 跳出当前循环 default 开关语句中的&quot;其他&quot;分支 sizeof 计算数据类型长度 return 子程序返回语句（可以带参数，也可不带参数）循环条件 其他 define、include不是关键字，是预处理指令 typedef // 类型别名 类型重命名 用来简化代码 static /*三种用法： 1.修饰局部变量：局部变量生命周期延长（本质：改变了数据类型，从栈区-&gt;静态区） 2.修饰全局变量：使全局变量只能在自己所在的源文件.c内部使用，即使在其他源文件种声明也不能使用改全局变量 3.修饰函数：使函数只能在自己的内部源文件.c种使用，项目中其他源文件不能使用*/ 示例 static修饰局部变量 static修饰全局变量 static修饰函数 1.13 define define使预处理指令 /*作用： 1. 定义常量 2. 定义宏（宏用来完成替换）*/ 1.13.1 定义变量 1.13.2 定义宏 // 宏只完成替换// 为保证正常运行，应使用小括号将函数体括起来 1.14 指针 指针描述了数据在内存中的位置（内存地址），标示了一个占据存储空间的实体。 C/C++语言中，指针一般被认为是指针变量，指针变量的内容存储的是其指向的对象的首地址，指向的对象可以是变量（指针变量也是变量），数组，函数等占据存储空间的实体。 1.14.1 指针变量的声明 // 格式；type *var_name;// type使指针的基类型，*表示该变量是一个指针变量，var_name使变量名// eg:int* pi;double* pd; 1.14.2 指针变量的大小 // 在32位系统种，指针变量大小为4byte// 在64位系统种，指针变量大小位8byte// 指针变量大小与指针指向的数据类型无关// 下图为64位系统种，指针大小演示： 1.14.2 访问数据地址 // 格式： &amp;var_name // 通过&amp;获取var_name所在的内存地址 // eg: int main() { int a = 666; int* pa = &amp;a; // 去除变量a的地址并赋值给指针变量pa printf(&quot;%p\\n&quot;, pa); return 0; } 1.14.3 NULL指针 // NULL指针：空指针，是一个定义在标准库中的值为零的常量。 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。 1.15 结构体 结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构用于表示一条记录。 1.15.1 定义 // 格式：struct 结构体名 { 结构体所包含的变量};// eg:struct Student{ char name[16]; // 姓名 int age; // 年龄 double height; // 身高}; 1.15.2 结构体变量 定义结构体时定义结构体变量 struct Student { char name[16]; // 姓名 int age; // 年龄 double height; // 身高 } s1, s2; // 将变量放在结构体的最后 如果只需要是使用s1和s2，此后不再使用结构体，则可省略结构体名称 struct{ char name[16]; // 姓名 int age; // 年龄 double height; // 身高 } s1, s2; 1.15.3 成员获取和赋值 获取 // 1).结构体变量名.成员名 printf(&quot;name: %s, age: %d, height: %lf\\n&quot;, s.name, s.age, s.height); // 2).结构体指针变量名-&gt;成员名 struct Student* ps = &amp;s; printf(&quot;name: %s, age: %d, height: %lf\\n&quot;, (*ps).name, (*ps).age, (*ps).height); printf(&quot;name: %s, age: %d, height: %lf\\n&quot;, ps-&gt;name, ps-&gt;age, ps-&gt;height); 赋值 // 1).单个赋值：结构体变量名.成员名 = &quot;Value&quot;; // 2).整体赋值，eg： // a.定义结构体时整体赋值： struct{ char name[16]; // 姓名 int age; // 年龄 double height; // 身高 } s = {&quot;listen&quot;, 20, 180.5}; // b.定义结构体后整体赋值： struct Student s = {&quot;listen&quot;, 20, 185}; // 结构体是创建变量的模板，不占用内存空间 // -&gt; 先找到指针指向的对象，再找到他的成员 ","link":"https://listen2022.github.io/1chu-shi-c-yu-yan/"}]}